<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows内核函数]]></title>
    <url>%2F2019%2F09%2F12%2FWindows%20%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Windows 内核函数Windows 内核部分会调用一些内核层的函数。这些函数都以固定的开始前缀，分别属于内核中不同的管理模块。通过函数名就可以大致知道这个函数所属的层次和模块。这些主要的前缀如下： * Ex：管理层。“Ex”是“Executive”的开头两个字母。 * Ke：核心层。“Ke”是“Kernel”的开头两个字母。 * HAL：硬件抽象层。“HAL”是“Hardware Abstraction Layer”的缩写。 * Ob：对象管理。“Ob”是“Object”的开头两个字母。 * MM：内存管理。“MM”是“Memory Manager”的缩写。 * Ps：进程（线程）管理。“Ps”表示“Process”。 * Se：安全管理。“Se”是“Security”的开头两个字母。 * Io：I/O管理。 * Fs：文件系统。“Fs”是“File System”的缩写。 * Cc：文件缓存管理。“Cc”表示“Cache”。 * Cm：系统配置管理。“Cm”是“Configuration Manager”的缩写。 * Pp：即插即用管理。“Pp”表示“Pnp”。 * Rtl：运行时程序库。“Rtl”是“Runtime Library”的缩写。 * Zw/Nt：对应于SSDT中的服务函数，例如与文件或者注册表相关的操作函数。 * Flt：Minifilter文件过滤驱动中调用的函数。 * Ndis：Ndis网络框架中调用的函数。]]></content>
      <tags>
        <tag>Windows内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5算法学习]]></title>
    <url>%2F2019%2F09%2F10%2FMD5%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、题目内容 这里有一段丢失的md5密文 e9032???da???08????911513?0???a2要求你还原出他并且加上nctf{}提交 已知线索 明文为：TASC?O3RJMV?WDJKX?ZM 。 题目来源：安恒杯 简单的MD5密码碰撞，通过对比密文e9032与加密后的数据，定位相关信息。我用Python写了一个简单的解题代码，运行后得出密文。3. 解题代码如下1234567891011121314151617181920import md5Enable = &#123;'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q', 'R','S','T','U','V','W','X','Y','Z','1','2','3','4','5','6','7','8', '9',' ', '!', '"', '#', '$', '%', '&amp;', '\'', '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '&lt;', '=', '&gt;', '?', '@','[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k','l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '&#123;', '|', '&#125;', '~'&#125;fiveCode = ""for i in Enable: for j in Enable: for k in Enable: strToDecode = "TASC" + i + "O3RJMV" + j + "WDJKX" + k + "ZM" m1 = md5.new() m1.update(strToDecode) cipher = m1.hexdigest() fiveCode = cipher[0:5] if fiveCode == "e9032": print "密文：" + cipher 结果如下： 1密文：e9032994dabac08080091151380478a2 4、MD5算法1、算法原理 （1）数据填充 填充消息使其长度与448模512同余（即长度=448 mod 512）.也就是说，填充后的消息长度比512的倍数小64位。填充方法：附一个1在消息后面，然后用0来填充，直到消息的长度与448模512同余。至少填充1位，至多填充512位。 （2）添加长度 在上一步的结果之后附上64位的消息长度。如果填充前消息长度大于2^64，则只使用其低64位。添加填充位和消息长度之后，最终消息的长度正好是512的整数倍。 （3）初始化变量 用四个变量（A、B、C、D）来计算消息摘要。这里的A、B、C、D都是32位的寄存器。这些寄存器以下面的十六进制来初始化： A=01234567h，B=89abcdefh，C=fedcbah，D=76543210h 而且，在内存中是以低字节在前的形式储存的，格式如下： 01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10 （4）数据处理 以512位分组为单位处理消息。首先定义4个辅助函数，每个都是以3个32为双字作为输入，输出1个32位双字。 F(X，Y，Z) = (X&amp;Y)|((~X)&amp;Z) G(X，Y，Z) = (X&amp;Z)|(Y&amp;(~Z)) H(X，Y，Z) = X^Y^Z I(X，Y，Z) = Y^X|(~Z) 注：&quot;&amp;&quot;是与操作，&quot;|&quot;是或操作，&quot;~&quot;是非操作，&quot;^&quot;是异或操作。 这四轮变换是对进入主循环的521位消息分组的16个32位字分别进行如下操作：将A、B、C、D的副本a、b、c、d中的3个经F、G、H、I运算后的结果与第4个相加，再加上32位字和一个32位字的加法常数，并将所得的值循环左移若干位，最后结果加上啊a、b、c、d其中一个，并回送至A、B、C、D，由此完成一次循环。 所用的加法常数由表T[i]来定义，其中i为1至64之中的值。T[i]等于4294967296乘以abs(sin(i))所得结果的整数部分，其中i用弧度来表示。 FF(a, b, c, d, M[j], s, ti)表示 a = b + ((a + F(b, c, d) + Mj + ti) &lt;&lt;&lt; s) GG(a, b, c, d, M[j], s, ti)表示 a = b + ((a + G(b, c, d) + Mj + ti) &lt;&lt;&lt; s) HH(a, b, c, d, M[j], s, ti)表示 a = b + ((a + H(b, c, d) + Mj + ti) &lt;&lt;&lt; s) II(a, b, c, d, M[j], s, ti)表示 a = b + ((a + I(b, c, d) + Mj + ti) &lt;&lt;&lt; s) For i = 0 to N/16-1 do For j = 0 to 15 do Set X[j] to M[i*16+j] AA=A; BB=B; CC=C; DD=D FF(a,b,c,d,M[0],7,0xd76aa478) ; FF(d,a,b,c,M[1],12,0xe8c7b756) ; FF(c,d,a,b,M[2],17,0x242070db) ; FF(b,c,d,a,M[3],22,0xc1bdceee) ; FF(a,b,c,d,M[4],7,0xf57c0faf) ; FF(d,a,b,c,M[5],12,0x4787c62a) ; FF(c,d,a,b,M[6],17,0xa8304613) ; FF(b,c,d,a,M[7],22,0xfd469501) ; FF(a,b,c,d,M[8],7,0x698098d8) ; FF(d,a,b,c,M[9],12,0x8b44f7af) ; FF(c,d,a,b,M[10],17,0xffff5bb1); FF(b,c,d,a,M[11],22,0x895cd7be); FF(a,b,c,d,M[12],7,0x6b901122) ; FF(d,a,b,c,M[13],12,0xfd987193); FF(c,d,a,b,M[14],17,0xa679438e); FF(b,c,d,a,M[15],22,0x49b40821); GG(a,b,c,d,M[1],5,0xf61e2562) ; GG(d,a,b,c,M[6],9,0xc040b340) ; GG(c,d,a,b,M[11],14,0x265e5a51); GG(b,c,d,a,M[0],20,0xe9b6c7aa) ; GG(a,b,c,d,M[5],5,0xd62f105d) ; GG(d,a,b,c,M[10],9,0x02441453) ; GG(c,d,a,b,M[15],14,0xd8a1e681); GG(b,c,d,a,M[4],20,0xe7d3fbc8) ; GG(a,b,c,d,M[9],5,0x21e1cde6) ; GG(d,a,b,c,M[14],9,0xc33707d6) ; GG(c,d,a,b,M[3],14,0xf4d50d87) ; GG(b,c,d,a,M[8],20,0x455a14ed) ; GG(a,b,c,d,M[13],5,0xa9e3e905) ; GG(d,a,b,c,M[2],9,0xfcefa3f8) ; GG(c,d,a,b,M[7],14,0x676f02d9) ; GG(b,c,d,a,M[12],20,0x8d2a4c8a); HH(a,b,c,d,M[5],4,0xfffa3942) ; HH(d,a,b,c,M[8],11,0x8771f681) ; HH(c,d,a,b,M[11],16,0x6d9d6122); HH(b,c,d,a,M[14],23,0xfde5380c); HH(a,b,c,d,M[1],4,0xa4beea44) ; HH(d,a,b,c,M[4],11,0x4bdecfa9) ; HH(c,d,a,b,M[7],16,0xf6bb4b60) ; HH(b,c,d,a,M[10],23,0xbebfbc70); HH(a,b,c,d,M[13],4,0x289b7ec6) ; HH(d,a,b,c,M[0],11,0xeaa127fa) ; HH(c,d,a,b,M[3],16,0xd4ef3085) ; HH(b,c,d,a,M[6],23,0x04881d05) ; HH(a,b,c,d,M[9],4,0xd9d4d039) ; HH(d,a,b,c,M[12],11,0xe6db99e5); HH(c,d,a,b,M[15],16,0x1fa27cf8); HH(b,c,d,a,M[2],23,0xc4ac5665) ; II(a,b,c,d,M[0],6,0xf4292244) ; II(d,a,b,c,M[7],10,0x432aff97) ; II(c,d,a,b,M[14],15,0xab9423a7); II(b,c,d,a,M[5],21,0xfc93a039) ; II(a,b,c,d,M[12],6,0x655b59c3) ; II(d,a,b,c,M[3],10,0x8f0ccc92) ; II(c,d,a,b,M[10],15,0xffeff47d); II(b,c,d,a,M[1],21,0x85845dd1) ; II(a,b,c,d,M[8],6,0x6fa87e4f) ; II(d,a,b,c,M[15],10,0xfe2ce6e0); II(c,d,a,b,M[6],15,0xa3014314) ; II(b,c,d,a,M[13],21,0x4e0811a1); II(a,b,c,d,M[4],6,0xf7537e82) ; II(d,a,b,c,M[11],10,0xbd3af235); II(c,d,a,b,M[2],15,0x2ad7d2bb) ; II(b,c,d,a,M[9],21,0xeb86d391) ; A = A+AA; B = B+BB; C = C+CC; D = D+DD （5）输出 当512位分组都运算完毕，A、B、C、D的连级将被输出为MD5散列的结果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[一道RE学习：IngiteMe]]></title>
    <url>%2F2019%2F09%2F10%2FIgniteMe%E9%80%86%E5%90%91%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、RE-IgniteMe这道题来自XCTF社区，比较简单。 题目链接：https://adworld.xctf.org.cn/media/task/attachments/fac4d1290e604fdfacbbe06fd1a5ca39.exe2、解题思路下载好后我们发现这是一个EXE文件，先拖入PEID查壳看看，发现没有壳。直接运行，题目要求你输入flag，我们用IDA打开，进入_main函数，按F5 我们可以发现一串“Congratulations！”字符，这里应该就是关键判断，双击它sub_4011C0函数，进入查看 可以看到末尾的关键字符串，从后往前推，它的主要算法是异或和加减以及大小写字母之间的转换，我用C语言写了段代码进行解码，代码如下： 12345678910111213141516171819202122int main()&#123; int i; char str[32] = "GONDPHyGjPEKruv&#123;&#123;pj]X@rF"; int num[32] = &#123;0x0D, 0x13,0x17,0x11,2,1, 0x20,0x1D,0x0C,2,0x19,0x2F,0x17,0x2B,0x24, 0x1F,0x1E,0x16,9,0x0F,0x15,0x27,0x13,0x26, 0x0A,0x2F,0x1E,0x1A,0x2D,0x0C,0x22,4&#125;; for(i = 0; str[i] !='\0'; i++) &#123; str[i] = ((str[i]^num[i])-72)^0x55; if(str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') str[i] -= 32; if(str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') str[i] += 32; &#125; printf("EIS&#123;%s&#125;\n",str); return 0;&#125; 运行后得出flag： 1EIS&#123;wadx_tdgk_aihc_ihkn_pjlm&#125; 3、总结逆向过程需要耐心和不断地尝试。]]></content>
      <tags>
        <tag>XCTF-RE</tag>
      </tags>
  </entry>
</search>
